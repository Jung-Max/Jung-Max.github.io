{"meta":{"title":"Max's Blog","subtitle":"개발시 정리사항 끄적끄적","description":"개발시 정리했던 사항을 끄적이기 위한 블로그","author":"Jung Max","url":"http://jung-max.github.io","root":"/"},"pages":[],"posts":[{"title":"우분투에서 libcurl 사용","slug":"Linux-libcurl 우분투에서 libcurl 사용","date":"2022-02-14T08:04:16.000Z","updated":"2022-02-14T08:14:33.690Z","comments":true,"path":"2022/02/14/Linux-libcurl 우분투에서 libcurl 사용/","link":"","permalink":"http://jung-max.github.io/2022/02/14/Linux-libcurl 우분투에서 libcurl 사용/","excerpt":"","text":"설치아래와 같이 libcurl을 설치한다. 1$ sudo apt-get install libcurl4-openssl-dev 다음 커맨드로 빌드옵션을 알 수 있다. 12$ curl-config --cflags$ curl-config --libs 아래의 명령어로 빌드 가능하다. (test.c 빌드시) 1$ gcc -o test test.c -L/usr/lib/x86_64-linux-gnu -lcurl 그 후 아래의 명령어로 실행 가능하다. 1$ ./test 예제rest api를 통해서 http get을 얻어오는 예제이다. 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;curl/curl.h&gt; int main(void)&#123; CURL *curl; CURLcode res; curl = curl_easy_init(); if(curl) &#123; curl_easy_setopt(curl, CURLOPT_URL, \"https://reqres.in/api/users/1\"); /* example.com is redirected, so we tell libcurl to follow redirection */ curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L); /* Perform the request, res will get the return code */ res = curl_easy_perform(curl); /* Check for errors */ if(res != CURLE_OK) fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res)); /* always cleanup */ curl_easy_cleanup(curl); &#125; return 0;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"buildroot 보드 ssh 설정","slug":"Linux-buildroot-보드-ssh설정","date":"2022-02-10T07:57:17.000Z","updated":"2022-02-14T08:15:20.720Z","comments":true,"path":"2022/02/10/Linux-buildroot-보드-ssh설정/","link":"","permalink":"http://jung-max.github.io/2022/02/10/Linux-buildroot-보드-ssh설정/","excerpt":"","text":"개요roc-rk3308b-cc-plus 보드는 여러 컴파일 옵션이 있지만 기본으로 buildroot로 sdk를 컴파일 합니다. 보드의 좀더 쉬운 컨트롤를 위해서 ssh를 설치했는데 이 방법을 공유해보겠습니다. buildroot sdk 컴파일기본 sdk에는 ssh가 깔려있지 않습니다. ssh를 수동으로 추가하긴 힘드므로 sdk를 컴파일 할때 sdk를 추가해줍니다. 일단 추가를 위해서 buildroot 폴더에서 make menuconfig를 실행합니다. 1root@ubuntu:~/workspace/rk3308b_sdk_linux/buildroot# make menuconfig 그럼 아래와 같이 창이 뜨게 됩니다. 여기서 다음을 체크해 줍니다. 12Target packages &gt; Filesystem and flash utilities &gt; sshfs (FUSE)Target packages &gt; Networking applications &gt; openssh sshfs는 마운트를 위한 것으로 필요하지 않다면 깔지 않아도 됩니다.openssh가 기본으로 설정되있다면 sdk를 컴파일 하지 않아도 됩니다. root password 설정기본적으로 root는 패스워드가 설정되있지 않습니다. 패스워드 설정을 위해 아래와 같이 입력합니다. 1passwd 그러면 root의 암호를 변경할 수 있습니다. ssh 동작 확인기본적으로 ssh가 기본으로 실행되고 있습니다. 아래와 같은 방법으로 확인 가능합니다. 12root@ubuntu:~/# ps -aef | grep sshd 800 root 4808 S /usr/sbin/sshd ssh root 로그인 설정기본적으로 ssh는 root로 로그인이 불가능 합니다. 아래와 같은 방법으로 root로그인을 허용해 줍니다. 1vi /etc/ssh/sshd_config 해당 파일에서 PermitRootLogin을 yes로 변경해 줍니다. 1PermitRootLogin yes 그 후 reboot을 합니다. ssh 접속기본적으로 wifi로 네트워크 접속이 필요합니다. wifi 접속 방법은 여기를 참고해주세요. wifi 접속 후 ifconfig를 치면 wlan0에 ip주소가 표시됩니다. 해당 ip주소와 22번 port, id : root, password는 위에서 설정했던 것으로 ssh접속을 하면 됩니다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"buildroot","slug":"Linux/buildroot","permalink":"http://jung-max.github.io/categories/Linux/buildroot/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"}]},{"title":"rk-roc3308b-plus cross compile","slug":"Linux-rk-roc3308b-plus-cross-complie","date":"2022-02-10T07:57:17.000Z","updated":"2022-02-14T08:15:20.720Z","comments":true,"path":"2022/02/10/Linux-rk-roc3308b-plus-cross-complie/","link":"","permalink":"http://jung-max.github.io/2022/02/10/Linux-rk-roc3308b-plus-cross-complie/","excerpt":"","text":"개요buildroot sdk가 올라간 보드에서는 컴파일이 불가능 합니다. 그렇기 때문에 Cross compiling을 사용해서 컴파일을 진행해야 합니다. Cross compiling toolssdk를 컴파일 한 폴더를 기준으로 아래의 경로를 찾아갑니다. 1cd buildroot/output/firefly_rk3308_release/host/usr/bin/ 그러면 Cross compiling tool을 이용해서 바로 컴파일이 가능합니다. 1./buildroot/output/firefly_rk3308_release/host/usr/bin/aarch64-rockchip-linux-gnu-gcc main.c -o test 해당 파일을 타겟 보드에 옮기고 실행을 합니다. 1./test 만약 permison error가 발생한다면 아래와 같이 권한을 수정합니다. 1chmod 777 test","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"buildroot","slug":"Linux/buildroot","permalink":"http://jung-max.github.io/categories/Linux/buildroot/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"}]},{"title":"rk-roc3308b-plus 보드 wifi config","slug":"Linux-rk-roc3308b-plus-보드-wifi-config","date":"2022-02-10T07:57:17.000Z","updated":"2022-02-14T08:15:20.721Z","comments":true,"path":"2022/02/10/Linux-rk-roc3308b-plus-보드-wifi-config/","link":"","permalink":"http://jung-max.github.io/2022/02/10/Linux-rk-roc3308b-plus-보드-wifi-config/","excerpt":"","text":"네트워크 구성무선 네트워크 구성‘wpa_supplicant’ 도구는 무선 네트워크 구성에 사용됩니다.주로 wpa_supplicant 및 wpa_cli의 두 가지 프로그램을 포함하는 WIFI 연결 및 구성을 위한 도구입니다. 커맨드 라인와이파이 활성화12echo 1 &gt;/sys/class/rkwifi/driverifconfig wlan0 up 완료되면 ifconfig 명령을 실행하면 wlan0 노드를 볼 수 있습니다. wpa_supplicant 프로세스 시작1wpa_supplicant -B -i wlan0 -c /data/cfg/wpa_supplicant.conf 파일 생성: /data/cfg/wpa_supplicant.conf 파일이 없으면 다음 구성을 추가해야 합니다. 123vi /data/cfg/wpa_supplicant.confctrl_interface=/var/run/wpa_supplicantap_scan=1 wpa_cli로 WIFI 구성일반적인 명령: 123wpa_cli -i wlan0 scan // Search wifi network nearbywpa_cli -i wlan0 scan_result // Print the searched WiFi networkwpa_cli -i wlan0 add_network // Add a network connection 무선 네트워크가 [WPA-PSK-CCMP+TKIP] [WPA2-PSK-CCMP+TKIP] [ESS](wpa 암호화)로 암호화되고 Wi-Fi 이름: 이름, Wi-Fi 암호: psk. 연결 작업은 다음과 같습니다. 123wpa_cli -i wlan0 set_network 0 ssid &apos;&quot;name&quot;&apos;wpa_cli -i wlan0 set_network 0 psk &apos;&quot;psk&quot;&apos;wpa_cli -i wlan0 enable_network 0 //Enable WiFi 무선 네트워크가 [WEP] [ESS](wep 암호화)로 암호화되어 있고 wifi 이름: 이름, wifi 암호: psk. 연결 작업은 다음과 같습니다. 1234wpa_cli -i wlan0 set_network 0 ssid &apos;&quot;name&quot;&apos;wpa_cli -i wlan0 set_network 0 key_mgmt NONEwpa_cli -i wlan0 set_network 0 wep_key0 &apos;&quot;psk&quot;&apos;wpa_cli -i wlan0 enable_network 0 무선 네트워크가 [ESS](암호화 없음)로 암호화되어 있고 Wi-Fi 이름: 이름인 경우 연결 작업은 다음과 같습니다. 123wpa_cli -i wlan0 set_network 0 ssid &apos;&quot;name&quot;&apos;wpa_cli -i wlan0 set_network 0 key_mgmt NONEwpa_cli -i wlan0 enable_network 0 WIFI 연결 정보 저장: 1wpa_cli -i wlan0 save_config 저장된 연결 재개:저장된 연결 재개: 123wpa_cli -i wlan0 list_network // List all saved connectionswpa_cli -i wlan0 select_network 0 // Connect the first saved connectionwpa_cli -i wlan0 enable_network 0 // Enable the first saved connection WiFi 끄기: 1ifconfig wlan0 down WIFI 구성 파일다음 파일을 수정합니다. 123vi /data/cfg/wpa_supplicant.confctrl_interface=/var/run/wpa_supplicantap_scan=1 다음 항목을 추가합니다. 123456network=&#123;ssid=&quot;WiFi-AP&quot; // WiFi namepsk=&quot;12345678&quot; // WiFi passwordkey_mgmt=WPA-PSK // Encryption# key_mgmt=NONE // No encryption&#125; 위의 구성을 다시 로드합니다. 1wpa_cli reconfigure 재접속: 1wpa_cli reconnect 휴대폰으로 WIFI 구성휴대폰을 사용하여 Softap 또는 Bluetooth를 통해 WiFi 네트워크를 구성하는 방법에는 여러 가지가 있습니다. 통합 음성 인식 SDK에는 “小度之家 SDK”와 같은 자체 방법도 포함될 것입니다. 여기에서는 ROC-RK3308B-CC의 내장 네트워크 구성 방법을 소개합니다. SoftAP로 WIFI 네트워크 구성Download the APP: RkEcho.apk, 또는 SDK:SDK/external/app/RkEcho.apk에서 찾을 수 있습니다. 빌드루트 구성: softapServer의 소스 디렉토리: 12/external/softapServer/ -- operations related to WIFI and APK /external/softapDemo/ -- operations related to WiFi apk RkEcho.apk를 설치하려면 휴대폰을 준비하세요. 필수입니다. 그런 다음 wpa_supplicant 프로세스가 시작되었는지 확인합니다. 1wpa_supplicant -B -i wlan0 -c /data/cfg/wpa_supplicant.conf 다음과 같이 WIFI 네트워크를 구성합니다. 다음 명령 실행: 1softapServer Rockchip-Echo-123 참고: Wi-Fi AP는 Rockchip-Echo-xxx 형식으로 이름을 지정해야 합니다. AP를 켠 후, 휴대폰의 WiFi 설정을 열고 Rckchip-Echo-123과 같이 방금 설정한 AP로의 연결을 클릭합니다. 연결이 완료되면 휴대폰에 설치된 apk를 열고 다음 작업을 수행합니다. APK를 열고 와이파이 설정 클릭 -&gt; 확인 -&gt; 确认 -&gt; 와이파이 목록 -&gt; 연결할 네트워크 클릭 -&gt; 비밀번호 입력 -&gt; 확인 클릭. 네트워크에 알리라는 음성 안내가 연결되면 사용 시작! 네트워크가 연결되어 있는지 확인: 1ping www.google.com 주의사항: softspServer Rockchip-Echo-123 명령이 실행되면 네트워크 구성이 완료될 때까지 철회할 수 없습니다. 잘못된 AP 이름을 설정하지 마십시오. 그렇지 않으면 apk가 확인 인터페이스(Rockchip-Echo-xxx)에 들어가지 않습니다. 이 기능은 현재 안드로이드 폰만 지원합니다. Ethernet이더넷 사용 eth0 1ifconfig eth0 up eth1 1ifconfig eth1 up IP 주소 설정동적으로 IP 주소 얻기WIFI는 동적으로 IP 주소를 획득하고 다음 명령을 실행합니다. 1udhcpc -i wlan0 -R 이더넷은 동적으로 IP 주소를 획득하고 다음 명령을 실행합니다. eth0 1udhcpc -i eth0 -R eth1 1udhcpc -i eth1 -R 고정 IP 주소 설정eth0에 대한 고정 IP 주소 설정 단계는 다음과 같습니다. 12345ip addr add 168.168.100.78/255.255.0.0 dev eth0 #ip address/subnet maskip route flush dev eth0ip route add 168.168.0.1 dev eth0 #gatewayip route add default via 168.168.0.1 dev eth0 #add default routerecho -e &quot;nameserver 114.114.114.114\\nnameserver 8.8.8.8&quot; &gt; /userdata/resolv.conf #set DNS WIFI 또는 eth1의 고정 IP 주소 단계는 위와 동일합니다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"buildroot","slug":"Linux/buildroot","permalink":"http://jung-max.github.io/categories/Linux/buildroot/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"}]},{"title":"libcurl example","slug":"Linux-libcurl example","date":"2022-02-09T07:31:07.000Z","updated":"2022-02-09T08:47:55.291Z","comments":true,"path":"2022/02/09/Linux-libcurl example/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl example/","excerpt":"","text":"libcurl examplehttps://curl.se/libcurl/c/example.html도 참고하세요. libcurl용 기본 API는 C로 되어 있으므로 이 장은 C로 작성된 예제에 초점을 맞춥니다. 그러나 libcurl용 언어 바인딩이 얇기 때문에 일반적으로 거의 동일한 기능을 노출하므로 여전히 흥미롭고 교육적일 수 있습니다. 다른 언어도 마찬가지입니다. 간단한 HTTP 페이지 가져오기이 예제는 주어진 URL에서 HTML을 가져와서 stdout으로 보냅니다. 아마도 가장 간단한 libcurl 프로그램을 작성할 수 있습니다. URL을 교체하면 물론 지원되는 다른 프로토콜을 통해서도 콘텐츠를 가져올 수 있습니다. 출력을 stdout으로 보내는 것은 기본 동작이며 일반적으로 실제로 원하는 것이 아닙니다. 대부분의 애플리케이션은 도착하는 데이터를 수신하기 위해 쓰기 콜백을 대신 설치합니다. 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;curl/curl.h&gt;int main(void)&#123; CURL *curl; CURLcode res; curl = curl_easy_init(); if(curl) &#123; curl_easy_setopt(curl, CURLOPT_URL, \"http://example.com/\"); /* Perform the request, res will get the return code */ res = curl_easy_perform(curl); /* Check for errors */ if(res != CURLE_OK) fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res)); /* always cleanup */ curl_easy_cleanup(curl); &#125; return 0;&#125; 메모리에 페이지 가져오기이 예는 수신된 데이터를 stdout(종종 원하는 것이 아님)으로 보내는 대신 수신 데이터가 증가함에 따라 확장되는 메모리 버퍼에 수신 데이터를 저장하는 전자의 변형입니다. 쓰기 콜백을 사용하여 데이터를 수신하여 이를 수행합니다. 이 예에서는 설정된 URL 체계와 함께 고정 URL 문자열을 사용하지만 물론 지원되는 다른 프로토콜을 사용하도록 이를 변경한 다음 대신 해당 프로토콜에서 리소스를 가져올 수 있습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;curl/curl.h&gt;struct MemoryStruct &#123; char *memory; size_t size;&#125;;static size_tWriteMemoryCallback(void *contents, size_t size, size_t nmemb, void *userp)&#123; size_t realsize = size * nmemb; struct MemoryStruct *mem = (struct MemoryStruct *)userp; mem-&gt;memory = realloc(mem-&gt;memory, mem-&gt;size + realsize + 1); if(mem-&gt;memory == NULL) &#123; /* out of memory */ printf(\"not enough memory (realloc returned NULL)\\n\"); return 0; &#125; memcpy(&amp;(mem-&gt;memory[mem-&gt;size]), contents, realsize); mem-&gt;size += realsize; mem-&gt;memory[mem-&gt;size] = 0; return realsize;&#125;int main(void)&#123; CURL *curl_handle; CURLcode res; struct MemoryStruct chunk; chunk.memory = malloc(1); /* will be grown as needed by the realloc above */ chunk.size = 0; /* no data at this point */ curl_global_init(CURL_GLOBAL_ALL); /* init the curl session */ curl_handle = curl_easy_init(); /* specify URL to get */ curl_easy_setopt(curl_handle, CURLOPT_URL, \"https://www.example.com/\"); /* send all data to this function */ curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback); /* we pass our 'chunk' struct to the callback function */ curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&amp;chunk); /* some servers do not like requests that are made without a user-agent field, so we provide one */ curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, \"libcurl-agent/1.0\"); /* get it! */ res = curl_easy_perform(curl_handle); /* check for errors */ if(res != CURLE_OK) &#123; fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res)); &#125; else &#123; /* * Now, our chunk.memory points to a memory block that is chunk.size * bytes big and contains the remote file. * * Do something nice with it! */ printf(\"%lu bytes retrieved\\n\", (long)chunk.size); &#125; /* cleanup curl stuff */ curl_easy_cleanup(curl_handle); free(chunk.memory); /* we are done with libcurl, so clean it up */ curl_global_cleanup(); return 0;&#125; HTTP를 통해 로그인 양식 제출HTTP를 통한 로그인 제출은 일반적으로 POST에서 제출할 데이터와 전송할 대상 URL을 정확히 파악하는 문제입니다. 로그인한 후 적절한 쿠키를 사용하면 대상 URL을 가져올 수 있습니다. 많은 로그인 시스템이 HTTP 리디렉션과 함께 작동하므로 libcurl이 이러한 리디렉션이 도착하면 이를 따르도록 요청합니다. 일부 로그인 양식은 이를 더 복잡하게 만들고 로그인 양식 등을 보여주는 페이지에서 쿠키를 얻어야 하므로 필요한 경우 이 코드를 약간 확장할 수 있습니다. 존재하지 않는 쿠키 파일을 전달함으로써 이 예제는 쿠키 파서를 활성화하여 로그인 응답의 응답이 도착할 때 들어오는 쿠키가 저장되고 리소스에 대한 후속 요청이 쿠키를 사용하고 우리가 실제로 올바르게 로그인했습니다. 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;curl/curl.h&gt;int main(void)&#123; CURL *curl; CURLcode res; static const char *postthis = \"user=daniel&amp;password=monkey123\"; curl = curl_easy_init(); if(curl) &#123; curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com/login.cgi\"); curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postthis); curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L); /* redirects! */ curl_easy_setopt(curl, CURLOPT_COOKIEFILE, \"\"); /* no file */ res = curl_easy_perform(curl); /* Check for errors */ if(res != CURLE_OK) fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res)); else &#123; /* * After the login POST, we have received the new cookies. Switch * over to a GET and ask for the login-protected URL. */ curl_easy_setopt(curl, CURLOPT_URL, \"https://example.com/file\"); curl_easy_setopt(curl, CURLOPT_HTTPGET, 1L); /* no more POST */ res = curl_easy_perform(curl); /* Check for errors */ if(res != CURLE_OK) fprintf(stderr, \"second curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res)); &#125; /* always cleanup */ curl_easy_cleanup(curl); &#125; return 0;&#125; FTP 디렉토리 목록 가져오기이 예제는 주어진 URL에서 FTP 디렉토리 출력을 가져와서 stdout으로 보냅니다. URL의 후행 슬래시는 libcurl이 이를 디렉토리로 처리하도록 합니다. 12345678910111213141516171819202122232425262728293031#include &lt;curl/curl.h&gt;int main(void)&#123; CURL *curl; CURLcode res; curl_global_init(CURL_GLOBAL_DEFAULT); curl = curl_easy_init(); if(curl) &#123; /* * Make the URL end with a trailing slash! */ curl_easy_setopt(curl, CURLOPT_URL, \"ftp://ftp.example.com/\"); res = curl_easy_perform(curl); /* always cleanup */ curl_easy_cleanup(curl); if(CURLE_OK != res) &#123; /* we failed */ fprintf(stderr, \"curl told us %d\\n\", res); &#125; &#125; curl_global_cleanup(); return 0;&#125; Non-blocking HTTP form-post이 예제는 다중 인터페이스를 사용하여 다중 파트 form-post를 만듭니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;sys/time.h&gt;#include &lt;curl/curl.h&gt;int main(void)&#123; CURL *curl; CURLM *multi_handle; int still_running = 0; curl_mime *form = NULL; curl_mimepart *field = NULL; struct curl_slist *headerlist = NULL; static const char buf[] = \"Expect:\"; curl = curl_easy_init(); multi_handle = curl_multi_init(); if(curl &amp;&amp; multi_handle) &#123; /* Create the form */ form = curl_mime_init(curl); /* Fill in the file upload field */ field = curl_mime_addpart(form); curl_mime_name(field, \"sendfile\"); curl_mime_filedata(field, \"multi-post.c\"); /* Fill in the filename field */ field = curl_mime_addpart(form); curl_mime_name(field, \"filename\"); curl_mime_data(field, \"multi-post.c\", CURL_ZERO_TERMINATED); /* Fill in the submit field too, even if this is rarely needed */ field = curl_mime_addpart(form); curl_mime_name(field, \"submit\"); curl_mime_data(field, \"send\", CURL_ZERO_TERMINATED); /* initialize custom header list (stating that Expect: 100-continue is not wanted */ headerlist = curl_slist_append(headerlist, buf); /* what URL that receives this POST */ curl_easy_setopt(curl, CURLOPT_URL, \"https://www.example.com/upload.cgi\"); curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L); curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerlist); curl_easy_setopt(curl, CURLOPT_MIMEPOST, form); curl_multi_add_handle(multi_handle, curl); do &#123; CURLMcode mc = curl_multi_perform(multi_handle, &amp;still_running); if(still_running) /* wait for activity, timeout or \"nothing\" */ mc = curl_multi_poll(multi_handle, NULL, 0, 1000, NULL); if(mc) break; &#125; while(still_running); curl_multi_cleanup(multi_handle); /* always cleanup */ curl_easy_cleanup(curl); /* then cleanup the form */ curl_mime_free(form); /* free slist */ curl_slist_free_all(headerlist); &#125; return 0;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl Header files","slug":"Linux-libcurl Header files","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T06:25:59.847Z","comments":true,"path":"2022/02/09/Linux-libcurl Header files/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl Header files/","excerpt":"","text":"Header files응용 프로그램을 사용하는 libcurl이 포함해야 하는 헤더는 단 하나뿐입니다. 1#include &lt;curl/curl.h&gt; 그 파일에는 몇 가지 다른 공개 헤더 파일이 포함되어 있지만 존재하지 않는 척 할 수 있습니다. (역사적으로 말해서, 우리는 약간 다르게 시작했지만 시간이 지남에 따라 포함에 대해 하나만 사용하는 이 형식을 중심으로 안정화되었습니다.)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl multi-threading","slug":"Linux-libcurl multi-threading","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T06:27:38.335Z","comments":true,"path":"2022/02/09/Linux-libcurl multi-threading/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl multi-threading/","excerpt":"","text":"multi-threadinglibcurl은 스레드로부터 안전하지만 내부 스레드 동기화가 없습니다. libcurl 스레드를 올바르게 사용하려면 고유한 잠금을 제공하거나 옵션을 변경해야 할 수 있습니다. 정확히 필요한 것은 libcurl이 빌드된 방식에 따라 다릅니다. 최신 정보가 포함된 libcurl 스레드 안전 웹페이지를 참조하십시오.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl URL API","slug":"Linux-libcurl URL API","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T06:18:43.996Z","comments":true,"path":"2022/02/09/Linux-libcurl URL API/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl URL API/","excerpt":"","text":"URL APIlibcurl은 URL을 구문 분석, 업데이트 및 생성하기 위한 API를 제공합니다. 이를 사용하여 응용 프로그램은 자체 목적을 위해 libcurl의 URL 파서를 사용할 수 있습니다. 동일한 파서를 사용함으로써 다른 해석으로 인한 보안 문제를 피할 수 있습니다. Include filesURL API를 사용하려는 경우 코드에 &lt;curl/curl.h&gt;를 포함합니다. 1234#include &lt;curl/curl.h&gt;CURLU *h = curl_url();rc = curl_url_set(h, CURLUPART_URL, \"ftp://example.com/no/where\", 0); Create, cleanup, duplicate이 API를 사용하는 첫 번째 단계는 URL 정보와 리소스를 보유하는 CURLU * 핸들을 만드는 것입니다. 핸들은 단일 URL 및 모든 다른 구성 요소에 대한 정보를 보유하는 연결된 데이터 개체에 대한 참조입니다. API를 사용하면 각 URL 구성 요소를 개별적으로 또는 전체 URL로 설정하거나 가져올 수 있습니다. 다음과 같이 URL 핸들을 만듭니다. 1CURLU *h = curl_url(); 완료되면 정리하십시오. 1curl_url_cleanup(h); 핸들 사본이 필요하면 복사하십시오. 1CURLU *nh = curl_url_dup(h); Parse a URL핸들에서 CURLUPART_URL 부분을 설정하여 전체 URL을 구문 분석합니다. 123CURLU *h = curl_url();rc = curl_url_set(h, CURLUPART_URL, \"https://example.com:449/foo/bar?name=moo\", 0); 성공하면 rc에 CURLUE_OK가 포함되고 다른 URL 구성 요소가 핸들에 유지됩니다. libcurl에 관한 한 URL이 유효했음을 의미합니다. 함수 호출의 네 번째 인수는 특정 기능을 변경하기 위한 비트마스크입니다. 파서의 동작을 변경하기 위해 비트를 하나만 더 설정할 수 있습니다. CURLU_NON_SUPPORT_SCHEMEcurl_url_set()이 지원되지 않는 체계를 허용하도록 합니다. 설정하지 않으면 libcurl이 알고 있고 지원하는 내장 프로토콜에 대한 유일한 구성표가 허용됩니다. CURLU_URLENCODE공백 또는 “제어 문자”와 같은 이점이 있는 바이트가 있는 경우 함수 URL이 경로 부분을 인코딩하도록 합니다. CURLU_DEFAULT_SCHEME전달된 문자열이 체계를 사용하지 않는 경우 기본 체계를 의도한 것으로 가정합니다. 기본 체계는 HTTPS입니다. 이것이 설정되지 않으면 스킴 부분이 없는 URL은 유효한 것으로 승인되지 않습니다. 둘 다 설정된 경우 CURLU_GUESS_SCHEME 옵션을 재정의합니다. CURLU_GUESS_SCHEMElibcurl이 URL이 스키마 없이 설정되도록 하고 대신 호스트 이름을 기반으로 의도한 스키마를 “추측”합니다. 가장 바깥쪽 하위 도메인 이름이 DICT, FTP, IMAP, LDAP, POP3 또는 SMTP와 일치하면 해당 체계가 사용되며, 그렇지 않으면 HTTP를 선택합니다. 둘 다 설정된 경우 우선적으로 적용되는 CURLU_DEFAULT_SCHEME 옵션과 충돌합니다. CURLU_NO_AUTHORITY권한 검사를 건너뜁니다. RFC는 개별 체계가 호스트 부분(일반적으로 권한의 유일한 필수 부분)을 생략하도록 허용하지만 libcurl은 이것이 사용자 지정 체계에 허용되는지 여부를 알 수 없습니다. 플래그를 지정하면 파일 구성표가 처리되는 방식과 유사한 빈 권한 섹션이 허용됩니다. CURLU_NON_SUPPORT_SCHEME와 조합해서만 사용할 수 있습니다. CURLU_PATH_AS_ISlibcurl이 경로의 정규화를 건너뛰게 합니다. 이것은 curl이 점-슬래시 및 점-점 등의 시퀀스를 제거하는 절차입니다. 전송에 사용되는 동일한 옵션을 CURLOPT_PATH_AS_IS라고 합니다. CURLU_ALLOW_SPACEURL 파서가 가능한 경우 공간(ASCII 32)을 허용하도록 합니다. URL 구문은 일반적으로 공백을 허용하지 않지만 %20 또는 +로 인코딩해야 합니다. 공백이 허용되면 스키마에서 여전히 허용되지 않습니다. URL에서 공간이 사용되고 허용되면 CURLU_URLENCODE도 설정되지 않는 한 그대로 저장됩니다. 그러면 libcurl이 저장하기 전에 공간을 URL로 인코딩합니다. 이는 전체 URL 또는 개별 부분을 추출하기 위해 curl_url_get()을 사용할 때 URL이 구성되는 방식에 영향을 줍니다. 상대 URL로 리디렉션핸들이 이미 URL을 구문 분석한 경우 두 번째 상대 URL을 설정하면 이에 맞게 “리디렉션”됩니다. 예를 들어, 먼저 원래 URL을 설정한 다음 “리디렉션”할 URL을 다음으로 설정합니다. 12345CURLU *h = curl_url();rc = curl_url_set(h, CURLUPART_URL, \"https://example.com/foo/bar?name=moo\", 0);rc = curl_url_set(h, CURLUPART_URL, \"../test?another\", 0); Get a URLCURLU * 핸들은 URL 또는 URL의 일부를 나타내며 언제든지 해당 URL을 쉽게 추출할 수 있습니다. 123char *url;rc = curl_url_get(h, CURLUPART_URL, &amp;url, CURLU_NO_DEFAULT_PORT);curl_free(url); 핸들에 전체 URL을 추가하기에 충분한 정보가 없으면 오류를 반환합니다.반환된 문자열은 작업을 마친 후 curl_free()로 해제해야 합니다.함수 호출의 네 번째 인수에서 0은 특정 기능을 변경하기 위한 플래그 비트마스크입니다. CURLU_DEFAULT_PORTURL 핸들에 저장된 포트 번호가 없는 경우 이 옵션은 curl_url_get()이 사용된 체계에 대한 기본 포트를 반환하도록 합니다. CURLU_DEFAULT_SCHEME핸들에 저장된 체계가 없는 경우 이 옵션은 curl_url_get()이 오류 대신 기본 체계를 반환하도록 합니다. CURLU_NO_DEFAULT_PORT포트 번호가 스키마에 사용된 기본 포트와 일치하는 경우 생성된 URL에서 포트 번호를 사용하지 않도록 curl_url_get()에 지시합니다. 예를 들어 포트 번호 443이 설정되고 스키마가 https인 경우 추출된 URL에는 포트 번호가 포함되지 않습니다. CURLU_URLENCODE설정하면 전체 URL이 검색될 때 curl_url_get() URL이 호스트 이름 부분을 인코딩하도록 합니다. 설정되지 않은 경우(기본값) libcurl은 IDN 이름이 있는 그대로 표시되도록 지원하기 위해 호스트 이름이 “raw”인 URL을 반환합니다. IDN 호스트 이름은 일반적으로 비ASCII 바이트를 사용하며 그렇지 않으면 백분율로 인코딩됩니다. URL 인코딩을 요청하지 않는 경우에도 %(바이트 37)는 호스트 이름이 유효한지 확인하기 위해 호스트 이름에서 URL로 인코딩됩니다. 개별 URL 부분 가져오기URL이 구문 분석되었거나 개별 부분이 CURLU 핸들에 설정된 경우 언제든지 핸들에서 해당 부분을 다시 추출할 수 있습니다. curl_url_get()에 대한 두 번째 인수는 추출할 부분을 지정합니다. 그것들은 모두 null로 끝나는 char * 데이터로 추출되므로 이러한 변수에 대한 포인터를 전달합니다. 1234567891011121314151617181920212223char *host;rc = curl_url_get(h, CURLUPART_HOST, &amp;host, 0);char *scheme;rc = curl_url_get(h, CURLUPART_SCHEME, &amp;scheme, 0);char *user;rc = curl_url_get(h, CURLUPART_USER, &amp;user, 0);char *password;rc = curl_url_get(h, CURLUPART_PASSWORD, &amp;password, 0);char *port;rc = curl_url_get(h, CURLUPART_PORT, &amp;port, 0);char *path;rc = curl_url_get(h, CURLUPART_PATH, &amp;path, 0);char *query;rc = curl_url_get(h, CURLUPART_QUERY, &amp;query, 0);char *fragment;rc = curl_url_get(h, CURLUPART_FRAGMENT, &amp;fragment, 0); 작업이 끝나면 반환된 문자열을 curl_free로 해제하는 것을 잊지 마십시오! 추출된 부분은 사용자가 CURLU_URLDECODE 플래그로 요청하지 않는 한 URL 디코딩되지 않습니다. 개별 URL 부분 설정API를 사용하면 전체 URL을 구문 분석하거나 구문 분석하는 대신 CURLU 핸들에 보관된 URL의 개별 부분을 애플리케이션에서 설정할 수 있습니다. 12345678rc = curl_url_set(urlp, CURLUPART_HOST, \"www.example.com\", 0);rc = curl_url_set(urlp, CURLUPART_SCHEME, \"https\", 0);rc = curl_url_set(urlp, CURLUPART_USER, \"john\", 0);rc = curl_url_set(urlp, CURLUPART_PASSWORD, \"doe\", 0);rc = curl_url_set(urlp, CURLUPART_PORT, \"443\", 0);rc = curl_url_set(urlp, CURLUPART_PATH, \"/index.html\", 0);rc = curl_url_set(urlp, CURLUPART_QUERY, \"name=john\", 0);rc = curl_url_set(urlp, CURLUPART_FRAGMENT, \"anchor\", 0); API는 항상 세 번째 인수에서 null로 끝나는 char * 문자열을 예상하거나 필드를 지우려면 NULL을 예상합니다. 포트 번호도 이런 식으로 문자열로 제공됩니다. 사용자가 네 번째 인수에서 CURLU_URLENCODE 플래그를 사용하여 요청하지 않는 한 설정 부분은 URL로 인코딩되지 않습니다. 쿼리에 추가응용 프로그램은 CURLU_APPENDQUERY 플래그를 사용하여 기존 쿼리 부분의 오른쪽 끝에 문자열을 추가할 수 있습니다. URL https://example.com/?shoes=2를 보유하는 핸들을 고려하십시오. 그러면 애플리케이션은 다음과 같이 쿼리 부분에 문자열 hat=1을 추가할 수 있습니다. 1rc = curl_url_set(urlp, CURLUPART_QUERY, \"hat=1\", CURLU_APPENDQUERY); 앰퍼샌드(&amp;) 구분 기호가 없는 경우에도 이를 삽입하므로 핸들의 전체 URL은 https://example.com/?shoes=2&amp;hat=1과 같습니다. 추가된 문자열은 물론 추가 시 인코딩된 URL을 얻을 수도 있으며, 요청하는 경우 인코딩은 ‘=’ 문자를 건너뜁니다. 예를 들어, 우리가 이미 가지고 있는 것에 candy=M&amp;M을 추가하고 데이터의 앰퍼샌드를 처리하기 위해 그것을 URL 인코딩합니다: 12rc = curl_url_set(urlp, CURLUPART_QUERY, \"candy=M&amp;M\", CURLU_APPENDQUERY | CURLU_URLENCODE); 이제 URL은 https://example.com/?shoes=2&amp;hat=1&amp;candy=M%26M과 같습니다. CURLOPT_CURLU응용 프로그램의 편의를 위해 CURLOPT_URL의 대안으로 이미 구문 분석된 URL을 libcurl에 전달할 수 있습니다. CURLOPT_CURLU 옵션을 사용하여 URL 문자열 대신 CURLU 핸들을 전달합니다.예시: 12345CURLU *h = curl_url();rc = curl_url_set(h, CURLUPART_URL, \"https://example.com/\", 0);CURL *easy = curl_easy_init();curl_easy_setopt(easy, CURLOPT_CURLU, h);","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl Proxies","slug":"Linux-libcurl Proxies","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T04:31:32.988Z","comments":true,"path":"2022/02/09/Linux-libcurl Proxies/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl Proxies/","excerpt":"","text":"프록시네트워크 컨텍스트에서 프록시는 중개자, 즉 클라이언트인 귀하와 통신하려는 원격 서버 사이에 있는 서버입니다. 클라이언트는 중간 사람에게 연락한 다음 계속해서 원격 서버에 연락합니다. 이 스타일의 프록시 사용은 회사와 조직에서 사용하는 경우가 있으며, 이 경우 일반적으로 대상 서버에 도달하기 위해 사용해야 합니다. 프록시와 통신할 때 사용할 여러 종류의 프록시와 프로토콜이 있으며 libcurl은 가장 일반적인 몇 가지 프록시 프로토콜을 지원합니다. 프록시에 사용되는 프로토콜이 원격 서버에 사용되는 프로토콜과 반드시 같지는 않다는 점을 인식하는 것이 중요합니다. libcurl로 전송을 설정할 때 프록시의 서버 이름과 포트 번호를 지적해야 합니다. 여러분이 즐겨 사용하는 브라우저가 libcurl보다 약간 더 고급 방식으로 이 작업을 수행할 수 있다는 것을 알게 될 것입니다. 이러한 세부 사항은 이후 섹션에서 다룰 것입니다. 프록시 유형libcurl은 SOCKS 및 HTTP 프록시의 두 가지 주요 프록시 유형을 지원합니다. 보다 구체적으로, 원격 이름 조회가 있거나 없는 SOCKS4 및 SOCKS5와 로컬 프록시에 대한 HTTP 및 HTTPS를 모두 지원합니다. 말하는 프록시의 종류를 지정하는 가장 쉬운 방법은 프록시 호스트 이름 문자열(CURLOPT_PROXY)의 구성표 부분을 일치하도록 설정하는 것입니다. 123456socks4://proxy.example.com:12345/socks4a://proxy.example.com:12345/socks5://proxy.example.com:12345/socks5h://proxy.example.com:12345/http://proxy.example.com:12345/https://proxy.example.com:12345/ socks4 - 로컬 이름 확인이 있는 SOCKS4를 의미합니다. socks4a - 프록시 이름이 확인되는 SOCKS4를 의미합니다. socks5 - 로컬 이름 확인이 있는 SOCKS5를 의미합니다. socks5h - 프록시 이름이 확인되는 SOCKS5를 의미합니다. http - 프록시가 항상 이름을 확인할 수 있도록 하는 HTTP를 의미합니다. https - 프록시에 대한 HTTPS를 의미하며 항상 프록시가 이름을 확인할 수 있습니다(HTTPS 프록시 지원은 최근 curl 7.52.0에 추가되었으며 OpenSSL, GnuTLS 및 NSS와 같은 TLS 라이브러리의 하위 집합에서만 작동합니다. ) CURLOPT_PROXYTYPE을 사용하여 호스트 이름만 설정하려는 경우 별도의 옵션으로 프록시 유형을 설정하도록 선택할 수도 있습니다. 마찬가지로 CURLOPT_PROXYPORT와 함께 사용할 프록시 포트 번호를 설정할 수 있습니다. 로컬 또는 프록시 이름 조회위의 섹션에서 서로 다른 프록시 설정을 통해 전송에 관련된 다른 당사자가 이름 확인을 수행할 수 있음을 알 수 있습니다. 여러 경우에 클라이언트가 서버 호스트 이름을 확인하고 연결할 프록시에 IP 주소를 전달하도록 할 수 있습니다. 물론 이름 조회가 클라이언트 시스템에서 정확하게 작동한다고 가정합니다. 프록시가 이름을 확인하도록 합니다. 연결할 IP 주소로 변환합니다. HTTP 또는 HTTPS 프록시를 사용하는 경우 항상 확인할 프록시에 이름을 지정합니다. 어떤 프록시?네트워크 연결에서 목적지에 도달하기 위해 프록시를 사용해야 하는 경우, 이를 파악하고 올바른 프록시를 사용하도록 libcurl에 알려야 합니다. libcurl에서는 프록시를 자동으로 파악하거나 감지하도록 지원하지 않습니다. 브라우저를 사용할 때 프록시에 PAC 스크립트 또는 기타 수단을 제공하는 것이 일반적이지만 libcurl에서는 그 중 어느 것도 인식하지 못합니다. 프록시 환경 변수프록시 옵션이 설정되지 않은 경우 libcurl은 프록시가 사용되도록 요청되었는지 확인하기 위해 전송을 수행하기 전에 특별히 명명된 환경 변수의 존재를 확인합니다. 프록시 호스트 이름을 보유하도록 [scheme]_proxy라는 변수를 설정하여 프록시를 지정할 수 있습니다(호스트를 -x로 지정하는 것과 동일한 방식). 따라서 HTTP 서버에 접근할 때 프록시를 사용하도록 curl에 지시하려면 ‘http_proxy’ 환경 변수를 설정합니다. 이와 같이: 1http_proxy=http://proxy.example.com:80 위의 프록시 예제는 HTTP용이지만 물론 프록시하려는 특정 프로토콜에 대해 ftp_proxy, https_proxy 등을 설정할 수도 있습니다. http_proxy를 제외한 이러한 모든 프록시 환경 변수 이름은 HTTPS_PROXY와 같이 대문자로 지정할 수도 있습니다. 모든 프로토콜을 제어하는 단일 변수를 설정하기 위해 ALL_PROXY가 존재합니다. 특정 프로토콜 변수가 있는 경우 해당 변수가 우선 적용됩니다. 환경 변수를 사용하여 프록시를 설정할 때 하나 또는 몇 개의 호스트 이름이 프록시를 통과하지 못하도록 제외되어야 하는 상황에 쉽게 도달할 수 있습니다. 이것은 NO_PROXY 변수 또는 해당 CURLOPT_NOPROXY libcurl 옵션을 사용하여 수행할 수 있습니다. 액세스할 때 프록시를 사용하지 않아야 하는 쉼표로 구분된 호스트 이름 목록으로 설정합니다. 모든 호스트와 일치하도록 NO_PROXY를 단일 별표(‘*’)로 설정할 수 있습니다. HTTP 프록시HTTP 프로토콜은 HTTP 프록시를 사용하는 방법에 대해 자세히 설명합니다. 실제 원격 서버에 요청을 보내는 대신 클라이언트(libcurl)는 대신 프록시에 특정 리소스를 요청합니다. HTTP 프록시에 대한 연결은 암호화되지 않은 일반 HTTP를 사용하여 이루어집니다. HTTPS 리소스가 요청되면 libcurl은 대신 프록시에 CONNECT 요청을 발행합니다. 이러한 요청은 프록시를 통해 터널을 열어 데이터를 이해하지 못한 채 전달합니다. 이런 식으로 libcurl은 HTTP 프록시가 있는 경우에도 안전한 종단 간 TLS 연결을 설정할 수 있습니다. HTTP 프록시를 통해 비 HTTP 프로토콜을 프록시할 수 있지만 이는 대부분 CONNECT 메서드를 통해 데이터를 터널링하여 수행되기 때문에 클라이언트가 다른 특정 원격 포트 번호에 연결할 수 있도록 프록시를 구성해야 합니다. 많은 HTTP 프록시는 80 및 443 이외의 다른 포트 번호에 대한 연결을 금지하도록 설정됩니다. HTTPS 프록시HTTPS 프록시는 HTTP 프록시와 유사하지만 클라이언트가 보안 HTTPS 연결을 사용하여 연결할 수 있습니다. 이 경우에도 프록시 연결은 원격 사이트와의 연결과 분리되어 있으므로 원격 사이트에 대한 HTTPS는 프록시에 대한 HTTPS 연결을 통해 터널링되므로 libcurl은 별도의 프록시 연결에 대한 전체 TLS 옵션 집합을 제공합니다. 원격 호스트에 대한 연결에서. 예를 들어, CURLOPT_PROXY_CAINFO는 CURLOPT_CAINFO가 원격 호스트를 위한 것과 같은 HTTPS 프록시의 기능입니다. CURLOPT_PROXY_SSL_VERIFYPEER는 CURLOPT_SSL_VERIFYPEER 등의 프록시 버전입니다. HTTPS 프록시는 오늘날에도 여전히 조직과 회사에서 상당히 이례적입니다. 프록시 인증프록시를 사용한 인증은 프록시 자체와의 핸드셰이크 협상에서 유효한 자격 증명을 제공해야 함을 의미합니다. 프록시 인증은 원격 호스트와의 가능한 인증 또는 인증 부족에 추가 및 분리됩니다. libcurl은 HTTP, HTTPS 및 SOCKS5 프록시를 통한 인증을 지원합니다. 핵심 옵션은 CURLOPT_PROXY 문자열 내에서 설정하지 않는 한 사용할 사용자 이름과 암호를 설정하는 CURLOPT_PROXYUSERPWD입니다. HTTP 프록시 헤더HTTP 또는 HTTP 프록시를 사용하여 libcurl은 헤더 세트를 포함하는 프록시에 요청을 발행합니다. 물론 애플리케이션은 서버로 보낸 요청과 마찬가지로 헤더를 수정할 수 있습니다. libcurl은 서버에 별도의 요청이 전송될 때 프록시로 전송되는 헤더를 제어하기 위해 CURLOPT_PROXYHEADER를 제공합니다. 이는 일반적으로 프록시를 통해 터널을 설정하기 위해 프록시로 전송된 초기 CONNECT 요청을 의미합니다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl --libcurl","slug":"Linux-libcurl --libcurl","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T06:25:12.192Z","comments":true,"path":"2022/02/09/Linux-libcurl --libcurl/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl --libcurl/","excerpt":"","text":"–libcurl우리는 사용자가 먼저 curl 명령줄 도구로 수행하려는 전송을 시도할 것을 적극 권장하며, 대략 원하는 대로 작동하면 --libcurl [filename] 옵션을 명령줄에 추가하고 다시 다음을 실행합니다. --libcurl 명령줄 옵션은 제공된 파일 이름으로 C 프로그램을 생성합니다. C 프로그램은 libcurl을 사용하여 방금 curl 명령줄 도구에서 수행한 전송을 실행하는 응용 프로그램입니다. 몇 가지 예외가 있고 항상 100% 일치하는 것은 아니지만 원하는 libcurl 옵션과 사용할 수 있는 libcurl 옵션 및 제공할 추가 인수에 대한 훌륭한 영감 소스 역할을 할 수 있습니다. --libcurl -과 같이 파일 이름을 단일 대시로 지정하면 파일 대신 stdout에 프로그램이 작성됩니다. 예를 들어 http://example.com을 가져오는 명령을 실행합니다. 1curl http://example.com --libcurl example.c 이렇게 하면 현재 디렉토리에 다음과 유사한 example.c가 생성됩니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344/********* Sample code generated by the curl command-line tool ********** * All curl_easy_setopt() options are documented at: * https://curl.se/libcurl/c/curl_easy_setopt.html ************************************************************************/#include &lt;curl/curl.h&gt;int main(int argc, char *argv[])&#123; CURLcode ret; CURL *hnd; hnd = curl_easy_init(); curl_easy_setopt(hnd, CURLOPT_URL, \"http://example.com\"); curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, 1L); curl_easy_setopt(hnd, CURLOPT_USERAGENT, \"curl/7.45.0\"); curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, 50L); curl_easy_setopt(hnd, CURLOPT_SSH_KNOWNHOSTS, \"/home/daniel/.ssh/known_hosts\"); curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, 1L); /* Here is a list of options the curl code used that cannot get generated as source easily. You may select to either not use them or implement them yourself. CURLOPT_WRITEDATA set to a objectpointer CURLOPT_WRITEFUNCTION set to a functionpointer CURLOPT_READDATA set to a objectpointer CURLOPT_READFUNCTION set to a functionpointer CURLOPT_SEEKDATA set to a objectpointer CURLOPT_SEEKFUNCTION set to a functionpointer CURLOPT_ERRORBUFFER set to a objectpointer CURLOPT_STDERR set to a objectpointer CURLOPT_HEADERFUNCTION set to a functionpointer CURLOPT_HEADERDATA set to a objectpointer */ ret = curl_easy_perform(hnd); curl_easy_cleanup(hnd); hnd = NULL; return (int)ret;&#125;/**** End of sample code ****/","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl CURL코드 리턴 코드","slug":"Linux-libcurl CURL코드 리턴 코드","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T07:17:43.342Z","comments":true,"path":"2022/02/09/Linux-libcurl CURL코드 리턴 코드/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl CURL코드 리턴 코드/","excerpt":"","text":"CURL코드 리턴 코드많은 libcurl 함수는 CURLcode를 반환합니다. 그것은 오류 코드에 대한 특별한 libcurl typedeffed 변수입니다. 모든 것이 훌륭하고 멋지면 CURLE_OK(값이 0임)를 반환하고 문제가 감지되면 0이 아닌 숫자를 반환합니다. 거의 100개의 CURLcode 오류가 사용 중이며, 모두 curl/curl.h 헤더 파일에서 찾을 수 있으며 libcurl-errors 매뉴얼 페이지에 문서화되어 있습니다. curl_easy_strerror() 함수를 사용하여 CURLcode를 사람이 읽을 수 있는 문자열로 변환할 수 있습니다. 그러나 이러한 오류는 UI 또는 최종 사용자에게 노출하기에 적합한 방식으로 표현되는 경우가 거의 없다는 점에 유의하십시오. 12const char *str = curl_easy_strerror( error );printf(\"libcurl said %s\\n\", str); 오류가 발생했을 때 약간 더 나은 오류 텍스트를 얻는 또 다른 방법은 프로그램의 버퍼를 가리키도록 CURLOPT_ERRORBUFFER 옵션을 설정하는 것입니다. 그러면 libcurl은 오류를 반환하기 전에 관련 오류 메시지를 그곳에 저장합니다: 12char error[CURL_ERROR_SIZE]; /* needs to be at least this big */CURLcode ret = curl_easy_setopt(handle, CURLOPT_ERRORBUFFER, error);","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl Post transfer info","slug":"Linux-libcurl Post transfer info","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T04:49:11.175Z","comments":true,"path":"2022/02/09/Linux-libcurl Post transfer info/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl Post transfer info/","excerpt":"","text":"Post transfer infolibcurl 전송이 “쉬운 핸들”과 어떻게 연관되어 있는지 기억하십시오! 각 전송에는 이러한 핸들이 있으며 전송이 완료되면 핸들을 정리하거나 다른 전송에 재사용하기 전에 이전 작업에서 정보를 추출하는 데 사용할 수 있습니다. 이 작업을 수행하는 친구를 curl_easy_getinfo()라고 하며 관심 있는 특정 정보를 알려주면 가능한 경우 해당 정보를 반환합니다. 이 함수를 사용할 때 원하는 정보와 답을 담을 변수에 대한 포인터를 쉽게 처리할 수 있습니다. 올바른 유형의 변수에 대한 포인터를 전달해야 합니다. 그렇지 않으면 일이 엉뚱한 방향으로 갈 위험이 있습니다. 이러한 정보 값은 전송이 완료된 후 제공되도록 설계되었습니다. 받는 데이터는 long, ‘char’, ‘struct curl_slist’, double 또는 socket일 수 있습니다. 이전 HTTP 전송에서 Content-Type: 값을 추출하는 방법은 다음과 같습니다. 123CURLcode res;char *content_type;res = curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &amp;content_type); 해당 연결에 사용된 로컬 포트 번호를 추출하려면 다음을 수행하십시오. 123CURLcode res;long port_number;res = curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT, &amp;port_number); 이용 가능한 정보 Getinfo option Type Description CURLINFO_ACTIVESOCKET curl_socket_t 세션의 활성 소켓 CURLINFO_APPCONNECT_TIME double 시작부터 SSL/SSH 핸드셰이크가 완료될 때까지의 시간 CURLINFO_APPCONNECT_TIME_T curl_off_t 시작부터 SSL/SSH 핸드셰이크가 완료될 때까지의 시간(마이크로초) CURLINFO_CERTINFO struct curl_slist * 인증서 체인 CURLINFO_CONDITION_UNMET long 시간 조건이 충족되었는지 여부 CURLINFO_CONNECT_TIME double 시작부터 원격 호스트 또는 프록시가 완료될 때까지의 시간 CURLINFO_CONNECT_TIME_T curl_off_t 시작부터 원격 호스트 또는 프록시가 완료될 때까지의 시간(마이크로초) CURLINFO_CONTENT_LENGTH_DOWNLOAD double Content-Length 헤더의 콘텐츠 길이 CURLINFO_CONTENT_LENGTH_UPLOAD double 업로드 크기 CURLINFO_CONTENT_TYPE char * Content-Type 헤더의 콘텐츠 유형 CURLINFO_COOKIELIST struct curl_slist * 알려진 모든 쿠키 목록 CURLINFO_EFFECTIVE_METHOD char * 마지막으로 사용한 HTTP 요청 방법 CURLINFO_EFFECTIVE_URL char * 마지막으로 사용한 URL CURLINFO_PROXY_SSL_VERIFYRESULT long 프록시 인증서 확인 결과 CURLINFO_PROXYAUTH_AVAIL long 사용 가능한 HTTP 프록시 인증 방법 CURLINFO_REDIRECT_COUNT long 팔로우한 총 리디렉션 수 CURLINFO_REDIRECT_TIME double 최종 전송 전 모든 리디렉션 단계에 소요된 시간 CURLINFO_REDIRECT_TIME_T curl_off_t 최종 전송 전 모든 리디렉션 단계에 소요된 시간(마이크로초) CURLINFO_REDIRECT_URL char * 리디렉션을 활성화한 경우 리디렉션을 통해 이동할 URL CURLINFO_REQUEST_SIZE long 발행된 HTTP 요청에서 보낸 바이트 수 CURLINFO_RESPONSE_CODE long 마지막으로 받은 응답 코드 CURLINFO_RETRY_AFTER curl_off_t 응답 Retry-After: 헤더의 값 CURLINFO_RTSP_CLIENT_CSEQ long 다음에 사용될 RTSP CSeq CURLINFO_RTSP_CSEQ_RECV long RTSP CSeq 마지막 수신 CURLINFO_RTSP_SERVER_CSEQ long 다음에 예상되는 RTSP CSeq CURLINFO_RTSP_SESSION_ID char * RTSP 세션 ID CURLINFO_SCHEME char * 연결에 사용된 체계 CURLINFO_SIZE_DOWNLOAD double 다운로드된 바이트 수 CURLINFO_SIZE_UPLOAD double 업로드된 바이트 수 CURLINFO_SPEED_DOWNLOAD double 평균 다운로드 속도 CURLINFO_SPEED_UPLOAD double 평균 업로드 속도 CURLINFO_SSL_ENGINES struct curl_slist * OpenSSL 암호화 엔진 목록 CURLINFO_SSL_VERIFYRESULT long 인증서 확인 결과 CURLINFO_STARTTRANSFER_TIME double 시작부터 첫 번째 바이트가 수신될 때까지의 시간 CURLINFO_STARTTRANSFER_TIME_T curl_off_t 시작부터 첫 번째 바이트가 수신될 때까지의 시간(마이크로초) CURLINFO_TLS_SSL_PTR struct curl_slist * 추가 처리에 사용할 수 있는 TLS 세션 정보 CURLINFO_TOTAL_TIME double 이전 전송의 총 시간 CURLINFO_TOTAL_TIME_T curl_off_t 이전 전송의 총 시간(마이크로초)","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl curl easy options","slug":"Linux-libcurl curl easy options","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T07:14:13.503Z","comments":true,"path":"2022/02/09/Linux-libcurl curl easy options/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl curl easy options/","excerpt":"","text":"curl easy options이지 핸들에서 옵션을 설정하여 전송 방식을 제어하거나 경우에 따라 실제로 옵션을 설정하고 전송이 진행되는 동안 전송 동작을 수정할 수 있습니다. curl_easy_setopt()로 옵션을 설정하고 핸들, 설정하려는 옵션 및 옵션에 대한 인수를 제공합니다. 모든 옵션은 정확히 하나의 인수를 취하며 항상 curl_easy_setopt() 호출에 정확히 세 개의 매개변수를 전달해야 합니다. curl_easy_setopt() 호출은 수백 가지 다른 옵션을 허용하고 다양한 옵션은 다양한 유형의 인수를 허용하므로 세부 사항을 읽고 특정 옵션이 지원하고 기대하는 인수 유형을 정확히 제공하는 것이 중요합니다. 잘못된 유형을 전달하면 예기치 않은 부작용이 발생하거나 딸꾹질을 이해하기 어려울 수 있습니다. 모든 전송에 필요한 가장 중요한 옵션은 URL입니다. libcurl은 관련된 URL을 알지 못하면 전송을 수행할 수 없으므로 알려야 합니다. URL 옵션 이름은 CURLOPT_URL입니다. 모든 옵션에는 CURLOPT_ 접두어가 붙은 다음 설명이 포함된 이름이 모두 대문자를 사용하기 때문입니다. http://example.com HTTP 콘텐츠를 가져오기 위해 URL을 설정하는 예제 줄은 다음과 같습니다. 1CURLcode ret = curl_easy_setopt(easy, CURLOPT_URL, \"http://example.com\"); 다시: 이것은 핸들의 옵션만 설정합니다. 실제 전송 또는 기타 작업을 수행하지 않습니다. libcurl에게 문자열을 복사하도록 지시하고 작동하면 OK를 반환합니다. 물론 반환 코드를 확인하여 아무 문제가 없는지 확인하는 것이 좋습니다. 숫자 옵션 설정curl_easy_setopt()는 3번째 인자가 상황에 따라 다른 타입을 사용할 수 있는 vararg 함수이기 때문에 일반적인 C언어 타입 변환은 불가능하다. 따라서 문서에서 그렇게 말하는 경우 ‘int’가 아닌 ‘long’을 실제로 전달했는지 확인해야 합니다. 크기가 같은 아키텍처에서는 문제가 발생하지 않을 수 있지만 모두가 그렇게 작동하지는 않습니다. 마찬가지로 ‘curl_off_t’ 유형을 허용하는 옵션의 경우 해당 유형을 사용하고 다른 유형을 사용하지 않는 인수를 전달하는 것이 중요합니다. 긴 실행: 1curl_easy_setopt(handle, CURLOPT_TIMEOUT, 5L); /* 5 seconds timeout */ curl_off_t 시행: 12curl_off_t no_larger_than = 0x50000;curl_easy_setopt(handle, CURLOPT_MAXFILESIZE_LARGE, no_larger_than); 핸들 옵션 가져오기이전에 curl_easy_setopt()로 설정한 것과 동일한 정보를 추출하는 일반적인 방법은 없습니다! 이전에 설정한 정보를 다시 추출해야 하는 경우 애플리케이션에서 해당 데이터를 직접 추적하는 것이 좋습니다. TLS 옵션이 글을 쓰는 시점에서 libcurl이 SSL과 TLS를 수행하는 방식을 제어하기 위한 전용 curl_easy_setopt에 대해 40가지 이상의 다른 옵션이 있습니다. TLS를 사용하여 수행된 전송은 안전한 기본값을 사용하지만 curl은 다양한 시나리오 및 설정에서 사용되기 때문에 이러한 동작을 변경하려는 상황이 발생할 가능성이 있습니다. 프로토콜 버전CURLOPT_SSLVERSION 및 CURLOPT_PROXY_SSLVERSION을 사용하여 허용되는 SSL 또는 TLS 프로토콜 범위를 지정할 수 있습니다. 전통적으로 SSL 및 TLS 프로토콜 버전은 시간이 지남에 따라 감지되고 사용하기에 부적합한 것으로 밝혀졌으며 curl 자체가 시간이 지남에 따라 기본 낮은 버전을 올리더라도 가장 최신의 보안 프로토콜 버전만 사용하도록 선택할 수 있습니다. 이러한 옵션은 허용 가능한 가장 낮은 버전과 선택적으로 최대값을 사용합니다. 서버가 해당 조건으로 연결을 협상할 수 없으면 전송이 실패합니다. 예시: 1curl_easy_setopt(easy, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2); 프로토콜 세부정보 및 동작CURLOPT_SSL_CIPHER_LIST 및 CURLOPT_PROXY_SSL_CIPHER_LIST를 설정하여 사용할 암호를 선택할 수 있습니다. CURLOPT_SSL_FALSESTART를 사용하여 SSL “False Start”를 활성화하도록 요청할 수 있으며 CURLOPT_SSL_OPTIONS를 사용하여 조정할 몇 가지 다른 동작 변경 사항이 있습니다. 확인(Verification)TLS를 사용하는 클라이언트는 자신이 말하는 서버가 정확하고 신뢰할 수 있는 서버인지 확인해야 합니다. 이것은 서버의 인증서가 curl에 대한 공개 키가 있는 인증 기관(CA)에 의해 서명되었고 인증서에 서버의 이름이 포함되어 있는지 확인하여 수행됩니다. 이러한 검사 중 하나라도 실패하면 전송이 실패합니다. 개발 목적과 실험을 위해 curl을 사용하면 애플리케이션이 서버 또는 HTTPS 프록시에 대한 이러한 검사 중 하나 또는 둘 다를 끌 수 있습니다. CURLOPT_SSL_VERIFYPEER는 인증서가 신뢰할 수 있는 CA에 의해 서명되었는지 확인하는 것을 제어합니다. CURLOPT_SSL_VERIFYHOST는 인증서 내의 이름 확인을 제어합니다. CURLOPT_PROXY_SSL_VERIFYPEER는 CURLOPT_SSL_VERIFYPEER의 프록시 버전입니다. CURLOPT_PROXY_SSL_VERIFYHOST는 CURLOPT_SSL_VERIFYHOST의 프록시 버전입니다. 선택적으로 CURLOPT_PINNEDPUBLICKEY 또는 CURLOPT_PROXY_PINNEDPUBLICKEY를 사용하여 알려진 해시에 대해 인증서의 공개 키를 확인하도록 curl에 지시할 수 있습니다. 여기에서도 불일치로 인해 전송이 실패합니다. AuthenticationTLS 클라이언트 인증서TLS를 사용하고 서버가 클라이언트에게 인증서를 사용하여 인증하도록 요청할 때 일반적으로 CURLOPT_SSLKEY 및 CURLOPT_SSLCERT를 사용하여 개인 키와 해당 클라이언트 인증서를 지정합니다. 일반적으로 CURLOPT_SSLKEYPASSWD를 사용하여 키의 비밀번호도 설정해야 합니다. 다시 말하지만, CURLOPT_PROXY_SSLKEY, CURLOPT_PROXY_SSLCERT 등 HTTPS 프록시에 대한 연결에 대해 동일한 옵션 세트가 별도로 존재합니다. TLS 인증TLS 연결은 보안 원격 암호라는 (거의 사용되지 않는) 기능을 제공합니다. 이것을 사용하여 이름과 암호를 사용하여 서버에 대한 연결을 인증하고 옵션은 CURLOPT_TLSAUTH_USERNAME 및 CURLOPT_TLSAUTH_PASSWORD입니다. STARTTLSSTARTTLS 방법을 사용하여 TLS(FTP, IMAP, POP3 및 SMTP)로의 연결을 업그레이드하는 프로토콜의 경우 일반적으로 URL을 지정할 때 curl에 비TLS 버전의 프로토콜을 사용하도록 지시한 다음 curl에게 TLS를 활성화하도록 CURLOPT_USE_SSL 옵션으로 요청합니다. 이 옵션을 사용하면 클라이언트가 TLS로 업그레이드할 수 없는 경우 curl을 계속할 수 있지만 제대로 인식하지 못한 채 안전하지 않은 프로토콜을 사용할 수 있으므로 권장하지 않는 경로입니다. 12/* require use of SSL for this, or fail */curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_ALL);","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl API 호환성","slug":"Linux-libcurl API 호환성","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T06:22:09.752Z","comments":true,"path":"2022/02/09/Linux-libcurl API 호환성/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl API 호환성/","excerpt":"","text":"API 호환성libcurl은 API 안정성을 약속하고 오늘 작성된 프로그램이 앞으로도 계속 작동할 것임을 보장합니다. 우리는 호환성을 깨뜨리지 않습니다. 시간이 지남에 따라 기능, 새 옵션 및 새 기능을 API에 추가하지만 호환되지 않는 방식으로 동작을 변경하거나 기능을 제거하지 않습니다. API를 호환되지 않는 방식으로 마지막으로 변경한 것은 2006년 7.16.0용이었고 다시는 변경하지 않을 계획입니다. 버전 번호Curl과 libcurl은 개별적으로 버전이 지정되지만 대부분 서로 밀접하게 따릅니다.버전 번호는 항상 동일한 시스템을 사용하여 구성됩니다. 1X.Y.Z X는 기본 버전 번호입니다. Y는 릴리스 번호입니다. Z는 패치 번호입니다. 범람하는 숫자이 X.Y.Z 숫자 중 하나는 모든 새 릴리스에서 충돌합니다. 범프된 숫자의 오른쪽에 있는 숫자는 0으로 재설정됩니다. 기본 버전 번호 X는 실제로 크고 충돌하는 변경 사항이 있을 때 충돌합니다. 릴리스 번호 Y는 변경이 수행되거나 사물/기능이 추가될 때 범프됩니다. 변경 사항이 단순한 버그 수정일 때 패치 번호 Z가 충돌합니다. 이는 릴리스 1.2.3 이후에 정말 큰 변화가 있으면 2.0.0을 릴리스할 수 있고, 그렇지 않은 경우 1.3.0을 릴리스하거나 대부분의 버그가 수정된 경우 1.2.4를 릴리스할 수 있음을 의미합니다. 숫자를 1로 늘릴 때와 같이 범핑은 무조건 숫자 중 하나에만 영향을 미칩니다(오른쪽에 있는 숫자는 0으로 설정됨). 1은 2가 되고 3은 4가 되고 9는 10이 되고 88은 89가 되고 99는 100이 됩니다. 따라서 1.2.9 이후에는 1.2.10이 됩니다. 3.99.3 이후에는 3.100.0이 나올 수 있습니다. 모든 원본 컬 소스 릴리스 아카이브는 libcurl 버전에 따라 이름이 지정됩니다(앞서 말했듯이 다를 수 있는 컬 클라이언트 버전이 아님). 어떤 libcurl 버전새로운 libcurl 기능을 지원하는 동시에 이전 버전으로 빌드할 수 있는 모든 애플리케이션에 대한 서비스로 모든 릴리스에는 비교에 사용할 수 있는 정적 번호 매기기 체계를 사용하여 curl/curlver.h 파일에 libcurl 버전이 저장되어 있습니다. . 버전 번호는 다음과 같이 정의됩니다. 1#define LIBCURL_VERSION_NUM 0xXXYYZZ 여기서 XX, YY 및 ZZ는 16진수의 기본 버전, 릴리스 및 패치 번호입니다. 세 개의 숫자 필드 모두는 항상 두 자리(각각 8비트)를 사용하여 표현됩니다. 1.2.0은 “0x010200”으로 표시되고 버전 9.11.7은 “0x090b07”로 표시됩니다. 이 6자리 16진수 숫자는 최신 릴리스에서 항상 더 큰 숫자입니다. 일보다 크거나 작음과 비교합니다. 이 번호는 LIBCURL_VERSION_MAJOR, LIBCURL_VERSION_MINOR 및 LIBCURL_VERSION_PATCH의 세 가지 개별 정의로도 사용할 수 있습니다.물론 이러한 정의는 지금 빌드된 버전 번호를 파악하는 데에만 적합하며 지금부터 3년 후 런타임에 사용되는 libcurl 버전을 파악하는 데 도움이 되지 않습니다. 실행되는 libcurl 버전애플리케이션이 현재 사용하고 있는 libcurl 버전을 파악하기 위해 curl_version_info()가 있습니다. 동적/DLL 라이브러리는 응용 프로그램과 독립적으로 변경할 수 있으므로 응용 프로그램은 컴파일 시간 검사를 사용하는 대신 이 기능을 사용하여 작업이 가능한지 여부를 판단해야 합니다. curl_version_info()는 버전 번호 및 다양한 기능과 실행 중인 libcurl 버전에 대한 정보가 포함된 구조체에 대한 포인터를 반환합니다. 당신은 libcurl이 그것을 호출하는 libcurl의 “나이”를 알 수 있도록 특별한 나이 카운터를 주어 그것을 호출합니다. 나이는 CURLVERSION_NOW라고 하는 정의이며 컬 발달 전반에 걸쳐 불규칙한 간격으로 증가하는 카운터입니다. 연령 번호는 libcurl이 반환할 수 있는 구조체 집합을 알려줍니다. 다음과 같이 함수를 호출합니다. 1curl_version_info_data *ver = curl_version_info( CURLVERSION_NOW ); 그러면 데이터는 다음 레이아웃을 갖거나 가질 수 있는 구조체를 가리킬 것입니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct &#123; CURLversion age; /* see description below */ /* when 'age' is 0 or higher, the members below also exist: */ const char *version; /* human readable string */ unsigned int version_num; /* numeric representation */ const char *host; /* human readable string */ int features; /* bitmask, see below */ char *ssl_version; /* human readable string */ long ssl_version_num; /* not used, always zero */ const char *libz_version; /* human readable string */ const char * const *protocols; /* protocols */ /* when 'age' is 1 or higher, the members below also exist: */ const char *ares; /* human readable string */ int ares_num; /* number */ /* when 'age' is 2 or higher, the member below also exists: */ const char *libidn; /* human readable string */ /* when 'age' is 3 or higher (7.16.1 or later), the members below also exist */ int iconv_ver_num; /* '_libiconv_version' if iconv support enabled */ const char *libssh_version; /* human readable string */ /* when 'age' is 4 or higher, the member below also exists: */ unsigned int brotli_ver_num; /* Numeric Brotli version (MAJOR &lt;&lt; 24) | (MINOR &lt;&lt; 12) | PATCH */ const char *brotli_version; /* human readable string. */ /* when 'age' is 5 or higher, the member below also exists: */ unsigned int nghttp2_ver_num; /* Numeric nghttp2 version (MAJOR &lt;&lt; 16) | (MINOR &lt;&lt; 8) | PATCH */ const char *nghttp2_version; /* human readable string. */ const char *quic_version; /* human readable quic (+ HTTP/3) library + version or NULL */ /* when 'age' is 6 or higher, the member below also exists: */ const char *cainfo; /* the built-in default CURLOPT_CAINFO, might be NULL */ const char *capath; /* the built-in default CURLOPT_CAPATH, might be NULL */ /* when 'age' is 7 or higher, the member below also exists: */ unsigned int zstd_ver_num; /* Numeric Zstd version (MAJOR &lt;&lt; 24) | (MINOR &lt;&lt; 12) | PATCH */ const char *zstd_version; /* human readable string. */ /* when 'age' is 8 or higher, the member below also exists: */ const char *hyper_version; /* human readable string. */&#125; curl_version_info_data;","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl for C++ programmers","slug":"Linux-libcurl for C++ programmers","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T07:37:22.903Z","comments":true,"path":"2022/02/09/Linux-libcurl for C++ programmers/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl for C++ programmers/","excerpt":"","text":"for C++ programmerslibcurl은 C API를 제공합니다. C와 C++는 비슷하지만 같지는 않습니다. C++에서 libcurl을 사용할 때 염두에 두어야 할 몇 가지 사항이 있습니다. 문자열은 C++ 문자열 객체가 아니라 C 문자열입니다.char *를 허용하는 libcurl의 API에 문자열을 전달할 때 C++ 문자열이나 객체를 해당 함수에 전달할 수 없음을 의미합니다. 예를 들어, C++로 문자열을 작성한 다음 해당 문자열을 URL로 사용하려는 경우: 12std::string url = \"https://example.com/foo.asp?name=\" + i;curl_easy_setopt(curl, CURLOPT_URL, url.c_str()); 콜백 고려 사항libcurl은 C 라이브러리이기 때문에 C++ 멤버 함수나 객체에 대해 아무것도 모릅니다. 클래스에 대한 포인터가 전달되는 정적 멤버 함수를 사용하면 이 “제한”을 비교적 쉽게 극복할 수 있습니다. 다음은 C++ 메서드를 콜백으로 사용하는 쓰기 콜백의 예입니다. 12345678910// f is the pointer to your object.static size_t YourClass::func(void *buffer, size_t sz, size_t n, void *f)&#123; // Call non-static member function. static_cast&lt;YourClass*&gt;(f)-&gt;nonStaticFunction();&#125;// This is how you pass pointer to the static function:curl_easy_setopt(hcurl, CURLOPT_WRITEFUNCTION, YourClass::func);curl_easy_setopt(hcurl, CURLOPT_WRITEDATA, this);","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl 전역 초기화","slug":"Linux-libcurl 전역 초기화","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T06:26:57.507Z","comments":true,"path":"2022/02/09/Linux-libcurl 전역 초기화/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl 전역 초기화/","excerpt":"","text":"전역 초기화프로그램에서 libcurl과 관련된 작업을 수행하기 전에 curl_global_init()으로 전역 libcurl 초기화 호출을 수행해야 합니다. 이는 libcurl이 사용할 수 있는 일부 기본 라이브러리가 설정을 가져오고 적절하게 초기화하기 위해 미리 호출해야 하기 때문에 필요합니다. curl_global_init()은 불행히도 스레드로부터 안전하지 않으므로 한 번만 수행하고 다른 호출과 동시에 수행하지 않도록 해야 합니다. 전역 상태를 초기화하므로 한 번만 호출해야 하며 프로그램이 libcurl을 사용하여 완전히 완료되면 curl_global_cleanup()을 호출하여 할당된 초기화 호출과 관련된 전역 리소스를 해제하고 정리할 수 있습니다. libcurl은 curl_global_init() 호출을 건너뛰는 상황을 처리하도록 빌드되었지만 대신 자체적으로 호출하여 수행하고(실제 파일 전송이 시작되기 전에 수행하지 않은 경우) 자체 기본값을 사용합니다. 그러나 그때도 여전히 스레드로부터 안전하지 않으므로 “흥미로운” 부작용이 발생할 수 있습니다. curl_global_init()를 제어된 방식으로 직접 호출하는 것이 훨씬 좋습니다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl 이름 확인","slug":"Linux-libcurl 이름 확인","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T08:49:04.653Z","comments":true,"path":"2022/02/09/Linux-libcurl 이름 확인/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl 이름 확인/","excerpt":"","text":"이름 확인libcurl이 수행할 수 있는 대부분의 전송에는 먼저 인터넷 주소로 변환되어야 하는 이름이 포함됩니다. 그것은 “이름 확인”입니다. URL에서 직접 숫자 IP 주소를 사용하면 일반적으로 이름 확인 단계를 피할 수 있지만 대부분의 경우 이름을 IP 주소로 수동으로 바꾸는 것이 쉽지 않습니다. libcurl은 새로운 연결을 생성하기 보다는 기존 연결을 재사용하기 위해 열심히 노력합니다. 사용할 기존 연결을 확인하는 기능은 순전히 이름을 기반으로 하며 이름 확인이 시도되기 전에 수행됩니다. 이것이 재사용이 훨씬 더 빠른 이유 중 하나입니다. 재사용된 연결을 사용하는 전송은 호스트 이름을 다시 확인하지 않습니다. 연결을 재사용할 수 없는 경우 libcurl은 확인하려는 주소 집합으로 호스트 이름을 확인합니다. 일반적으로 이것은 IPv4 및 IPv6 주소를 모두 요청한다는 것을 의미하며 libcurl에 반환된 전체 집합이 있을 수 있습니다. 그런 다음 해당 주소 집합이 작동하거나 실패를 반환할 때까지 시도됩니다. 응용 프로그램은 CURLOPT_IPRESOLVE를 기본 값으로 설정하여 libcurl이 IPv4 또는 IPv6 확인 주소만 사용하도록 할 수 있습니다. 예를 들어 IPv6 주소만 사용하도록 요청합니다. 1curl_easy_setopt(easy, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V6); 이름 확인자 백엔드libcurl은 이 세 가지 다른 방법 중 하나로 이름 확인을 수행하도록 빌드할 수 있으며 사용되는 백엔드 방법에 따라 약간 다른 기능 세트와 때때로 수정된 동작을 얻습니다. 기본 백엔드는 새로운 도우미 스레드에서 “일반” libc 해석기 기능을 호출하므로 원하는 경우 여전히 세분화된 시간 초과를 수행할 수 있고 차단 호출이 포함되지 않습니다. 이전 시스템에서 libcurl은 표준 동기 이름 해석기 기능을 사용합니다. 불행히도 작동하는 동안 다중 핸들 블록 내에서 모든 전송을 수행하며 멋지게 시간 초과되는 것이 훨씬 더 어렵습니다. 스레드를 사용하지 않고 비동기식 이름 확인을 지원하는 c-ares 타사 라이브러리로 확인하기 위한 지원도 있습니다. 이것은 엄청난 수의 병렬 전송으로 더 잘 확장되지만 기본 이름 확인기 기능과 항상 100% 호환되는 것은 아닙니다. HTTPS를 통한 DNSlibcurl이 사용하도록 빌드된 확인자 백엔드와는 별개로, 7.62.0부터는 사용자가 특정 DoH(DNS over HTTPS) 서버에 이름 주소를 요청할 수 있는 방법도 제공합니다. 이렇게 하면 일반적인 기본 리졸버 메서드와 서버를 사용하지 않고 전용 별도의 메서드와 서버를 요청합니다. DoH 서버는 다음과 같이 CURLOPT_DOH_URL 옵션을 사용하여 전체 URL로 지정됩니다. 1curl_easy_setopt(easy, CURLOPT_DOH_URL, \"https://example.com/doh\"); 이 옵션에 전달되는 URL은 https://를 사용해야 하며 일반적으로 libcurl이 DoH 서버에 대한 연결을 통해 다중 DoH 요청을 수행할 수 있도록 HTTP/2 지원을 활성화하는 것이 좋습니다. 캐싱이름이 확인되면 결과는 libcurl의 메모리 내 캐시에 저장되어 이름이 DNS 캐시에 유지되는 한 동일한 이름에 대한 후속 확인이 거의 즉시 이루어집니다. 기본적으로 각 항목은 캐시에 60초 동안 유지되지만 해당 값은 CURLOPT_DNS_CACHE_TIMEOUT으로 변경할 수 있습니다. DNS 캐시는 curl_easy_perform을 사용하는 경우 easy 핸들 내에, 멀티 인터페이스를 사용하는 경우 멀티 핸들 내에 유지됩니다. 또한 공유 인터페이스를 사용하여 여러 개의 쉬운 핸들 간에 공유할 수 있습니다. 호스트에 대한 사용자 지정 주소때로는 실제 호스트 이름에 “가짜” 주소를 제공하여 libcurl이 실제 이름 확인이 제안하는 주소 대신 다른 주소에 연결하도록 하는 것이 편리합니다. CURLOPT_RESOLVE 옵션의 도움으로 응용 프로그램은 libcurl의 DNS 캐시를 지정된 호스트 이름 및 포트 번호에 대한 사용자 지정 주소로 미리 채울 수 있습니다. 포트 443의 example.com이 요청될 때 libcurl이 127.0.0.1에 연결되도록 하려면 애플리케이션에서 다음을 수행할 수 있습니다. 123struct curl_slist *dns;dns = curl_slist_append(NULL, \"example.com:443:127.0.0.1\");curl_easy_setopt(curl, CURLOPT_RESOLVE, dns); 이렇게 하면 “가짜” 주소가 DNS 캐시에 저장되기 때문에 리디렉션 등을 따라갈 때도 작동합니다. 네임서버 옵션c-ares를 사용하도록 빌드된 libcurl의 경우 사용할 DNS 서버와 방법을 세밀하게 제어할 수 있는 몇 가지 옵션이 있습니다. 이것은 이름 해석을 위한 표준 시스템 호출이 사용될 때 사용할 수 없는 권한이기 때문에 순전히 c-are 빌드로 제한됩니다. CURLOPT_DNS_SERVERS를 통해 애플리케이션은 전용 DNS 서버 세트를 사용하도록 선택할 수 있습니다. CURLOPT_DNS_INTERFACE를 사용하면 기본 인터페이스 대신 DNS를 사용할 네트워크 인터페이스를 libcurl에 알릴 수 있습니다. CURLOPT_DNS_LOCAL_IP4 및 CURLOPT_DNS_LOCAL_IP6을 사용하면 응용 프로그램에서 DNS를 바인딩할 특정 네트워크 주소를 지정할 수 있습니다. 전역 DNS 캐시 없음CURLOPT_DNS_USE_GLOBAL_CACHE라는 옵션은 한때 curl에 전역 DNS 캐시를 사용하도록 지시했습니다. 이 기능은 7.65.0 이후 제거되었으므로 이 옵션이 여전히 존재하는 동안에는 아무 것도 하지 않습니다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl 핸들 간에 데이터 공유","slug":"Linux-libcurl 핸들 간에 데이터 공유","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T08:48:12.075Z","comments":true,"path":"2022/02/09/Linux-libcurl 핸들 간에 데이터 공유/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl 핸들 간에 데이터 공유/","excerpt":"","text":"핸들 간에 데이터 공유때때로 응용 프로그램은 전송 간에 데이터를 공유해야 합니다. 동일한 다중 핸들에 추가된 모든 쉬운 핸들은 동일한 다중 핸들의 핸들 간에 많은 공유가 자동으로 수행되지만 때로는 정확히 원하는 것이 아닙니다. 멀티 핸들동일한 다중 핸들에 추가된 모든 간편 핸들은 연결 캐시와 DNS 캐시를 자동으로 공유합니다. 쉬운 핸들 간 공유libcurl에는 일반 “공유 인터페이스”가 있으며, 여기서 응용 프로그램은 “공유 개체”를 생성한 다음 여러 손쉬운 핸들에서 공유할 수 있는 데이터를 보유합니다. 그런 다음 데이터를 공유하는 핸들 내에 보관하는 대신 공유 개체에서 데이터를 저장하고 읽습니다. 1CURLSH *share = curl_share_init(); 공유 객체는 쿠키, 연결 캐시, dns 캐시 및 SSL 세션 ID 캐시의 전체 또는 일부를 공유하도록 설정할 수 있습니다. 예를 들어 쿠키 및 DNS 캐시를 보유하도록 공유 설정: 12curl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_COOKIE);curl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS); 그런 다음 이 공유 개체를 사용하도록 해당 전송을 설정합니다. 1curl_easy_setopt(curl, CURLOPT_SHARE, share); 따라서 이 컬 핸들로 수행된 전송은 공유 핸들의 쿠키 및 DNS 정보를 사용하고 저장합니다. 동일한 공유 개체를 공유하기 위해 여러 개의 쉬운 핸들을 설정할 수 있습니다. 무엇을 공유할 것인가CURL_LOCK_DATA_COOKIE - 쿠키 항아리를 공유하려면 이 비트를 설정합니다. 각각의 쉬운 핸들은 쿠키 사용을 시작하기 위해 쿠키 “엔진”을 제대로 시작해야 합니다. CURL_LOCK_DATA_DNS - DNS 캐시는 libcurl이 이후 조회를 더 빠르게 하기 위해 확인된 호스트 이름에 대한 주소를 잠시 저장하는 곳입니다. CURL_LOCK_DATA_SSL_SESSION - SSL 세션 ID 캐시는 libcurl이 이전 연결을 더 빨리 재개할 수 있도록 SSL 연결에 대한 재개 정보를 저장하는 곳입니다. CURL_LOCK_DATA_CONNECT - 설정되면 이 핸들은 공유 연결 캐시를 사용하므로 재사용할 기존 연결을 찾을 가능성이 더 높아져 동일한 호스트에 직렬 방식으로 여러 번 전송할 때 성능이 더 빨라질 수 있습니다. 잠금다중 스레드 환경에서 전송을 통해 공유 개체를 공유하려는 경우. 아마도 많은 코어가 있는 CPU가 있고 각 코어가 자체 스레드를 실행하고 데이터를 전송하기를 원하지만 여전히 다른 전송에서 데이터를 공유하기를 원할 수 있습니다. 그런 다음 뮤텍스 콜백을 설정해야 합니다. 스레딩을 사용하지 않고 한 번에 하나씩 직렬 방식으로 공유 개체에 액세스한다는 것을 알고 있으면 잠금을 설정할 필요가 없습니다. 그러나 한 번에 공유 개체에 액세스하는 전송이 두 개 이상 있는 경우 데이터 파괴 및 충돌을 방지하기 위해 뮤텍스 콜백 설정을 가져와야 합니다. libcurl 자체는 사물을 잠그는 방법이나 사용 중인 스레딩 모델을 알지 못하기 때문에 한 번에 하나의 액세스만 허용하는 뮤텍스 잠금을 수행해야 합니다. pthreads 사용 애플리케이션에 대한 잠금 콜백은 다음과 유사할 수 있습니다. 123456static void lock_cb(CURL *handle, curl_lock_data data, curl_lock_access access, void *userptr)&#123; pthread_mutex_lock(&amp;lock[data]); /* uses a global lock array */&#125;curl_share_setopt(share, CURLSHOPT_LOCKFUNC, lock_cb); 해당 잠금 해제 콜백을 사용하면 다음과 같이 보일 수 있습니다. 123456static void unlock_cb(CURL *handle, curl_lock_data data, void *userptr)&#123; pthread_mutex_unlock(&amp;lock[data]); /* uses a global lock array */&#125;curl_share_setopt(share, CURLSHOPT_UNLOCKFUNC, unlock_cb); 공유 해제전송은 전송 중에 공유 개체를 사용하고 동일한 개체를 공유하는 다른 핸들과 공유하도록 지정된 개체를 공유합니다. 후속 전송에서 CURLOPT_SHARE를 NULL로 설정하여 전송이 계속 공유되는 것을 방지할 수 있습니다. 이 경우 핸들은 이전에 공유된 데이터에 대한 빈 캐시로 다음 전송을 시작할 수 있습니다. 두 전송 간에 공유 개체는 다른 속성 집합을 공유하도록 업데이트되어 해당 개체를 공유하는 핸들이 다음에 다른 데이터 집합을 공유할 수도 있습니다. DNS 데이터를 공유 해제할 때 다음과 같이 curl_share_setopt()의 CURLSHOPT_UNSHARE 옵션을 사용하여 공유 개체에서 공유할 항목을 제거합니다. 1curl_share_setopt(share, CURLSHOPT_UNSHARE, CURL_LOCK_DATA_DNS);","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl 자세한 작업","slug":"Linux-libcurl 자세한 작업","date":"2022-02-09T04:02:00.000Z","updated":"2022-02-09T07:27:04.900Z","comments":true,"path":"2022/02/09/Linux-libcurl 자세한 작업/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl 자세한 작업/","excerpt":"","text":"자세한 작업좋습니다, 우리는 특정 전송에서 무엇이 잘못되었는지 파악하고 종종 왜 그렇게 할 수 있는지 또는 현재 문제가 무엇인지 설명하기 때문에 사람이 읽을 수 있는 텍스트로 오류를 얻는 방법을 보여주었습니다. 최소한 libcurl 애플리케이션을 개발하거나 libcurl 자체를 디버깅하는 동안 모두가 알아야 하고 광범위하게 사용해야 하는 libcurl 애플리케이션을 작성할 때 다음 생명의 은인은 CURLOPT_VERBOSE를 사용하여 “상세 모드”를 활성화하는 것입니다. 1CURLcode ret = curl_easy_setopt(handle, CURLOPT_VERBOSE, 1L); libcurl이 verbose라고 하면 전송이 진행되는 동안 전송 관련 세부 정보 및 정보를 stderr에 언급합니다. 이것은 일이 실패하는 이유를 알아내고 libcurl이 다른 것을 요청할 때 정확히 무엇을 하는지 알아내는 것은 굉장합니다. CURLOPT_STDERR을 사용하여 stderr을 변경하여 출력을 다른 곳으로 리디렉션하거나 디버그 콜백을 사용하여 더 멋진 방식으로 더 많은 정보를 얻을 수 있습니다(나중 섹션에서 자세히 설명). 모든 것을 추적Verbose는 확실히 괜찮지만 때로는 더 필요합니다. libcurl은 또한 자세한 정보 표시 모드가 수행하는 모든 작업을 표시하는 것 외에도 전송 및 수신된 모든 데이터를 전달하여 애플리케이션이 모든 것을 완벽하게 추적할 수 있도록 추적 콜백을 제공합니다. 추적 콜백으로 전달되고 수신된 데이터는 암호화되지 않은 형식으로 콜백에 제공되며, 이는 디버깅을 위해 네트워크에서 데이터를 캡처하는 것이 실용적이지 않을 때 TLS 또는 SSH 기반 프로토콜로 작업할 때 편리할 수 있습니다. CURLOPT_DEBUGFUNCTION 옵션을 설정할 때 여전히 CURLOPT_VERBOSE를 활성화해야 하지만 추적 콜백을 설정하면 libcurl은 내부 처리 대신 해당 콜백을 사용합니다. 추적 콜백은 다음과 같은 프로토타입과 일치해야 합니다. 12int my_trace(CURL *handle, curl_infotype type, char *ptr, size_t size, void *userp); 핸들은 관련된 쉬운 핸들이고, 유형은 콜백에 전달된 특정 데이터(데이터 입/출력, 헤더 입/출력, TLS 데이터 입/출력 및 “텍스트”)를 설명하고, ptr은 크기가 바이트 수인 데이터를 가리킵니다. userp는 CURLOPT_DEBUGDATA로 설정한 사용자 지정 포인터입니다. ptr이 가리키는 데이터는 0으로 종료되지 않지만 size 인수에 의해 지시된 크기와 정확히 일치합니다. 콜백은 0을 반환해야 하며 그렇지 않으면 libcurl은 이를 오류로 간주하고 전송을 중단합니다. curl 웹사이트에서 영감을 얻을 수 있는 간단한 추적 기능이 포함된 debug.c라는 예제를 호스팅합니다. CURLOPT_DEBUGFUNCTION 매뉴얼 페이지에도 추가 세부 정보가 있습니다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl Cleanup","slug":"Linux-libcurl Cleanup","date":"2022-02-09T04:00:18.000Z","updated":"2022-02-09T04:01:41.557Z","comments":true,"path":"2022/02/09/Linux-libcurl Cleanup/","link":"","permalink":"http://jung-max.github.io/2022/02/09/Linux-libcurl Cleanup/","excerpt":"","text":"Cleanup이전 섹션에서 핸들을 설정하는 방법과 전송을 구동하는 방법에 대해 논의했습니다. 물론 모든 전송은 성공하거나 실패하는 어느 시점에서 끝납니다. 멀티 API다중 API로 단일 전송을 완료하면 curl_multi_info_read()를 사용하여 어떤 easy 핸들이 완료되었는지 정확히 식별하고 curl_multi_remove_handle()로 다중 핸들에서 해당 easy 핸들을 제거합니다. 더 이상 전송이 진행되지 않도록 다중 핸들에서 마지막 쉬운 핸들을 제거하면 다음과 같이 다중 핸들을 닫을 수 있습니다. 1curl_multi_cleanup( multi_handle ); 쉬운 핸들쉬운 핸들이 목적을 달성하면 닫을 수 있습니다. 다른 전송을 수행하려는 경우 핸들을 닫고 새 핸들을 만드는 것보다 핸들을 재사용하는 것이 좋습니다. 쉬운 핸들로 다른 전송을 수행하지 않으려면 libcurl에 정리를 요청하기만 하면 됩니다. 1curl_easy_cleanup( easy_handle );","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl Callback","slug":"Linux-libcurl callback","date":"2022-02-08T06:27:44.000Z","updated":"2022-02-09T08:55:31.734Z","comments":true,"path":"2022/02/08/Linux-libcurl callback/","link":"","permalink":"http://jung-max.github.io/2022/02/08/Linux-libcurl callback/","excerpt":"","text":"콜백libcurl 내의 많은 작업은 콜백을 사용하여 제어됩니다. 콜백은 libcurl이 특정 작업을 완료하기 위해 특정 시점에서 호출하는 libcurl에 제공되는 함수 포인터입니다. 각 콜백에는 문서화된 특정 목적이 있으며 올바른 인수를 수락하고 문서화된 반환 코드와 반환 값을 반환하여 libcurl이 원하는 방식으로 수행할 수 있도록 정확한 함수 프로토타입으로 작성해야 합니다. 각 콜백 옵션에는 연결된 “사용자 포인터”를 설정하는 동반 옵션도 있습니다. 이 사용자 포인터는 libcurl이 만지거나 신경 쓰지 않고 콜백에 대한 인수로 전달하는 포인터입니다. 이를 통해 예를 들어 로컬 데이터에 대한 포인터를 콜백 함수까지 전달할 수 있습니다. libcurl 함수 문서에 명시적으로 언급되지 않은 한 libcurl 콜백 내에서 libcurl 함수를 호출하는 것은 불법입니다. 데이터 쓰기쓰기 콜백은 CURLOPT_WRITEFUNCTION으로 설정됩니다. 1curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, write_callback); write_callback 함수는 다음 프로토타입과 일치해야 합니다. 1size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata); 이 콜백 함수는 저장해야 하는 데이터가 수신되는 즉시 libcurl에 의해 호출됩니다. ptr은 전달된 데이터를 가리키며 해당 데이터의 크기는 nmemb와 곱한 크기입니다. 이 콜백이 설정되지 않은 경우 libcurl은 기본적으로 ‘fwrite’를 대신 사용합니다. 쓰기 콜백은 모든 호출에서 가능한 한 많은 데이터를 전달하지만 어떤 가정도 해서는 안 됩니다. 1바이트일 수도 있고 수천 바이트일 수도 있습니다. 쓰기 콜백에 전달될 본문 데이터의 최대 양은 curl.h 헤더 파일 CURL_MAX_WRITE_SIZE에 정의되어 있습니다(일반적인 기본값은 16KB). 헤더 데이터가 쓰기 콜백으로 전달되도록 이 전송에 대해 CURLOPT_HEADER가 활성화된 경우 전달된 헤더 데이터의 최대 CURL_MAX_HTTP_HEADER 바이트를 얻을 수 있습니다. 이것은 일반적으로 100KB를 의미합니다. 이 함수는 전송된 파일이 비어 있는 경우 0바이트 데이터로 호출될 수 있습니다. 이 함수에 전달된 데이터는 0으로 종료되지 않습니다. 예를 들어, printf의 %s 연산자를 사용하여 내용을 표시하거나 strcpy를 사용하여 복사할 수 없습니다. 이 콜백은 실제로 처리된 바이트 수를 반환해야 합니다. 해당 번호가 콜백 함수에 전달된 번호와 다르면 라이브러리에 오류 상태를 알립니다. 이로 인해 전송이 중단되고 사용된 libcurl 함수는 CURLE_WRITE_ERROR를 반환합니다. userdata 인수의 콜백에 전달된 사용자 포인터는 CURLOPT_WRITEDATA로 설정됩니다. 1curl_easy_setopt(handle, CURLOPT_WRITEDATA, custom_pointer); 메모리에 저장인기 있는 요구는 검색된 응답을 메모리에 저장하는 것이며 위에서 설명한 콜백이 이를 지원합니다. 이 작업을 수행할 때 응답이 잠재적으로 엄청날 수 있으므로 주의하십시오. 다음과 유사한 방식으로 콜백을 구현합니다. 12345678910111213141516171819202122232425262728293031323334353637struct response &#123; char *memory; size_t size;&#125;;static size_tmem_cb(void *contents, size_t size, size_t nmemb, void *userp)&#123; size_t realsize = size * nmemb; struct repsonse *mem = (struct response *)userp; char *ptr = realloc(mem-&gt;memory, mem-&gt;size + realsize + 1); if(!ptr) &#123; /* out of memory! */ printf(\"not enough memory (realloc returned NULL)\\n\"); return 0; &#125; mem-&gt;memory = ptr; memcpy(&amp;(mem-&gt;memory[mem-&gt;size]), contents, realsize); mem-&gt;size += realsize; mem-&gt;memory[mem-&gt;size] = 0; return realsize;&#125;int main()&#123; struct response chunk; /* send all data to this function */ curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, mem_cb); /* we pass our 'chunk' to the callback function */ curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (void *)&amp;chunk);&#125; 데이터 읽기읽기 콜백은 CURLOPT_READFUNCTION으로 설정됩니다. 1curl_easy_setopt(handle, CURLOPT_READFUNCTION, read_callback); read`_callback 함수는 다음 프로토타입과 일치해야 합니다. 1size_t read_callback(char *buffer, size_t size, size_t nitems, void *stream); 이 콜백 함수는 서버에 데이터를 보내려고 할 때 libcurl에 의해 호출됩니다. 이것은 데이터를 업로드하거나 서버로 보내도록 설정한 전송입니다. 이 콜백은 모든 데이터가 전달되거나 전송이 실패할 때까지 계속해서 호출됩니다. 스트림 포인터는 CURLOPT_READDATA를 사용하여 개인 데이터 세트를 가리킵니다. 1curl_easy_setopt(handle, CURLOPT_READDATA, custom_pointer); 이 콜백이 설정되지 않은 경우 libcurl은 기본적으로 ‘fread’를 대신 사용합니다. 포인터 버퍼가 가리키는 데이터 영역은 함수에 의해 nitems 수를 곱한 최대 크기로 채워져야 합니다. 그런 다음 콜백은 해당 메모리 영역에 저장된 바이트 수를 반환하거나 데이터 끝에 도달한 경우 0을 반환해야 합니다. 콜백은 또한 libcurl이 즉시 실패를 반환하거나 특정 전송을 일시 중지하도록 하는 몇 가지 “마법” 반환 코드를 반환할 수 있습니다. 자세한 내용은 CURLOPT_READFUNCTION 매뉴얼 페이지를 참조하십시오. 진행 정보진행 콜백은 전송의 전체 수명 동안 각 전송에 대해 정기적으로 반복적으로 호출되는 것입니다. 이전 콜백은 CURLOPT_PROGRESSFUNCTION으로 설정되었지만 최신 콜백은 CURLOPT_XFERINFOFUNCTION으로 설정되었습니다. 1curl_easy_setopt(handle, CURLOPT_XFERINFOFUNCTION, xfer_callback); xfer_callback 함수는 다음 프로토타입과 일치해야 합니다. 12int xfer_callback(void *clientp, curl_off_t dltotal, curl_off_t dlnow, curl_off_t ultotal, curl_off_t ulnow); 이 옵션이 설정되고 CURLOPT_NOPROGRESS가 0(영)으로 설정되면 이 콜백 함수는 libcurl에 의해 빈번한 간격으로 호출됩니다. 데이터가 전송되는 동안에는 자주 호출되며 아무 것도 전송되지 않는 경우와 같이 느린 시간에는 초당 약 1회의 호출로 느려질 수 있습니다. clientp 포인터는 CURLOPT_XFERINFODATA를 사용하여 개인 데이터 세트를 가리킵니다. 1curl_easy_setopt(handle, CURLOPT_XFERINFODATA, custom_pointer); 콜백은 libcurl이 전송하고 전송한 데이터의 양을 바이트 수로 알려줍니다. dltotal은 libcurl이 이 전송에서 다운로드할 것으로 예상하는 총 바이트 수입니다. dlnow는 지금까지 다운로드한 바이트 수입니다. ultotal은 libcurl이 이 전송에서 업로드할 것으로 예상하는 총 바이트 수입니다. ulnow는 지금까지 업로드된 바이트 수입니다. 콜백에 전달된 알 수 없거나 사용되지 않은 인수 값은 0으로 설정됩니다(예: 데이터만 다운로드하는 경우 업로드 크기는 0으로 유지됨). 여러 번 콜백은 데이터 크기를 알기 전에 먼저 한 번 이상 호출되므로 이를 처리하도록 프로그램을 만들어야 합니다. 이 콜백에서 0이 아닌 값을 반환하면 libcurl이 전송을 중단하고 CURLE_ABORTED_BY_CALLBACK을 반환합니다. 다중 인터페이스로 데이터를 전송하는 경우 전송을 수행하는 적절한 libcurl 함수를 호출하지 않는 한 유휴 기간 동안 이 함수가 호출되지 않습니다. (더 이상 사용되지 않는 콜백 CURLOPT_PROGRESSFUNCTION은 동일하게 작동했지만 curl_off_t 유형의 인수를 사용하는 대신 double을 사용했습니다.) 헤더 데이터헤더 콜백은 CURLOPT_HEADERFUNCTION으로 설정됩니다. 1curl_easy_setopt(handle, CURLOPT_HEADERFUNCTION, header_callback); header_callback 함수는 다음 프로토타입과 일치해야 합니다. 1size_t header_callback(char *ptr, size_t size, size_t nmemb, void *userdata); 이 콜백 함수는 헤더가 수신되는 즉시 libcurl에 의해 호출됩니다. ptr은 전달된 데이터를 가리키며 해당 데이터의 크기는 nmemb와 곱한 크기입니다. libcurl은 헤더를 버퍼링하고 “전체” 헤더만 이 콜백에 하나씩 전달합니다. 이 함수에 전달된 데이터는 0으로 종료되지 않습니다! 예를 들어, printf의 %s 연산자를 사용하여 내용을 표시하거나 strcpy를 사용하여 복사할 수 없습니다. 이 콜백은 실제로 처리된 바이트 수를 반환해야 합니다. 해당 번호가 콜백 함수에 전달된 번호와 다르면 라이브러리에 오류 조건을 알립니다. 이로 인해 전송이 중단되고 사용된 libcurl 함수는 CURLE_WRITE_ERROR를 반환합니다. userdata 인수의 콜백에 전달된 사용자 포인터는 CURLOPT_HEADERDATA로 설정됩니다. 1curl_easy_setopt(handle, CURLOPT_HEADERDATA, custom_pointer); Debug디버그 콜백은 CURLOPT_DEBUGFUNCTION으로 설정됩니다. 1curl_easy_setopt(handle, CURLOPT_DEBUGFUNCTION, debug_callback); debug_callback 함수는 다음 프로토타입과 일치해야 합니다. 12345int debug_callback(CURL *handle, curl_infotype type, char *data, size_t size, void *userdata); 이 콜백 함수는 라이브러리의 기본 상세 출력 함수를 대체하며 모든 디버그 및 추적 메시지에 대해 호출되어 애플리케이션이 무슨 일이 일어나고 있는지 이해하도록 돕습니다. type 인수는 헤더, 데이터 또는 SSL 데이터와 같이 제공되는 데이터의 종류와 흐름 방향을 설명합니다. 이 콜백의 일반적인 용도는 libcurl이 보내고 받는 모든 데이터의 전체 추적을 가져오는 것입니다. 이 콜백으로 전송되는 데이터는 예를 들어 HTTPS 또는 기타 암호화된 프로토콜이 사용되는 경우에도 항상 암호화되지 않은 버전입니다.이 콜백은 0을 반환하거나 오류 코드와 함께 전송을 중지해야 합니다. userdata 인수의 콜백에 전달된 사용자 포인터는 CURLOPT_DEBUGDATA로 설정됩니다. 1curl_easy_setopt(handle, CURLOPT_DEBUGDATA, custom_pointer); sockoptsockopt 콜백은 CURLOPT_SOCKOPTFUNCTION으로 설정됩니다. 1curl_easy_setopt(handle, CURLOPT_SOCKOPTFUNCTION, sockopt_callback); sockopt_callback 함수는 다음 프로토타입과 일치해야 합니다. 123int sockopt_callback(void *clientp, curl_socket_t curlfd, curlsocktype purpose); 이 콜백 함수는 새 소켓이 생성되었지만 연결 호출 전에 응용 프로그램이 특정 소켓 옵션을 변경할 수 있도록 libcurl에 의해 호출됩니다. clientp 포인터는 CURLOPT_SOCKOPTDATA를 사용하여 개인 데이터 세트를 가리킵니다. 1curl_easy_setopt(handle, CURLOPT_SOCKOPTDATA, custom_pointer); 이 콜백은 다음을 반환해야 합니다. CURL_SOCKOPT_OK 성공 libcurl에 복구할 수 없는 오류를 알리는 CURL_SOCKOPT_ERROR CURL_SOCKOPT_ALREADY_CONNECTED는 성공을 알리지만 소켓이 실제로 이미 대상에 연결되어 있음을 나타냅니다. SSL contextlibcurl은 CURLOPT_SSL_CTX_FUNCTION이라는 특수한 TLS 관련 콜백을 제공합니다. 이 옵션은 OpenSSL, wolfSSL 또는 mbedTLS로 구동되는 libcurl에서만 작동하며 libcurl이 다른 TLS 백엔드로 빌드된 경우에는 아무 작업도 수행하지 않습니다. 이 콜백은 응용 프로그램이 TLS 초기화 동작을 수정할 수 있는 마지막 기회를 제공하기 위해 다른 모든 TLS 관련 옵션을 처리한 후 TLS 연결 초기화 직전에 libcurl에 의해 호출됩니다. 두 번째 인수에서 콜백에 전달된 ssl_ctx 매개변수는 실제로 OpenSSL 또는 wolfSSL의 경우 SSL 라이브러리의 SSL_CTX에 대한 포인터이고 mbedTLS의 경우 mbedtls_ssl_config에 대한 포인터입니다. 콜백에서 오류가 반환되면 연결 설정을 시도하지 않고 작업에서 콜백의 오류 코드를 반환합니다. CURLOPT_SSL_CTX_DATA 옵션으로 userptr 인수를 설정합니다. 이 함수는 TLS 협상 중에 서버에 대한 모든 새 연결에서 호출됩니다. TLS 컨텍스트는 매번 새로 초기화된 개체를 가리킵니다. Seek and ioctl이 콜백은 CURLOPT_SEEKFUNCTION으로 설정됩니다. 콜백은 입력 스트림의 특정 위치를 찾기 위해 libcurl에 의해 호출되며 재개된 업로드에서 파일을 빨리 전달하는 데 사용할 수 있습니다(일반 읽기 기능/콜백으로 업로드된 모든 바이트를 읽는 대신). 데이터가 이미 서버로 전송되어 다시 전송해야 할 때 스트림을 되감기 위해 호출되기도 합니다. 이는 다중 패스 인증 방법으로 HTTP PUT 또는 POST를 수행할 때 또는 기존 HTTP 연결이 너무 늦게 재사용되어 서버가 연결을 닫을 때 발생할 수 있습니다. 이 함수는 fseek(3) 또는 lseek(3)처럼 작동해야 하며 libcurl이 현재 SEEK_SET만 전달하지만 SEEK_SET, SEEK_CUR 또는 SEEK_END를 원본에 대한 인수로 가져옵니다. 콜백으로 전송된 사용자 정의 userp는 CURLOPT_SEEKDATA로 설정한 포인터입니다. 콜백 함수는 성공 시 CURL_SEEKFUNC_OK를 반환해야 하고, 업로드 작업이 실패하도록 하려면 CURL_SEEKFUNC_FAIL을 반환해야 하며, 탐색이 실패한 동안 가능한 경우 libcurl이 자유롭게 문제를 해결할 수 있음을 나타내려면 CURL_SEEKFUNC_CANTSEEK를 반환해야 합니다. 후자는 때때로 입력 또는 이와 유사한 것을 대신 읽어서 수행할 수 있습니다. 입력 인수를 fseek(3) 또는 lseek(3)에 직접 전달하는 경우 offset의 데이터 유형은 많은 시스템에서 curl_off_t에 대해 정의된 것과 동일하지 않습니다. 네트워크 데이터 변환네트워크 콜백과의 변환비 ASCII 플랫폼의 경우 CURLOPT_CONV_FROM_NETWORK_FUNCTION이 제공됩니다. 이 기능은 네트워크 인코딩에서 호스트 인코딩으로 변환되어야 합니다. CURLOPT_CONV_TO_NETWORK_FUNCTION은 호스트 인코딩에서 네트워크 인코딩으로 변환해야 합니다. 네트워크를 통해 명령이나 ASCII 데이터를 보낼 때 사용합니다. UTF-8 콜백에서 변환CURLOPT_CONV_FROM_UTF8_FUNCTION은 UTF-8 인코딩에서 호스트 인코딩으로 변환해야 합니다. SSL 처리에만 필요합니다. Opensocket and closesocket때때로 libcurl이 작업에 사용할 소켓을 보다 정확하게 제어하기를 원하는 상황이 발생합니다. libcurl은 socket()에 대한 libcurl의 자체 호출과 동일한 파일 설명자의 후속 close()를 대체하는 이 콜백 쌍을 제공합니다. 파일 설명자 제공CURLOPT_OPENSOCKETFUNCTION 콜백을 설정하여 libcurl이 사용할 파일 설명자를 반환하는 사용자 정의 함수를 제공할 수 있습니다. 1curl_easy_setopt(handle, CURLOPT_OPENSOCKETFUNCTION, opensocket_callback); opensocket_callback 함수는 다음 프로토타입과 일치해야 합니다. 123curl_socket_t opensocket_callback(void *clientp, curlsocktype purpose, struct curl_sockaddr *address); 콜백은 CURLOPT_OPENSOCKETDATA로 설정한 단순히 불투명한 포인터인 clientp를 첫 번째 인수로 가져옵니다. 다른 두 인수는 소켓을 사용할 목적과 주소를 식별하는 데이터를 전달합니다. 목적은 소켓이 생성되는 상황을 식별하는 CURLSOCKTYPE_IPCXN 또는 CURLSOCKTYPE_ACCEPT 값을 가진 typedef입니다. “수락” 경우는 FTP 활성 모드가 사용될 때 libcurl이 들어오는 FTP 연결을 수락하는 데 사용되며 libcurl이 자체 나가는 연결을 위한 소켓을 만드는 다른 모든 경우에는 IPCXN 값이 전달됩니다. 주소 포인터는 이 소켓이 생성되는 네트워크 대상의 IP 주소를 설명하는 curl_sockaddr 구조체를 가리킵니다. 예를 들어 콜백은 이 정보를 사용하여 특정 주소 또는 주소 범위를 화이트리스트 또는 블랙리스트에 추가할 수 있습니다. 어떤 종류의 네트워크 필터 또는 변환 계층을 제공하려는 경우 socketopen 콜백은 해당 구조체의 대상 주소를 수정할 수도 있습니다. 콜백은 파일 설명자 또는 CURL_SOCKET_BAD를 반환해야 합니다. 그러면 libcurl 내에서 복구할 수 없는 오류가 발생하고 결국에는 수행 함수에서 CURLE_COULDNT_CONNECT를 반환합니다. 이미 서버에 연결된 파일 설명자를 반환하려면 sockopt 콜백도 설정하고 올바른 반환 값을 반환하는지 확인해야 합니다. curl_sockaddress 구조체는 다음과 같습니다. 1234567struct curl_sockaddr &#123; int family; int socktype; int protocol; unsigned int addrlen; struct sockaddr addr;&#125;; Socket close callback열린 소켓에 대한 해당 콜백은 물론 닫기 소켓입니다. 일반적으로 파일 설명자를 제공하는 사용자 지정 방법을 제공할 때 자체 정리 버전도 제공하려고 합니다. 1curl_easy_setopt(handle, CURLOPT_CLOSESOCKETFUNCTION, closesocket_callback); closesocket_callback 함수는 다음 프로토타입과 일치해야 합니다. 1int closesocket_callback(void *clientp, curl_socket_t item); SSH key이 콜백은 CURLOPT_SSH_KEYFUNCTION으로 설정됩니다. 이것은 known_host 매칭이 완료되었을 때 호출되어 애플리케이션이 libcurl을 어떻게 처리할지 결정할 수 있도록 합니다. 콜백은 CURLOPT_SSH_KNOWNHOSTS도 설정된 경우에만 호출됩니다. 콜백에 대한 인수에는 이전 키와 새 키가 있으며 콜백은 libcurl에게 작동 방법을 알려주는 반환 코드를 반환할 것으로 예상됩니다. CURLKHSTAT_FINE_REPLACE - 새 호스트 + 키가 수락되고 libcurl은 연결을 계속하기 전에 이전 호스트 + 키를 known_hosts 파일로 바꿉니다. 이것은 또한 새로운 호스트+키 콤보가 이미 존재하지 않는 경우 메모리에 보관된 known_host 풀에 추가됩니다. 파일에 데이터를 추가하는 것은 파일을 새 복사본으로 완전히 교체하여 수행되므로 파일의 권한이 이를 허용해야 합니다. CURLKHSTAT_FINE_ADD_TO_FILE - 호스트+키가 수락되고 libcurl은 연결을 계속하기 전에 이것을 known_hosts 파일에 추가합니다. 이것은 또한 이미 존재하지 않는 경우 메모리에 보관된 known_host 풀에 host+key 콤보를 추가합니다. 파일에 데이터를 추가하는 것은 파일을 새 복사본으로 완전히 교체하여 수행되므로 파일의 권한이 이를 허용해야 합니다. CURLKHSTAT_FINE - 호스트 + 키가 수락되면 libcurl이 연결을 계속합니다. 이것은 또한 이미 존재하지 않는 경우 메모리에 보관된 known_host 풀에 host+key 콤보를 추가합니다. CURLKHSTAT_REJECT - 호스트 + 키가 거부되었습니다. libcurl은 계속하기 위해 연결을 거부하고 닫힙니다. CURLKHSTAT_DEFER - 호스트 + 키가 거부되지만 SSH 연결은 활성 상태로 유지되도록 요청됩니다. 이 기능은 앱이 어떻게든 호스트+키 상황으로 돌아가서 조치를 취한 다음 처음부터 다시 설정하는 오버헤드 없이 재시도하려고 할 때 사용할 수 있습니다. RTSP interleaved dataCURLOPT_INTERLEAVEFUNCTION 옵션이 있는 콜백. 이 콜백은 RTSP 전송을 수행할 때 인터리브된 RTP 데이터를 수신하자마자 libcurl에 의해 호출됩니다. 각 $ 블록에 대해 호출되므로 정확히 하나의 상위 계층 프로토콜 단위(예: 하나의 RTP 패킷)를 포함합니다. libcurl은 인터리브 처리된 헤더와 각 호출에 대해 포함된 데이터를 씁니다. 첫 번째 바이트는 항상 ASCII 달러 기호입니다. 달러 기호 다음에 1바이트 채널 식별자가 오고 네트워크 바이트 순서로 2바이트 정수 길이가 옵니다. RTP 인터리빙의 작동 방식에 대한 자세한 내용은 RFC2326 섹션 10.12를 참조하세요. 설정하지 않거나 NULL로 설정하면 curl은 기본 쓰기 기능을 사용합니다. CURLOPT_INTERLEAVEDATA 포인터는 콜백의 userdata 인수로 전달됩니다. FTP 와일드 카드 일치libcurl은 FTP 와일드 카드 일치를 지원합니다. CURLOPT_WILDCARDMATCH를 1L로 설정한 다음 URL의 파일 이름 부분에 “와일드 카드 패턴”을 사용하여 이 기능을 사용합니다. 와일드 카드 패턴기본 libcurl 와일드 카드 일치 기능은 다음을 지원합니다. * - 별표 1ftp://example.com/some/path/*.txt some/path 디렉토리의 모든 txt 파일을 일치시키려면. 동일한 패턴 문자열 내에서는 두 개의 별표만 사용할 수 있습니다. ? - 물음표 물음표는 모든(정확히 하나의) 문자와 일치합니다. photo1.jpeg 및 photo7.jpeg라는 파일이 있는 경우 이 패턴은 다음과 일치할 수 있습니다. 1ftp://example.com/some/path/photo?.jpeg [ - BRACKET 표현왼쪽 대괄호는 대괄호 표현식을 엽니다. 대괄호 식에서 물음표와 별표는 특별한 의미가 없습니다. 각 대괄호 표현식은 오른쪽 대괄호(])로 끝나고 정확히 한 문자와 일치합니다. 몇 가지 예는 다음과 같습니다. [a-zA-Z0-9] 또는 [f-gF-G] - 문자 간격 [abc] - 문자 열거 [^abc] 또는 [!abc] - 부정 [[:name:]] 클래스 표현식입니다. 지원되는 클래스는 alnum, lower, space, alpha, digit, print, upper, blank, graph, xdigit입니다. [][-!^] - 특수 케이스, \\-, ], [, ! 또는 ^. [\\\\[\\\\]\\\\\\\\] - 이스케이프 구문. [, ] 또는 \\\\와 일치합니다. 위의 규칙을 사용하여 파일 이름 패턴을 구성할 수 있습니다. 1ftp://example.com/some/path/[a-z[:upper:]\\\\\\\\].jpeg FTP chunk 콜백FTP 와일드 카드 일치가 사용되면 일치하는 파일에 대한 전송이 시작되기 전에 CURLOPT_CHUNK_BGN_FUNCTION 콜백이 호출됩니다. 콜백은 다음 반환 코드 중 하나를 반환하도록 선택하여 libcurl에게 파일로 무엇을 할 것인지 알릴 수 있습니다. CURL_CHUNK_BGN_FUNC_OK 파일 전송 CURL_CHUNK_BGN_FUNC_SKIP CURL_CHUNK_BGN_FUNC_FAIL 오류로 인해 중지 일치하는 파일이 전송되거나 건너뛴 후 CURLOPT_CHUNK_END_FUNCTION 콜백이 호출됩니다. 끝 chunk 콜백은 성공 또는 오류만 반환할 수 있습니다. FTP 매칭 콜백기본 패턴 일치 기능이 마음에 들지 않으면 CURLOPT_FNMATCH_FUNCTION 옵션을 대체 기능으로 설정하여 고유한 대체 기능을 제공할 수 있습니다. Resolver 시작CURLOPT_RESOLVER_START_FUNCTION으로 설정된 이 콜백 함수는 새로운 확인 요청이 시작되기 전에 매번 libcurl에 의해 호출되며 어떤 CURL * 핸들이 확인 대상인지 지정합니다. 트레일러 보내기“Trailers”은 전송이 끝날 때 헤더를 전달할 수 있는 HTTP/1 기능입니다. 이 콜백은 업로드가 완료된 후 컬이 있는 트레일러를 보내고 싶을 때 사용됩니다. 청크 인코딩된 POST 형식의 업로드입니다. CURLOPT_TRAILERFUNCTION으로 설정된 콜백이 호출되고 함수는 목록에 헤더를 추가할 수 있습니다. 하나 또는 여러 개. 완료되면 libcurl은 이를 서버에 트레일러로 보냅니다. HSTSHSTS, HTTP Strict Transport Security의 경우 libcurl은 할당이 규칙에 대한 저장소를 구현할 수 있도록 두 개의 콜백을 제공합니다. 그런 다음 콜백은 영구 저장소에서 HSTS 정책을 읽고/쓰도록 설정됩니다. CURLOPT_HSTSREADFUNCTION을 사용하여 응용 프로그램은 libcurl에 있는 HSTS 데이터를 읽는 데 사용하는 기능을 제공합니다. CURLOPT_HSTSWRITEFUNCTION은 libcurl이 데이터를 쓰기 위해 호출하는 해당 함수입니다. Prereq여기서 “Prereq”는 요청이 발행되기 직전을 의미합니다. 바로 이 콜백이 호출되는 순간입니다. CURLOPT_PREREQFUNCTION으로 함수를 설정하면 호출되고 인수에 IP 주소와 포트 번호가 전달됩니다. 이를 통해 애플리케이션은 시작 직전에 전송에 대해 알 수 있으며 원할 경우 이 특정 전송을 취소할 수도 있습니다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl 연결 재사용","slug":"Linux-libcurl 연결 재사용","date":"2022-02-08T04:04:09.000Z","updated":"2022-02-09T03:59:14.298Z","comments":true,"path":"2022/02/08/Linux-libcurl 연결 재사용/","link":"","permalink":"http://jung-max.github.io/2022/02/08/Linux-libcurl 연결 재사용/","excerpt":"","text":"연결 재사용libcurl은 오래된 연결 풀을 활성 상태로 유지합니다. 하나의 전송이 완료되면 기존 연결 중 하나를 재사용할 수 있게 된 후속 전송이 새 연결을 만드는 대신 사용할 수 있도록 “연결 풀”(연결 캐시라고도 함)에서 N 연결을 활성 상태로 유지합니다. . 새 연결을 만드는 대신 연결을 재사용하면 속도와 필요한 리소스 면에서 상당한 이점을 얻을 수 있습니다. libcurl이 전송을 위해 새 연결을 만들려고 할 때 먼저 풀에 대신 재사용할 수 있는 기존 연결이 있는지 확인합니다. 연결 재사용 검사는 DNS 또는 기타 이름 확인 메커니즘이 사용되기 전에 수행되므로 순전히 호스트 이름을 기반으로 합니다. 올바른 호스트 이름에 대한 기존 라이브 연결이 있는 경우 다른 많은 속성(포트 번호, 프로토콜 등)도 사용할 수 있는지 확인합니다. 쉬운 API 풀easy API를 사용하거나 더 구체적으로 curl_easy_perform()을 사용하는 경우 libcurl은 특정 easy 핸들과 연결된 풀을 유지합니다. 그런 다음 동일한 쉬운 핸들을 재사용하면 연결을 재사용할 수 있습니다. 다중 API 풀다중 API를 사용하는 경우 연결 풀은 대신 다중 핸들과 연결된 상태로 유지됩니다. 이를 통해 연결 풀 손실 위험 없이 이지 핸들을 자유롭게 정리하고 다시 생성할 수 있으며, 하나의 이지 핸들에서 사용하는 연결을 나중에 전송할 때 별도의 핸들에서 재사용할 수 있습니다. 멀티 핸들을 재사용하십시오! “연결 캐시” 공유libcurl 7.57.0부터 애플리케이션은 공유 인터페이스를 사용하여 다른 방식으로 독립적인 전송이 동일한 연결 풀을 공유하도록 할 수 있습니다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"buildroot 환경에서 linux로 http통신 하기 (cURL사용)","slug":"Linux-http 통신(curl)","date":"2022-02-08T04:04:09.000Z","updated":"2022-02-08T04:31:04.897Z","comments":true,"path":"2022/02/08/Linux-http 통신(curl)/","link":"","permalink":"http://jung-max.github.io/2022/02/08/Linux-http 통신(curl)/","excerpt":"","text":"개요 클라이언트에서 커맨드 라인이나 소스코드로 손 쉽게 웹 브라우저 처럼 활동할 수 있도록 해주는 기술(커맨드라인 Tool 혹은 라이브러리) 서버와 통신할 수 있는 커맨드 명령어 툴이다. 웹개발에 매우 많이 사용되고 있는 무료 오픈소스이다 curl의 특징으로는 다음과 같은 수 많은 프로토콜을 지원한다는 장점이 있다. 다양한 지원 프로토콜들DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, Telnet, TFTP 또한 SSL 인증 방식 역시 가능하다. url을 가지고 할 수 있는 것들은 다할 수 있다. 예를 들면, http 프로토콜을 이용해 웹 페이지의 소스를 가져온다거나 파일을 다운받을 수 있다. ftp 프로토콜을 이용해서는 파일을 받을 수 있을 뿐 아니라 올릴 수도 있다. 심지어 SMTP 프로토콜을 이용하면 메일도 보낼 수 있다 예) 123$ curl -X GET http://127.0.0.1:3000/api/users/bakyeono$ curl -X POST http://127.0.0.1:3000/api/languages/ansi-common-lisp$ curl -X PUT http://127.0.0.1:3000/api/resources/1789 위 명령은 cURL을 이용해 각각 다음과 같은 요청을 보낸다. http://127.0.0.1:3000/api/users/bakyeono 리소스를 GET http://127.0.0.1:3000/api/languages/ansi-common-lisp 리소스를 POST http://127.0.0.1:3000/api/resources/1789 리소스를 PUT","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl 드라이브 전송","slug":"Linux-libcurl 드라이브 전송","date":"2022-02-08T04:04:09.000Z","updated":"2022-02-09T03:54:13.787Z","comments":true,"path":"2022/02/08/Linux-libcurl 드라이브 전송/","link":"","permalink":"http://jung-max.github.io/2022/02/08/Linux-libcurl 드라이브 전송/","excerpt":"","text":"드라이브 전송libcurl은 전송을 수행하는 세 가지 다른 방법을 제공합니다. 귀하의 경우에 어떤 방법을 사용할지는 전적으로 귀하와 귀하가 필요로 하는 것에 달려 있습니다. ‘쉬운’ 인터페이스를 사용하면 동기식으로 단일 전송을 수행할 수 있습니다. libcurl은 전체 전송을 수행하고 성공 여부와 상관없이 애플리케이션이 완료되면 제어를 다시 애플리케이션으로 반환합니다. ‘멀티’ 인터페이스는 동시에 둘 이상의 전송을 수행하거나 비차단 전송을 원할 때 사용합니다. ‘multi_socket’ 인터페이스는 일반 다중 인터페이스의 약간의 변형이지만 이벤트 기반이며 실제로 동시 전송 수를 수백 또는 수천 정도로 확장하려는 경우 사용하도록 제안되는 API입니다. easy drive‘easy’라는 이름은 libcurl을 사용하는 정말 쉬운 방법이기 때문에 선택되었으며, 물론 easy에는 몇 가지 제한 사항이 있습니다. 예를 들어, 한 번에 하나의 전송만 수행할 수 있고 단일 함수 호출에서 전체 전송을 수행하고 완료되면 반환합니다. 1res = curl_easy_perform( easy_handle ); 서버가 느리거나 전송이 크거나 네트워크에서 일부 불쾌한 시간 초과가 발생하거나 이와 유사한 경우 이 함수 호출에 시간이 오래 걸릴 수 있습니다. 물론 N초를 초과하지 않도록 타임아웃을 설정할 수 있지만 특정 조건에 따라 상당한 시간을 의미할 수도 있습니다. libcurl이 쉬운 인터페이스로 전송하는 동안 애플리케이션이 다른 작업을 수행하도록 하려면 여러 스레드를 사용해야 합니다. easy 인터페이스를 사용할 때 여러 개의 동시 전송을 수행하려면 각각의 전송을 자체 스레드에서 수행해야 합니다. Drive with multi‘multi’라는 이름은 다중 병렬 전송에서와 같이 모두 동일한 단일 스레드에서 수행되는 다중에 대한 것입니다. 다중 API는 차단되지 않으므로 단일 전송에도 사용할 수 있습니다.위에서 설명한 대로 전송은 여전히 “쉬운” CURL * 핸들로 설정되지만 다중 인터페이스를 사용하면 생성된 다중 CURLM * 핸들도 필요하며 이를 사용하여 모든 개별 전송을 구동해야 합니다. 다중 핸들은 하나 이상의 쉬운 핸들을 “잡을” 수 있습니다. 1CURLM *multi_handle = curl_multi_init(); 다중 핸들은 또한 curl_multi_setopt()로 수행하는 특정 옵션 세트를 얻을 수 있지만 가장 간단한 경우에는 거기에 설정할 것이 없을 수도 있습니다.다중 인터페이스 전송을 구동하려면 먼저 다중 핸들로 전송되어야 하는 모든 개별 간편 핸들을 추가해야 합니다. 언제라도 멀티 핸들에 추가할 수 있으며 원할 때마다 다시 제거할 수 있습니다. 다중 핸들에서 쉬운 핸들을 제거하면 물론 연결이 제거되고 특정 전송이 즉시 중지됩니다. 멀티 핸들에 easy 핸들을 추가하는 것은 쉽습니다. 1curl_multi_add_handle( multi_handle, easy_handle ); 하나를 제거하는 것도 간단합니다. 1curl_multi_remove_handle( multi_handle, easy_handle ); 수행하려는 전송을 나타내는 쉬운 핸들을 추가한 후 전송 루프를 작성합니다. 다중 인터페이스를 사용하면 루핑을 수행하여 libcurl에 파일 설명자 세트와 시간 초과 값을 요청하고 스스로 select() 호출을 수행하거나 curl_multi_wait를 사용하여 이를 수행하는 약간 단순화된 버전을 사용할 수 있습니다. 가장 간단한 루프는 다음과 같을 수 있습니다. (실제 응용 프로그램은 반환 코드를 확인합니다) 12345int transfers_running;do &#123; curl_multi_wait ( multi_handle, NULL, 0, 1000, NULL); curl_multi_perform ( multi_handle, &amp;transfers_running );&#125; while (transfers_running); 위의 예에서 1000으로 설정된 curl_multi_wait에 대한 네 번째 인수는 밀리초 단위의 시간 초과입니다. 어쨌든 반환되기 전에 함수가 활동을 기다리는 가장 긴 시간입니다. 시간 초과, 진행 콜백 등이 있으므로 curl_multi_perform을 다시 호출하기 전에 너무 오랫동안 잠그고 싶지 않습니다. 그렇게 하면 정밀도가 떨어질 수 있습니다. 대신 select()를 자체적으로 수행하기 위해 다음과 같이 libcurl에서 파일 설명자와 시간 초과 값을 추출합니다(실제 응용 프로그램은 반환 코드를 확인할 것입니다). 123456789101112131415161718192021222324252627282930313233int transfers_running;do &#123; fd_set fdread; fd_set fdwrite; fd_set fdexcep; int maxfd = -1; long timeout; /* extract timeout value */ curl_multi_timeout(multi_handle, &amp;timeout); if (timeout &lt; 0) timeout = 1000; /* convert to struct usable by select */ timeout.tv_sec = timeout / 1000; timeout.tv_usec = (timeout % 1000) * 1000; FD_ZERO(&amp;fdread); FD_ZERO(&amp;fdwrite); FD_ZERO(&amp;fdexcep); /* get file descriptors from the transfers */ mc = curl_multi_fdset(multi_handle, &amp;fdread, &amp;fdwrite, &amp;fdexcep, &amp;maxfd); if (maxfd == -1) &#123; SHORT_SLEEP; &#125; else select(maxfd+1, &amp;fdread, &amp;fdwrite, &amp;fdexcep, &amp;timeout); /* timeout or readable/writable sockets */ curl_multi_perform(multi_handle, &amp;transfers_running);&#125; while ( transfers_running ); 이 두 루프 모두 자신의 소켓이나 파이프 등에서 읽는 경우와 같이 대기할 파일 설명자를 하나 이상 사용할 수 있습니다. 또한 루핑 중 언제라도 멀티 핸들에 쉬운 핸들을 추가하거나 제거할 수 있습니다. 물론 전송 도중 핸들을 제거하면 해당 전송이 중단됩니다. 단일 전송은 언제 완료됩니까?위의 예에서 볼 수 있듯이 프로그램은 transfers_running 변수가 감소하는 것을 확인하여 개별 전송이 완료되는 시점을 감지할 수 있습니다. 또한 curl_multi_info_read()를 호출하여 전송이 종료된 경우 구조체에 대한 포인터(“메시지”)를 반환하고 해당 구조체를 사용하여 해당 전송의 결과를 찾을 수 있습니다. 여러 병렬 전송을 수행하는 경우 동일한 curl_multi_perform 호출에서 둘 이상의 전송이 완료될 수 있으며 완료된 각 전송에 대한 정보를 얻기 위해 curl_multi_info_read에 대한 호출이 둘 이상 필요할 수 있습니다. Drive with multi_socket“multi_socket” 인터페이스로 구동multi_socket은 일반 다중 인터페이스의 추가 매운 버전이며 이벤트 기반 응용 프로그램을 위해 설계되었습니다. multi_socket은 모두 동일한 단일 스레드에서 수행되는 다중 병렬 전송을 지원하며 단일 애플리케이션에서 수만 건의 전송을 실행하는 데 사용되었습니다. 일반적으로 많은 수(&gt;100 정도) 병렬 전송을 수행하는 경우 가장 적합한 API입니다. 이 경우 이벤트 구동은 응용 프로그램이 여러 소켓에 “구독”하는 시스템 수준 라이브러리 또는 설정을 사용하고 해당 소켓 중 하나를 읽거나 쓸 수 있을 때 응용 프로그램에 알려주고 정확히 어느 소켓을 알려줍니다. 이 설정을 통해 클라이언트는 다른 시스템보다 훨씬 더 많은 동시 전송 수를 확장하면서도 여전히 우수한 성능을 유지할 수 있습니다. 그렇지 않으면 “일반” API는 모든 소켓 목록을 스캔하는 데 너무 많은 시간을 낭비합니다. 하나를 선택선택할 수 있는 이벤트 기반 시스템이 많이 있으며 libcurl은 사용자가 사용하는 시스템에 대해 완전히 불가지론적입니다. libevent, libev 및 libuv는 널리 사용되는 세 가지이지만 epoll, kqueue, /dev/poll, pollset 또는 Event Completion과 같은 운영 체제의 기본 솔루션으로 직접 이동할 수도 있습니다. 많은 쉬운 핸들일반 다중 인터페이스와 마찬가지로 curl_multi_add_handle()을 사용하여 다중 핸들에 쉬운 핸들을 추가합니다. 수행하려는 각 전송에 대한 하나의 쉬운 핸들. 전송이 실행되는 동안 언제든지 추가할 수 있으며 curl_multi_remove_handle 호출을 사용하여 언제든지 간편 핸들을 유사하게 제거할 수도 있습니다. 그러나 일반적으로 전송이 완료된 후에만 핸들을 제거합니다. multi_socket 콜백위에서 설명했듯이 이 이벤트 기반 메커니즘은 libcurl이 어떤 소켓을 사용하고 libcurl이 해당 소켓에서 무엇을 기다리는지를 애플리케이션에 의존합니다. 소켓이 읽기, 쓰기 또는 둘 다 되기를 기다리는 경우! 또한 libcurl이 스스로 할 수 없는 모든 것을 제어하기 때문에 타임아웃 시간이 만료되면 libcurl에 알려야 합니다. 따라서 libcurl은 업데이트된 시간 초과 값도 응용 프로그램에 알려야 합니다. 소켓_콜백libcurl은 CURLMOPT_SOCKETFUNCTION이라는 콜백으로 대기할 소켓 활동에 대해 애플리케이션에 알립니다. 애플리케이션은 다음과 같은 기능을 구현해야 합니다. 1234567891011int socket_callback(CURL *easy, /* easy handle */ curl_socket_t s, /* socket */ int what, /* what to wait for */ void *userp, /* private callback pointer */ void *socketp) /* private socket pointer */&#123; /* told about the socket 's' */&#125;/* set the callback in the multi handle */curl_multi_setopt(multi_handle, CURLMOPT_SOCKETFUNCTION, socket_callback); 이것을 사용하여 libcurl은 애플리케이션이 모니터링해야 하는 소켓을 설정 및 제거합니다. 애플리케이션은 기본 이벤트 기반 시스템에 소켓을 기다리도록 지시합니다. 이 콜백은 대기할 소켓이 여러 개 있는 경우 여러 번 호출되며 상태가 변경되면 다시 호출되며 쓰기 가능한 소켓을 기다리는 대신 읽을 수 있게 될 때까지 기다리는 것으로 전환해야 합니다. 응용 프로그램이 libcurl을 대신하여 모니터링하는 소켓 중 하나가 요청에 따라 읽기 또는 쓰기가 가능해진다고 등록하면 curl_multi_socket_action()을 호출하고 영향을 받는 소켓과 어떤 소켓 활동이 있었는지 지정하는 관련 비트마스크를 전달하여 libcurl에 알려줍니다. 12345int running_handles;ret = curl_multi_socket_action(multi_handle, sockfd, /* the socket with activity */ ev_bitmask, /* the specific activity */ &amp;running_handles); 타이머_콜백응용 프로그램이 제어되고 소켓 활동을 기다립니다. 그러나 소켓 활동이 없더라도 libcurl이 해야 할 일이 있습니다. 시간 초과 문제, 진행 콜백 호출, 재시도를 다시 시작하거나 너무 오래 걸리는 전송 실패 등. 이 작업을 수행하려면 응용 프로그램은 libcurl이 설정하는 단일 샷 시간 초과도 처리해야 합니다. libcurl은 timer_callback으로 시간 초과를 설정합니다. CURLMOPT_TIMERFUNCTION 123456789int timer_callback(multi_handle, /* multi handle */ timeout_ms, /* milliseconds to wait */ userp) /* private callback pointer */&#123; /* the new time-out value to wait for is in 'timeout_ms' */&#125;/* set the callback in the multi handle */curl_multi_setopt(multi_handle, CURLMOPT_TIMERFUNCTION, timer_callback); 추가된 개별 easy 핸들 또는 진행 중인 전송의 수와 상관없이 전체 다중 핸들에 대해 애플리케이션이 처리하는 시간 초과는 한 번뿐입니다. 타이머 콜백은 현재 가장 가까운 대기 시간으로 업데이트됩니다. 소켓 활동으로 인해 시간 초과 만료 시간 전에 libcurl이 호출되면 만료되기 전에 시간 초과 값을 다시 업데이트할 수 있습니다. 선택한 이벤트 시스템이 결국 타이머가 만료되었다고 알려줄 때 libcurl에 이에 대해 알려야 합니다. 1curl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, 0, &amp;running); … 많은 경우에 이것은 libcurl이 timer_callback을 다시 호출하고 다음 만료 기간에 대한 새로운 시간 초과를 설정하게 합니다. 모든 것을 시작하는 방법다중 핸들에 하나 이상의 쉬운 핸들을 추가하고 다중 핸들에서 소켓 및 타이머 콜백을 설정하면 전송을 시작할 준비가 된 것입니다. 모든 것을 시작하기 위해 libcurl에게 시간 초과(모든 쉬운 핸들이 짧은 시간 초과로 시작하기 때문에)에 알리면 libcurl이 콜백을 호출하여 설정한 다음 이벤트 시스템이 구동되도록 할 수 있습니다. 12345678910/* all easy handles and callbacks are setup */curl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, 0, &amp;running);/* now the callbacks should have been called and we have sockets to wait for and possibly a timeout, too. Make the event system do its magic */event_base_dispatch(event_base); /* libevent2 has this API *//* at this point we have exited the event loop */ 언제 완료되나요?curl_multi_socket_action이 반환한 ‘running_handles’ 카운터는 완료되지 않은 현재 전송 수를 보유합니다. 해당 숫자가 0에 도달하면 진행 중인 전송이 없음을 알 수 있습니다. ‘running_handles’ 카운터가 변경될 때마다 curl_multi_info_read()는 완료된 특정 전송에 대한 정보를 반환합니다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl Easy handle","slug":"Linux-libcurl Easy handle","date":"2022-02-08T04:04:09.000Z","updated":"2022-02-09T03:59:17.256Z","comments":true,"path":"2022/02/08/Linux-libcurl Easy handle/","link":"","permalink":"http://jung-max.github.io/2022/02/08/Linux-libcurl Easy handle/","excerpt":"","text":"Easy handle먼저 전송에 대한 핸들인 “이지 핸들”을 생성합니다. 1CURL *easy_handle = curl_easy_init(); 그런 다음 해당 핸들에서 옵션을 설정하여 예정된 전송을 제어합니다. 이 예에서는 URL을 설정합니다. 12/* set URL to operate on */res = curl_easy_setopt(easy_handle, CURLOPT_URL, \"http://example.com/\"); curl_easy_setopt()가 CURLE_OK를 반환하면 옵션이 제대로 저장되었음을 알 수 있습니다. 쉬운 핸들을 만들고 옵션을 설정해도 전송이 발생하지 않으며 일반적으로 전송이 실제로 발생했을 때 나중에 사용하고자 하는 libcurl을 저장하는 것 외에는 더 많은 일이 발생하지 않습니다. 입력의 많은 구문 검사 및 유효성 검사도 연기될 수 있으므로 curl_easy_setopt가 불평하지 않았다고 해서 입력이 정확하고 유효하다는 의미는 아닙니다. 나중에 오류가 반환될 수 있습니다. 별도 섹션에서 쉬운 옵션에 대해 자세히 읽어보세요. 쉬운 핸들로 옵션 설정을 마치면 실제 전송을 시작할 수 있습니다. 전송의 실제 수행은 애플리케이션에서 원하는 동작의 종류와 libcurl이 아키텍처에 가장 잘 통합되는 방식에 따라 다양한 메서드와 함수 호출을 사용하여 수행할 수 있습니다. 이에 대해서는 이 장의 뒷부분에서 자세히 설명합니다. 전송이 진행되는 동안 libcurl은 콜백이라고 하는 지정된 함수를 호출하여 데이터를 전달하고 데이터를 읽고 다양한 작업을 수행합니다. 전송이 완료된 후 성공 여부를 알 수 있으며 libcurl이 전송 중에 수집한 통계 및 기타 정보를 easy 핸들에서 추출할 수 있습니다. 전송 후 정보를 참조하십시오. 재사용!쉬운 핸들은 재사용할 수 있도록 설계되었습니다. 이지핸들로 한번의 이체를 마치면 바로 다음 이체에 다시 사용할 수 있습니다. 이를 통해 얻을 수 있는 이득이 많다. 모든 옵션은 “고정”입니다. 다시 변경하거나 핸들에서 curl_easy_reset()을 호출할 때까지 핸들에 설정된 상태로 유지됩니다. 동일한 핸들로 두 번째 전송을 수행하면 동일한 옵션이 사용됩니다.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"libcurl","slug":"Linux-libcurl","date":"2022-02-08T04:04:09.000Z","updated":"2022-02-09T08:53:00.769Z","comments":true,"path":"2022/02/08/Linux-libcurl/","link":"","permalink":"http://jung-max.github.io/2022/02/08/Linux-libcurl/","excerpt":"","text":"libcurllibcurl은 C로 작성된 응용 프로그램을 위해 C API와 함께 제공되는 함수 라이브러리입니다. 몇 가지 고려 사항만 있으면 C++에서도 쉽게 사용할 수 있습니다(C++ 프로그래머용 libcurl 참조. 다른 언어의 경우 “바인딩”이 있습니다. libcurl 라이브러리와 원하는 특정 언어에 대한 해당 기능 사이의 중간 계층으로 작동합니다. 아래는 https://everything.curl.dev/libcurl의 해석본입니다. Easy handle 드라이브 전송 연결 재사용 callback Cleanup 이름 확인 Proxies Post transfer info 핸들 간에 데이터 공유 URL API API 호환성 –libcurl Header files 전역 초기화 multi-threading curl easy options CURL코드 리턴 코드 자세한 작업 example for C++ programmers","categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"}]},{"title":"Android OTA Update","slug":"Android-OTA Update","date":"2022-01-11T00:23:41.000Z","updated":"2022-02-08T02:11:11.770Z","comments":true,"path":"2022/01/11/Android-OTA Update/","link":"","permalink":"http://jung-max.github.io/2022/01/11/Android-OTA Update/","excerpt":"","text":"안드로이드 업데이트 (OTA Updates)안드로이드 디바이스는 시스템, 어플리케이션, 타임존 룰을 over-the-air(OTA) update로 받고 설치할 수 있다. 이 섹션은 Update Package의 구조를 설명하고 Update Package를 빌드하기 위한 도구에 대해서 설명한다. OTA Update은 OS를 업그레이드하고, 시스템 파티션에 설치된 ReadOnly 앱을 업그레이드하고, 타임존 룰을 업그레이드하도록 디자인되어 있다. 이 업데이트는 사용자에 의해 설치된 어플리케이션에는 영향을 미치지 않는다. OTA Package Toolsbuild/tools/releasetools 위치에 제공되는 ota_from_target_files 도구는 full 과 incremental(증분)의 두 가지 종류의 패키지를 빌드할 수 있다. 이 도구는 안드로이드 빌드 시스템에서 만들어진 target_files.zip 파일을 입력으로 받는다. Full UpdatesFull Update는 패키지 안에 디바이스의 최종 상태 전체(system, boot, recovery 파티션)를 포함하고 있다. 디바이스가 패키지를 받고 리커버리 시스템으로 부팅할 수 있는 한, 디바이스의 현재 상태에 상관없이 패키지를 설치할 수 있다. 예시 &gt; 가상의 tardis 디바이스를 위한 Full Update를 빌드하기 위한 릴리즈 툴의 사용 1234# first, build the target-files.zip$ . build/envsetup.sh &amp;&amp; lunch tardis-eng$ mkdir dist_output$ make dist DIST_DIR=dist_output target-files.zip은 OTP 패키지를 구성하기 위한 모든 것을 포함하고 있다. 1$ ./build/tools/releasetools/ota_from_target_files dist_output/tardis-target_files.zip ota_update.zip 위와 같이 하면 테스트 디바이스를 위한 ota_update.zip이 준비된다. 사용자 디바이스를 위해서는 Signing builds for release에 설명된 대로 별도의 개인 키를 생성해야 한다. Incremental Updates (증분 업데이트)증분 업데이트는 디바이스에 이미 있는 데이타에 대한 바이너리 패치의 집합으로 구성되어 있다. 이는 상당히 작은 양의 업데이트 패키지를 만들어낸다.*. 변경대상이 아닌 파일은 포함되지 않는다.*. 자주 변경되는 파일은 보통 이전 버전과 아주 비슷해서 패키지는 두 파일의 차이만을 포함한다.증분 업데이트는 디바이스에 설치되어 있는 이전의 패키지를 가지고 있거나 이전의 패키지를 다시 빌드 할 수 있는 소스가 있는 경우에만 사용할 수 있다. 증분 업데이트를 만들기 위해서는 새 빌드의 target_files.zip 뿐만 아니라 이전 빌드의 target_files.zip 가 필요하다. 1$ ./build/tools/releasetools/ota_from_target_files -i PREVIOUS-tardis-target_files.zip dist_output/tardis-target_files.zip incremental_ota_update.zip # make incremental from the older version 새 빌드는 이전 빌드와 비슷하기 때문에 증분 업데이트 패키지는 Full Update 에 비해서 상당히 작다. 증분 빌드는 증분 빌드를 만들기 위해 사용된 이전 빌드와 정확히 일치하는 빌드를 사용하는 디바이스에만 배포되어야 한다. 다른 빌드를 사용하고 있는 디바이스에 증분 업데이트를 사용할 경우에는 복구 에러 아이콘을 보여준다. 이 시점에 디바이스를 재부팅하면 옛날 시스템으로 부팅할 것이다. Update Packages업데이트 패키지(ota_update.zip, incremental_ota_update.zip)은 META-INF/com/google/android/update-binary를 포함하고 있는 zip 파일이다. 패키지의 서명을 검증한 이후에는 리커버리는 이 바이너리를 /tmp에 압축해제하고 다음의 인자를 넘긴다. Update binary API version number. update binary에 넘기는 인자가 변경되면 이 숫자는 증가한다. File descriptor of the command pipe. update 프로그램은 pipe를 통해 리커버리 바이너리에 명령을 되돌려 보낼 수 있다. (대부분의 경우 진행상황을 사용자에게 표시하기 위핸 UI 변경), *Filename of the update package.zip file. 리커버리 패키지는 update binary에 정적으로 링크된 바이너리를 사용할 수 있다. OTA 패키지 구성 도구는 updater 프로그램을 사용한다.( bootable/recovery/updater 에 소스가 있다.) updater 프로그램은 간단한 스크립팅 언어를 제공하여 여러 설치 작업을 할 수 있게 한다. updater binary와 edify 문법, 내장 함수에 대해서는 Inside OTA Packages를 참조하라. Signing Builds for Release안드로이드 OS는 두 곳에서 암호화 서명을 사용한다. 이미지의 각 .apk 파일은 서명되어야 한다. 안드로이드의 Package Manager는 .apk 서명을 두 가지고 사용한다. 어플리케이션이 교체될 때, 이전 어플리케이션 data에 접근하기 위하여 이전 어플리케이션과 동일한 키로 서명되어야 한다. 이는 사용자 앱에서나 시스템 앱에서나 동일하게 적용된다. 둘 이상의 어플리케이션이 동일한 user ID를 공유하려고 할 경우에는, 동일한 키로 서명되어야 한다. OTA update 패키지는 system에 의해 기대되어지는 키 중 하나로 서명되어야 한다. 그렇지 않으면 설치 프로젝트가 설치를 거부할 것이다. Release Keys안드로이드는 build/target/product/security 디렉토리 안에 test-keys를 가지고 있다. make를 사용하여 안드로이드 OS 이미지를 만들때 모든 .apk 파일은 test-keys를 이용하여 서명된다. test-keys가 알려져 있기 때문에 누구나 자신의 .apk를 같은 키로 서명할 수 있다. 이는 다른사람이 이 서명을 이용하여 OS Image의 시스템 앱을 교체하거나 시스템앱을 하이재킹할 수 있게 한다. 이런 이유로 공개적으로 접근할 수 없는 release-keys를 사용하여 안드로이드 OS 이미지에 서명하는 것은 중요하다. 자신의 유일한 release-keys를 생성하기 위해서는 안드로이드 트리의 최상단 디렉토리에서 다음을 실행하라. 12345$ subject=&apos;/C=US/ST=California/L=Mountain View/O=Android/OU=Android/CN=Android/emailAddress=android@android.com&apos;$ mkdir ~/.android-certs$ for x in releasekey platform shared media; do \\ ./development/tools/make_key ~/.android-certs/$x &quot;$subject&quot;; \\ done $subject는 기관의 정보를 반영하도록 수정되어야 한다. 어떤 디렉토리라도 사용할 수 있지만 백업이 되고 안전한 장소를 사용하도록 주의를 기울여야 한다. 몇몇의 vendor들은 강력한 비밀구문을 이용하여 private-key를 압호화하고 암호화된 키를 source control에 저장한다. 다른 vendor들은 release key를 완전히 다른 곳에 보관한다. 릴리즈 이미지를 만들기 위해서 다음을 사용하라 12345$ make dist$ ./build/tools/releasetools/sign_target_files_apks \\ -o \\ # explained in the next section -d ~/.android-certs out/dist/*-target_files-*.zip \\ signed-target_files.zip sign_target_files_apks 스크립트는 target-files.zip을 입력으로 받고 그 안의 모든 apk를 새로운 키로 서명한다. 새로 서명된 이미지는 /IMAGE/안에 signed-target_files.zip에서 찾을 수 있다. Signing OTA Packages서명된 target-files zip은 다음의 명령으로 서명된 OTA update zip 파일료 변환할 수 있다. 1234$ ./build/tools/releasetools/ota_from_target_files \\ -k ~/.android-certs/releasekey \\ signed-target_files.zip \\ signed-ota_update.zip Signatures and sideloadingSideloading은 리커버리의 일반 패키지 서명 확인 메카니즘을 건너뛰지 않는다. 일반 OTA 패키지에 대해서와 같이 패키지를 설치하기 전에 리커버리는 리커버리 파티션에 저장되어있는 공개 키에 맞는 private key로 서명되어 있는지 확인한다. 메인 시스템에서 받은 업데이트 패키지는 전형적으로 두번 검증된다. 한번은 안드로이드 API의 RecoverySystem.verifyPackage() 메소드를 사용하는 메인 시스템에서 검증하고, 리커버리에서 다시 한번 검증된다. RecoverySystem API는 메인시스템에 저장된 공개 키(디폴트는 /system/etc/security/otacerts.zip)에 대해서 서명을 체크한다. 리커버리 시스템은 리커버리 파티션의 RAM disk에 저장된 공개키(/res/keys)에 대해서 서명을 체크한다. 디폴트로 build로 만들어지는 target-files.zip는 OTA 인증서가 test key에 맞도록 설정한다. 릴리즈 이미지에서는 디바이스가 업데이트 패키지의 인증을 검증할 수 있도록 다른 인증서가 사용되어야 한다. sign_target_files_apks에 -o 플래그를 넘김으로써 cert 디렉토리의 test key certificate 을 release key certificate으로 교체할 수 있다. 일반적으로 시스템 이미지와 복구 이미지는 같은 OTA public key 셋을 저장한다. 복구 시스템에만 key를 추가함으로써 sideloading을 통해서 설치할 수 있게 서명하는 것이 가능하다.(메인 시스템 업데이트 다운로드 메카니즘은 ocacert.zip을 통해 검증을 올바르게 수행한다.) PRODUCT_EXTRA_RECOVERY_KEYS변수를 설정함으로써 추가의 키를 리커버리에 포함하도록 할 수 있다. 1vendor/yoyodyne/tardis/products/tardis.mk 123[...]PRODUCT_EXTRA_RECOVERY_KEYS := vendor/yoyodyne/security/tardis/sideload 이것은 vendor/yoyodyne/security/tardis/sideload.x509.pem 공개키를 리커버리 키 파일에 포함하도록 한다. 인스톨 패키지는 이 키로 서명할 수 있다. 이 추가의 키는 otacerts.zip에는 포함되지 않는다. 그러므로 시스템은 다운로드된 패키지를 올바르게 검증할 수 있다. Certificates and private keys각각의 키는 두 개의 파일로 구성된다. .x509.pem 의 확장자를 가지는 certificate과 pk8확장자를 가지는 private key가 그것이다. private key는 패키지에 서명할 때 필요하며 비밀로 안전하게 보관되어야 한다. 키는 패스워드로 보호될 수 있다. certificate은 키의 공개된 반만을 포함하고 있고 공개되어 넓게 배포된다. certificate은 private key로 서명이 되었는지 검증하기 위해 사용한다. 표준 안드로이드 빌드는 4가지 key를 사용한다. 모든 키는 build/target/product/security에 위치한다. testkey 키를 지정하지 않았을 때 사용되는 일반 디폴트 키이다. platform core platform의 부분의 패키지들에 사용되는 test key이다. shared home/contects 과정에 공유되는 것들에 대한 test key이다. media media/download 시스템의 일부의 패키지에 사용되는 test key이다. 각각의 패키지는 Android.mk의 LOCAL_CERTIFICATE에 이중 하나를 지정한다. (이 값이 지정되지 않으면 testkey가 사용된다.) pathname을 사용하여 완전히 다른 키를 지정할 수도 있다. 1device/yoyodyne/apps/SpecialApp/Android.mk 123 [...]LOCAL_CERTIFICATE := device/yoyodyne/security/special 위와 같이 하면 device/yoyodyne/security/special.{x509.pem, pk8}키가 SpecialApp.apk를 서명하는 데 사용된다. 빌드는 password로 보호되지 않는 private key만을 사용할 수 있다. Advanced signing optionsManually generating keysCreating image filesReducing OTA SizeA/B (Seamless) system updates근대의 안드로이드 디바이스는 각 파티션(A, B)의 두 개의 복사본을 가지고 있어서 Update를 현재 사용하지 않는 파티션에 적용할 수 있다. A/B 디바이스는 네트워크에서 수신하면서 바로 업데이트를 적용하기 때문에 패키지를 다운로드해서 저장하기 위한 별도의 공간이 필요하지 않다. 이런것을 Streaming A/B 라고 알려져 있다. A/B 디바이스의 OTA update에 대한 추가의 정보는 A/B(Seamless) System Updates를 참조하라. A/B (Seamless) System UpdatesA/B System Update는 seamless updates로 알려져 있는데, OTA Update중에 동작가능한 부팅 시스템이 남아있는 것을 보장한다. 이 접근은 업데이트 후에 디바이스가 사용 불가능하게 될 가능성을 줄인다.(즉, 보증 센터에서 디바이스 교환이나 디바이스 리플래싱을 하는 것을 줄인다.) Chrome과 같은 다른 상용 레벨 OS도 A/B Update을 성공적으로 사용하고 있다. A/B System Update이 어떻게 동작하는지에 대해서는 [Partition selection(slots)]를 보라. A/B System Update는 다음의 이익을 제공한다. OTA Update가 시스템이 동작하는 동안에 사용자의 동작을 방해하는 것 없이 수행될 수 있다. 사용자는 OTA Update중에 디바이스를 사용하는 것을 계속 할 수 있다. 유일한 사용하지 못하는 시간은 디바이스가 리부팅하는 동안뿐이다. Update 후의 리부팅은 일반적인 상황에서의 리부팅보다 오래 걸리지 않는다. OTA 적용이 실패했을 경우에도 사용자는 영향을 받지 않는다. 사용자는 옛날 OS를 가지고 계속 동작할 수 있으며, 다시 업데이트를 재시도 할 수 있다. 만약 OTA update를 적용했는데 부팅이 실패한다면 디바이스는 옛날 파티션으로 재부팅하게 된다. 사용자는 나중에 업데이트를 재시도할 수 있다. 어떤 에러도 사용하지 않고 있는 파티션에만 적용되기 때문에 나중에 재시도할 수 있다. 이런 에러는 가능성이 낮은데, 사용자의 사용성을 낮추는 것을 막기 위해 I/O 부하가 아주 적기 때문이다. Update는 A/B 디바이스에 스트리밍 될 수 있다. 업데이트를 다운로드하고 인스톨 할 필요가 없다. 스트리밍은 /data나 /cache 디렉토리에 업데이트 패키지를 저장하기 위해 충분한 공간을 가질 필요가 없게 한다. cache 파티션은 OTA update 패키지를 저장하는데 더이상 사용되지 않는다. 그러므로 cache 파티션이 업데이트를 위해 클 필요가 없다. dm-verify는 손상되지 않은 이미지를 부팅하는 것을 보장한다. 만약 디바이스가 잘못된 OTA나 dm-verify문제로 부팅하지 않는다면 디바이스는 이전의 이미지로 리부팅할 수 있다. (안드로이드 Verified Boot은 A/B Update를 필요로하지 않는다.) About A/B system updatesPartition selection (slots)Update engine daemonBootloader interactionsStreaming update supportLife of an A/B updatePost-installationAfter reboot Implementing A/B Updates Frequently Asked Questions Non-A/B system updates옛날의 안드로이드 디바이스는 업데이트 패키지의 압축을 풀고 Update를 다른 파티션에 적용하기 위한 소프트웨어를 포함하는 전용의 리커버리 피티션을 가지고 있다. 더 많은 정보를 위해서는 Non-A/B System Updates를 참조하라. Non-A/B System UpdatesA/B 파티션이 없는 예전의 안드로이드 디바이스의 경우에 플래시 공간은 다음의 파티션들을 포함한다.: boot : 리눅스 커널과 작은 root 파일시스템을 포함하고 있다. (RAM Disk에 로드된다.) System과 다른 파티션들을 마운트하고 system 파티션에 위치한 runtime을 개시한다. system : AOSP에서 이용가능한 소스코드로 생성되는 System Application과 라이브러리를 포함한다. 일반적인 동작에서 이 파티션은 read-only로 마운트되고 OTA update동안에만 이 파티션의 내용이 바뀐다. vendor : AOSP에 포함되지 않은 소스코드로 생성되는 System Application과 라이브러리를 포함한다. 일반적인 동작에서 이 파티션은 read-only로 마운트되고 OTA update동안에만 이 파티션의 내용이 바뀐다. userdata : 사용자가 설치한 application에 의해 저장되는 데이터를 보존한다. 일반적으로 이 파티션은 OTA update에 의해 변경되지 않는다. cache : 일부 Application에 의해 사용되는 임시 영역이다.(이 영역을 접근하려면 특별한 app 퍼미션이 필요하다.) 이 영역은 OTA update 패키지를 다운로드하는 공간으로 사용된다. 다른 프로그램은 언제든 이 영역에 있는 파일들이 사라질 수 있다는 것을 가정한다. 몇몇의 OTA 패키지의 설치는 이 파티션을 완전히 지우는 결과가 될 수 있다. 이 파티션은 OTA update의 log를 포함한다. recovery : 두번째의 완전한 리눅스 시스템을 포함하고 있다. 커널과 다른 파티션을 update하는 데 사용하는 특별한 복구용의 바이너리들을 포함하고 있다. misc : OTA 패키지가 적용되는 동안 재시작할 때 어떤 작업을 하는 중인지에 대한 정보를 저장하기 위해 리커버리에서 사용되는 작은 파티션이다. OTA Update의 생명주기(순서)전형적인 OTA update는 다음의 과정을 포함한다. 디바이스는 OTA 서버를 주기적으로 체크하고 업데이트(OTA 서버로부터 업데이트 패키지의 URL과 사용자에게 보여줄 설명 등을 포함하여)가 사용가능한지 확인한다. cache나 data 파티션에 업데이트를 다운로드하고 암호화 서명을 /system/etc/security/otacert.zip에 대해서 검증한다. 사용자에게 업데이트를 설치하는 것을 알린다. 디바이스는 리커버리 모드로 리부팅한다. 리커버리 모드로 리부팅하면 boot 파티션에 있는 커널 대신에 recovery 파티션에 있는 커널과 시스템으로 부팅되게 된다. 리커버리 바이너리가 실행되면 /cache/recovery/command의 명령줄 인자를 찾는다. /cache/recovery/command에는 다운로드된 패키지의 경로가 포함되어 있다. 리커버리는 /res/keys의 공통키에 대해서 패키지의 암호화 서명을 검증한다. (res/keys는 recovery파티션에 포함되어있는 RAM disk의 일부이다.) 패키지에서 데이타를 추출하여 필요에 따라 boot, system, vendor 파티션을 업데이트한다. system 파티션에서는 새로운 recovery 파티션을 파일로 포함하고 있다. 일반 모드로 디바이스가 리부팅한다. 새로 업데이트된 boot 파이션이 로딩된다. 새롭게 업데이트된 system 파티션을 마운트하고 system 파티션의 바이너리를 실행한다. 일반적인 시작 과정의 일부로, 시스템은 recovery 파티션의 내용이 system 파티션에 파일로 저장되어 있는 recovery파티션과 같은지 확인한다. 만약 다르다면 recovery 파티션은 system 파티션에 있는 내용으로 다시 쓰여진다. (다음번의 부팅에서는 recovery파티션은 system 파티션에 있는 내용과 동일하므로 다시쓰기 작업은 필요없어진다.) 시스템 업데이트 과정이 완료되면 Update로그는 /cache/recovery/last_log 에서 찾을 수 있다. Migratiing from previous releases안드로이드 2.3/3.0/4.0에서 이전할 때, 주요 변경은 디바이스 특정적인 C 함수의 집합이 미리 정의된 C++ 객체로 변경된 것이다. 다음 테이블은 거의 동일한 목적의 옛날 함수와 새로운 함수를 열거한다. C function C++ method device_recovery_start() Device::RecoveryStart() device_toggle_display(), device_reboot_now() RecoveryUI::CheckKey()(also RecoveryUI::IsKeyPressed()) device_handle_key() Device::HandleMenuKey() device_perform_action() Device::InvokeMenuItem() device_wipe_data() Device::WipeData() device_ui_init() ScreenRecoveryUI::Init() 옛날 함수에서 새 메소드로의 변환은 상당히 직관적이다. 그리고 개발자의 디바이스에 대한 Device class의 서브클래스 객체를 리턴하는 함수 make_device()를 구현해야 한다. Block-Based OTAs안드로이드 5.0이상의 디바이스에서부터 Block 기반 OTA를 활성화 할 수 있다. OTA는 OEM이 디바이스의 system 파티션을 원격으로 업데이트하는 메카니즘이다. Android 5.0과 이후의 버전은 각 디바이스가 정확히 동일한 파티션을 사용하는지 보장하기 위해 block OTA 업데이트를 사용한다. 각각의 파일을 비교하고 바이너리 패치를 만드는 대신에, block OTA는 결과 파티션이 정확히 의도된 bit을 포함하는 것을 보장하기 위해 전체 파티션을 하나의 파일로 다루고 하나의 바이너리 패치를 계산한다. 이것은 fastboot나 OTA를 통해 디바이스 시스템 이미지가 동일 상태가 되게 한다. *Android 4.0과 이전버전은 file OTA 업데이트를 사용한다. 이 방법은 각 디바이스가 동일한 파일과 퍼미션, 모드를 가지도록 보장하지만 업데이트 방법에 따라 metadata가 달라질 수 있다. block OTA는 각 디바이스가 동일한 파티션을 가지게 되는 것을 보장하기 때문에, dm-verify을 사용하여 system 파티션에 서명하는 것을 가능하게 한다. dm-verify에 대한 것은 Verified Boot을 참조하라. Recommendations안드로이드 5.0과 이후 버전에 대하여 factory ROM에 block OTA update를 사용하라. 이어지는 업데이트를 위한 block 기반의 OTA를 생성하기 위해서는 ota_from_target_files에 –block 옵션을 넘겨줘야 한다. 안드로이드 4.0과 이전 버전에 대해서 file OTA update를 사용하라. Android 5.0과 이후버전의 전체 block OTA를 전송하는 것이 가능하지만 full OTA는 증분 OTA를 보내는 것보다 상당히 큰 사이즈이다. dm-verify는 안드로이드 5.0과 이후버전에서 나타나는 bootloader의 지원이 필요하기 때문에 기존에 존재하는 디바이스에 대해서는 dm-verify를 활성화 할 수 없다. 안드로이드 OTA 시스템(recovery 이미지와 OTA를 생성하는 스크립트)에서 작업하는 개발자는 android-ota@googlegroups.com 메일링 리스트를 구독함으로써 변경 내용을 추적할 수 있다. File vs Block OTAsfile 기반 OTA중에, 안드로이드는 system 파이션의 filesystem layer의 내용을 바꾼다.(파일마다). 일관된 순서로 파일을 쓴다거나 일관된 파일 수정시간, 동일 위치에 파일이 쓰이는 것에 대해서 보장되지 않는다. 이런 이유로 file 기반의 OTA는 dm-verify-enabled 디바이스에서 실패한다. OTA 시도후에 디바이스는 부팅할 수 없게 될수도 있다. block 기반 OTA중에 안드로이드는 두 집합의 파일의 차이보다는 두 block 이미지의 차이를 본다. 업데이트는 해당하는 빌드 서버에서 디바이스 빌드를 다음중에 하나의 방법을 사용하여 확인한다. Full Update 전체 시스템 이미지를 복사하는 것은 간단하고 패치 생성을 쉽게 만든다. 하지만 큰 사이즈의 이미지는 패치 적용 비용을 비싸게 만들 수 있다. Incremental Update 바이너리 diff 도구를 사용하여 보다 작은 이미지를 만들어내고 패치 적용을 쉽게 만든다. 하지만 패치를 생성할 때 메모리 사용량이 많을 수 있다. Updating unmodified systems (system 파티션이 변경되지 않은 상태에서의 업데이트)안드로이드 5.0을 사용하는 system 파티션이 변경되지 않은 디바이스에서는 file OTA와 block OTA에 대해서 다운로드와 설치 과정이 동일하다. 하지만 OTA 업데이트 그 자체는 다음과 같은 차이가 있을 수 있다. 다운로드 사이즈 : Full block OTA는 full file OTA와 사이즈가 비슷하다. 증분 업데이트의 경우에는 몇 메가바이트가 더 클 수 있다. 일반적으로는 증분 block OTA 가 증분 file OTA보다 더 크다. Flash 와 RAM 에 대한 오류 민감성 : 파일이 깨진 경우에, file OTA는 깨진 파일을 접근하지 않는 동안에는 성공하지만 block OTA는 system 파티션의 어떤 깨짐에도 실패하게 된다. Updating modified systems (system 파티션이 변경된 상태에서의 업데이트)안드로이드 5.0을 사용하는 system 파티션이 변경된 디바이스에서 증분 block OTA update는 실패한다. system 파티션은 adb remount 동안에 변경되거나 malware에 의해 변경될 수 있다. file OTA는 파티션의 일부 변경에 대해서 더 강인하다(예를 들어 증분 OTA에 포함되지 않은 파일의 추가나 변경에 대하여). 그러나 block OTA는 파티션의 어떤 변경에 대해서도 실패한다. 이런 경우에 Full OTA 로 system 파티션의 변경을 덥어써야 한다. . 변경된 파일을 바꾸려고 시도하는 것은 업데이트 실패를 발생시킨다. block OTA와 file OTA모두에서 변경된 파일을 업데이트하려는 것은 업데이트를 실패하게 한다. . 변경된 파일에 접근하려는 것은 에러를 만들어낸다.(dm-verify only) block OTA와 file OTA모두에서 dm-verify가 활성화되어 있고 system 파일시스템의 변경된 부분을 OTA 가 접근하려는 것은 에러를 발생시킨다. Inside OTA Packages Device-Specific Code리커버리 시스템은 OTA 업데이타가 안드로이드 시스템 이외의 부분 역시 업데이트 할 수 있도록 디바이스 특정적인 코드를 삽입할 훅을 포함하고 있다.(예를 들면, Baseband or radio processor) 다음 섹션은 yoyodyne 벤더가 생산하는 tardis 디바이스를 커스터마이즈하는 예제이다. Partition map안드로이드 2.3부터 플랫폼에서는 eMMc 플래시 디바이스를 지원하고 ext4 파일시스템을 지원한다. 또한 옛날 릴리즈를 위하여 Memory Technology Device(MTD) 플래시 디바이스와 yaffs2 파일시스템을 지원한다. 파티션 맵은 TARGET_RECOVERY_FSTAB에 의해 지정된다. 이 파일은 recovery 바이너리와 패키지 빌딩 도구들에 의해 사용된다. BoardConfig.mk에서 TARGET_RECOVERY_FSTAB를 사용하여 맵파일을 지정할 수 있다. 샘플 파티션 맵 파일은 다음과 같은 모양이다. 1device/yoyodyne/tardis/recovery.fstab 123456789# mount point fstype device [device2] [options (3.0+ only)]/sdcard vfat /dev/block/mmcblk0p1 /dev/block/mmcblk0/cache yaffs2 cache/misc mtd misc/boot mtd boot/recovery emmc /dev/block/platform/s3c-sdhci.0/by-name/recovery/system ext4 /dev/block/platform/s3c-sdhci.0/by-name/system length=-4096/data ext4 /dev/block/platform/s3c-sdhci.0/by-name/userdata 옵션인 /sdcard를 제외하고는 이 예제의 모든 파티션은 반드시 정의되어야 한다.(디바이스는 이 이외의 파티션도 추가할 수 있다.).다섯 종류의 파일시스템 타입을 지원한다. yaffs2 mtd ext4 emmc vfat 안드로이드 3.0부터, recovery.fstab 파일은 options 라는 추가의 옵션 필드를 가진다. 현재로써는 정의된 유일한 옵션은 length이다. 이것은 파티션의 길이를 명시적으로 지정할 수 있게 한다. 이 length는 파티션을 재포맷할 때에 사용된다.(e.g. data wipe/factory reset 동작중에 userdata 파티션을 위해서나 full OTA 패키지의 설치시 system 파티션을 위해서..) 만약 length 가 음수이면 포멧으로의 사이즈가 실제의 파티션 사이즈에 length 값을 추가한 값으로 정해진다.예를 들어 “length=-16384”로 설정하는 것은 그 파티션의 마지막 16k는 파티션이 재포맷될 때 덥어씌워지지 않게 한다. 이것은 userdata 파티션의 암호화와 같은 기능을 지원한다.(암호화 메타데이타가 파티션의 마지막에 저장되어 있어 덮어쓰면 안되는 경우) Boot animation디바이스 제조사는 안드로이드 디바이스가 부팅할 때 보여지는 애니메이션을 커스터마이즈할 수 있다. 이렇게 하기 위해서 bootanimation format에 따라 .zip 파일을 구성해야 한다. Note: 이미지는 Android Brand Guidelines 에 맞아야 합니다. Recovery UI다른 하드웨어를 가지고 있는 디바이스를 지원하기 위해서, 복구 인터페이스를 커스터마이즈 하여 상태를 표시하고, 수동으로 동작하는 숨겨진 기능에 접근할 수 있습니다. Goal은 디바이스 특정적인 기능을 제공하는 C++ object의 쌍을 정적 라이브러리로 제공하는 것입니다. 기본적으로 사용됩니다. 이 파일을 복사하고 새 디바이스에 대한 버전을 쓰는 것이 좋은 시작점입니다.12 device/yoyodyne/tardis/recovery/recovery_ui.cpp 1234567```cpp#include &lt;linux/input.h&gt;#include &quot;common.h&quot;#include &quot;device.h&quot;#include &quot;screen_ui.h&quot; Header and item functionsDevice 클래스는 숨겨진 리커버리 메뉴에 나타나야 하는 헤더와 아이템을 리턴하는 함수가 필요합니다. 헤더들은 어떻게 메뉴를 동작해야 하는지 나타냅니다. 12345678910static const char* HEADERS[] = &#123; \"Volume up/down to move highlight;\", \"power button to select.\", \"\", NULL &#125;;static const char* ITEMS[] = &#123;\"reboot system now\", \"apply update from ADB\", \"wipe data/factory reset\", \"wipe cache partition\", NULL &#125;; 긴 라인은 잘려나가기 때문에 디바이스의 화면 크기를 고려해야 합니다. Customize CheckKey다음으로, 디바이스의 RecoveryUI 구현을 정의해야 합니다. 이 예제는 tardis 디바이스가 스크린을 가지고 있다고 가정했으며 내장의 ScreenRecoveryUIimplementation에서 상속이 가능합니다.(스크린 없는 디바이스에서의 동작은 [devices without a screen]을 보세요) ScreenRecoveryUI에서 커스터마이즈할 함수는 CheckKey()입니다. 이 함수는 최초 비동기적 키 핸들링을 합니다. 123456789class TardisUI : public ScreenRecoveryUI &#123; public: virtual KeyAction CheckKey(int key) &#123; if (key == KEY_HOME) &#123; return TOGGLE; &#125; return ENQUEUE; &#125;&#125;; KEY constantsKEY_* 상수는 linux/input.h 에 정의되어 있습니다. CheckKey()는 리커버리의 나머지에서 어떤것을 하던지 불려집니다. 메뉴가 toggled off 될 때, on 될 때, 패키지 설치중에, userdata wiping 중에 등… 이 함수는 다음의 값 중 하나를 리턴할 수 있습니다. TOGGLE. 메뉴의 디스플레이를 토글하고 text 를 log on 또는 off 합니다. REBOOT. 즉시 디바이스를 재부팅합니다. IGNORE. 키 입력을 무시합니다. ENQUEUE. 키 입력을 enqueue합니다. &lt;= 수정할것…. CheckKey()는 KeyUp 이벤트가 따라오는 KeyDown 이벤트마다 호출됩니다. (A-down, B-down, B-up, A-up의 경우 CheckKey(B)만 호출됩니다.) CheckKey()는 IsKeyPressed()를 호출해서 다른 키가 눌려져 있는지 확인할 수 있습니다. (위의 시퀀스에서 CheckKey(B) 가 IsKeyPressed(A)를 호출하면 true를 리턴한다.) CheckKey()는 클래스에서 상태를 유지할 수 있습니다. 이것은 특정 순서의 키 순서를 감지하기 위해 유용합니다. 이 예제는 다소 복잡한 setup을 보여줍니다. POWER키가 눌린 상태에서 VOLUMEUP 키를 누르면 디스플레이가 토글되고 POWER 버튼을 다섯번 누르면 디바이스는 리붓합니다. 12345678910111213141516171819202122class TardisUI : public ScreenRecoveryUI &#123; private: int consecutive_power_keys; public: TardisUI() : consecutive_power_keys(0) &#123;&#125; virtual KeyAction CheckKey(int key) &#123; if (IsKeyPressed(KEY_POWER) &amp;&amp; key == KEY_VOLUMEUP) &#123; return TOGGLE; &#125; if (key == KEY_POWER) &#123; ++consecutive_power_keys; if (consecutive_power_keys &gt;= 5) &#123; return REBOOT; &#125; &#125; else &#123; consecutive_power_keys = 0; &#125; return ENQUEUE; &#125;&#125;; ScreenRecoveryUIScreenRecoveryUI에서 다른 이미지를 사용하는 경우 animation_fps를 설정하여 애니메이션의 frame 표시 속도를 조절할 수 있습니다. interlace-frames.py 스크립트는 animation_fps정보를 이미지 그 자체에 저장하는 것을 가능하게 합니다. 이전의 안드로이드 버전에서는 animation_fps 를 설정해야 했습니다. animation_fps를 설정하기 위해 ScreenRecoveryUI::Init()함수를 오버라이드 해야 합니다. 값을 설정하고 parent의 Init()함수를 호출합니다. 디폴트 값은 20FPS입니다. 디폴트 이미지를 사용하고 디폴트 값을 사용한다면 Init()함수를 제공할 필요가 없습니다. 자세한 것은 Recovery UI Images를 보세요. Device ClassRecoveryUI 구현 이후에, 디바이스의 device 클래스를 정의해야 합니다.(내장 Device class의 서브클래스) device클래스는 하나의 UI객체를 생성하고 GetUI함수를 통해 디바이스에서 사용할 UI 클래스를 리턴해야 합니다. StartRecoveryStartRecovery() 메소드는 리커버리의 시작시점에 호출됩니다. (이 시점은 UI 가 초기화 되고, 인자들이 모두 파싱된 이후이고, 실제의 동작이 수행되기 이전입니다. 디폴트 구현은 아무것도 하지 않습니다. 그렇기 때문에 아무것도 할 게 없다면 서브클래스에서 이 함수를 제공할 필요는 없습니다. 123void StartRecovery() &#123; // ... do something tardis-specific here, if needed .... &#125; Supplying and managing recovery menusystem은 두 개의 메소드를 호출하여 헤더 라인과 아이템 리스트를 얻습니다. 이 구현에서는 파일의 가장 위에 정의된 정적 배열을 리턴합니다. 12const char* const* GetMenuHeaders() &#123; return HEADERS; &#125;const char* const* GetMenuItems() &#123; return ITEMS; &#125; HandleMenuKey다음으로 HandleMenuKey()함수를 제공합니다. 이 메소드는 키입력과 현재 메뉴의 가시성을 입력으로 받고 어떤 동작을 할지 결정합니다. 12345678910int HandleMenuKey(int key, int visible) &#123; if (visible) &#123; switch (key) &#123; case KEY_VOLUMEDOWN: return kHighlightDown; case KEY_VOLUMEUP: return kHighlightUp; case KEY_POWER: return kInvokeItem; &#125; &#125; return kNoAction; &#125; 이 메소드는 key code와 menu/text log가 보이는지에 대한 상태를 입력으로 받습니다. 리턴 값은 정수입니다. 만약 값이 0이상이면, 메뉴 아이템의 포지션으로 취해지고 즉시 호출됩니다. (아래의 InvokeMenuItem() 메소드를 보세요.).그렇지 않으면 다음의 상수를 리턴할 수 있습니다. kHighlightUp. 메뉴의 포커스를 앞으로(위로) 이동합니다. kHighlightDown. 메뉴의 포커스를 다음으로(아래로) 이동합니다. kInvokeItem. 현재 Highlight 된 아이템을 호출합니다. kNoAction. 아무것도 하지 않습니다.visible 인자에서 함축하듯이, HandleMenuKey()는 보이지 않는 menu에 대해서도 불릴 수 있습니다. CheckKey()와는 달리, 패키지 설치를 하거나 Data Wipe를 하는 등의 리커버리 작업 중에는 호출되지 않습니다. - 이 함수는 리커버리가 idle 상태이거나 입력을 기다리고 있는 경우에만 호출됩니다. Trackball Mechanisms디바이스가 트랙볼 입력 메카니즘을 가지고 있다면(EV_REL 타입과 REL_Y 코드의 입력 이벤트를 생성) 리커버리는 트랙볼같은 입력 디바이스가 Y축의 움직임을 보고할 때마다 KEY_UP과 KEY_DOWN키 입력을 합성합니다.작업해야 하는 것은 KEY_UP 과 KEY_DOWN이벤트를 메뉴 동작으로 맵핑하는 것 뿐입니다. 이 맵핑은 CheckKey()에서는 일어나지 않습니다. 그러므로 트랙볼 모션을 리부팅이나 디스플레이 토글을 발생시키기 위해 사용할 수 없습니다. Modifier Keys키가 modifier로써 누른 상태로 있는 것을 체크하기 위해서는 IsKeyPressed()메소드를 호출합니다. 예를 들어 어떤 디바이스는 Alt-W를 리커버리에 누르면 data wipe을 개시합니다. 다음과 같이 구현합니다. 123456int HandleMenuKey(int key, int visible) &#123; if (ui-&gt;IsKeyPressed(KEY_LEFTALT) &amp;&amp; key == KEY_W) &#123; return 2; // position of the \"wipe data\" item in the menu &#125; ... &#125; visible 이 false 이더라도 메뉴를 조작하기 위해 리턴하는 값에는 영향이 없습니다. 그러므로 원하는 동작에 대한 값을 리턴하면 됩니다. InvokeMenuItem다음으로 InvokeMenuItem() 메소드를 제공합니다. 이 메소드는 정수의 position을 GetMenuItems()함수에서 리턴되는 동작으로 맵핑합니다. 예를 들어 다음과 같습니다. 123456789BuiltinAction InvokeMenuItem(int menu_position) &#123; switch (menu_position) &#123; case 0: return REBOOT; case 1: return APPLY_ADB_SIDELOAD; case 2: return WIPE_DATA; case 3: return WIPE_CACHE; default: return NO_ACTION; &#125; &#125; 이 메소드는 시스템이 어떤 동작을 수행할지를 시스템에 알려주기 위해 BuiltinAction 열거값의 어떤 값이라도 리턴할 수 있습니다.(또는 아무것도 하지 않게 하기 위해 NO_ACTION을 리턴할 수 있습니다.) 이 위치는 시스템에서 제공하는 것 이상의 복구 기능을 제공하기 위한 위치입니다. 메뉴에 아이템을 추가하고 메뉴아이템이 불렸을 때 이 위치에서 동작을 실행하고, NO_ACTION을 리턴하여 시스템이 다른 동작을 하지 않게 합니다. BuiltinAction은 다음의 값들을 가지고 있습니다. NO_ACTION 아무것도 하지 않습니다. REBOOT 리커버리를 나오고 디바이스를 일반 모드로 리붓합니다. APPLY_EXT, APPLY_CACHE, APPLY_ADB_SIDELOAD. 다양한 위치의 update 패키지를 설치합니다. 자세한 내용은 Sideloading을 보세요. WIPE_CACHE 캐시 파티션을 재포맷합니다. 비교적 피해가 없기때문에 확인 메세지는 표시되지 않습니다. WIPE_DATA userdata와 cache 파티션을 재포멧합나다. factory data reset으로 알려져 있습니다. 진행하기 전에 사용자에게 확인을 받게 됩니다. 마지막 메소드인, WipeData()는 옵션입니다. 이 함수는 data wipe 이 초기화 되었을 때 호출됩니다. 이 메소드는 userdata 와 cache 파티션이 wipe 되기 전에 호출됩니다. 만약 디바이스가 user data 를 이 두 파티션 이외에 저장한다면 이 위치에서 지워야 합니다. 리턴값 0은 성공을 나타내고 다른 값은 실패를 나타냅니다. (현재로서는 이 리턴값은 무시되고 있습니다.) 리턴값에 관계없이 userdata 와 cache 파티션은 지워집니다. 1234567891011121314151617 int WipeData() &#123; // ... do something tardis-specific here, if needed .... return 0; &#125;``` #### Make Device마지막으로, recovery_ui.cpp의 마지막에 make_device()를 위한 코드를 삽입합니다. 이 함수는 Device class의 인스턴스를 생성하고 리턴합니다.```cppclass TardisDevice : public Device &#123; // ... all the above methods ...&#125;;Device* make_device() &#123; return new TardisDevice();&#125; Build and link to device recoveryrecovery_ui.cpp 파일을 완료한 다음에, 빌드하고 디바이스의 리커버리에 링크합니다. Android.mk에서 이 C++ 파일만을 포함하는 정적 라이브러리를 포함합니다. 1device/yoyodyne/tardis/recovery/Android.mk 1234567891011LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE_TAGS := engLOCAL_C_INCLUDES += bootable/recoveryLOCAL_SRC_FILES := recovery_ui.cpp# should match TARGET_RECOVERY_UI_LIB set in BoardConfig.mkLOCAL_MODULE := librecovery_ui_tardisinclude $(BUILD_STATIC_LIBRARY) 그리고, 이 디바이스의 Board Configuration에서 이 정적 라이브러리를 TARGET_RECOVERY_UI_LIB에서 지정합니다. 12345device/yoyodyne/tardis/BoardConfig.mk [...]# device-specific extensions to the recovery UITARGET_RECOVERY_UI_LIB := librecovery_ui_tardis Recovery UI imagesProgress barsDevices without screensUpdaterOTA package generationSideloadingTime zone rule updates안드로이드 8.1부터 system 업데이트를 하지 않고도 업데이트된 time zone rule data를 push 할 수 있게 되었다. 이 메카니즘은 사용자가 적시에 업데이트를 받고 OEM이 system image 업데이트와 독립적으로 time zone updates를 테스트 할 수 있게 한다. 자세한 것은 Time Zone Rules를 참조하라.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"지식","slug":"Android/지식","permalink":"http://jung-max.github.io/categories/Android/지식/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"}]},{"title":"라즈베리파이 tp link t2u plus(ac600) 드라이버 설치(8812au)","slug":"라즈베리파이-tp link t2u plus(ac600) 드라이버 설치(8812au)","date":"2021-04-30T06:25:43.000Z","updated":"2022-02-08T02:11:11.828Z","comments":true,"path":"2021/04/30/라즈베리파이-tp link t2u plus(ac600) 드라이버 설치(8812au)/","link":"","permalink":"http://jung-max.github.io/2021/04/30/라즈베리파이-tp link t2u plus(ac600) 드라이버 설치(8812au)/","excerpt":"","text":"설치라즈베리는 기본적으로 wifi 모듈을 가지고 있다 하지만 수신률을 보면 그렇게 만족스럽지 못하다. 때문에 usb wifi 모듈을 찾아봤고 선택한게 tp-link사의 Archer T2U Plus 제품이다. 해당 제품은 리눅스 드라이버를 정식 지원하진 않지만 8812au 드라이버를 설치함으로서 사용할 수 있다. 설치 방법은 아래와 같다. 1234567891011sudo apt update &amp;&amp; sudo apt full-upgrade -ysudo apt install git dkmsgit clone https://github.com/aircrack-ng/rtl8812au.gitcd rtl8812aumakemake install 기본 내장 모듈 제거참고로 추가 모듈을 달면 기존의 wlan0이 살아있고 추가된 모듈은 wlan1로 동작한다. 내장 모듈 wlan0을 사용하지 않기 위해서는 /boot/config.txt를 수정한다. 가장 마지막 줄에 아래와 같이 추가한다. 1dtoverlay=disable-wifi 그 후 재부팅하면 적용된다. 주의 할 점은 내장 모듈을 사용하지 않기 때문에 추가된 모듈이 wlan1에서 wlan0으로 변경되었다는 점이다. 고정 IP등을 적용할 때 이점을 꼭 참고해야한다.","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"라즈베리파이","slug":"기타/라즈베리파이","permalink":"http://jung-max.github.io/categories/기타/라즈베리파이/"}],"tags":[{"name":"Android raspberry pi","slug":"Android-raspberry-pi","permalink":"http://jung-max.github.io/tags/Android-raspberry-pi/"}]},{"title":"라즈베리파이 크로미엄 키오스크 모드 및 부팅시 자동 실행","slug":"라즈베리파이-크로미엄 키오스크 모드 및 부팅시 자동 실행","date":"2021-04-28T04:59:36.000Z","updated":"2022-02-08T02:11:11.831Z","comments":true,"path":"2021/04/28/라즈베리파이-크로미엄 키오스크 모드 및 부팅시 자동 실행/","link":"","permalink":"http://jung-max.github.io/2021/04/28/라즈베리파이-크로미엄 키오스크 모드 및 부팅시 자동 실행/","excerpt":"","text":"/etc/xdg/lxsession/LXDE-pi/autostart를 수정한다. 제일 아래에 아래와 같이 추가한다. 1chromium-browser --start-maximized --kiosk www.naver.com 각종 인증서 에러등을 무시할려면 아래와 같이 추가한다. 1chromium-browser --ignore-certificate-error --ignore-ssl-errors --start-maximized --kiosk www.naver.com","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"라즈베리파이","slug":"기타/라즈베리파이","permalink":"http://jung-max.github.io/categories/기타/라즈베리파이/"}],"tags":[{"name":"raspberry pi","slug":"raspberry-pi","permalink":"http://jung-max.github.io/tags/raspberry-pi/"}]},{"title":"라즈베리파이 유용한 설정들","slug":"라즈베리파이-유용한설정들","date":"2021-04-16T01:51:22.000Z","updated":"2022-02-08T02:11:11.831Z","comments":true,"path":"2021/04/16/라즈베리파이-유용한설정들/","link":"","permalink":"http://jung-max.github.io/2021/04/16/라즈베리파이-유용한설정들/","excerpt":"","text":"화면 꺼짐 방지라즈베리를 쓰다보면 10분(?)정도 지나면 자동으로 계속 화면이 꺼진다. 이럴때 /boot/cmdline.txt를 수정하면 된다. 1$ sudo vim /boot/cmdline.txt 파일의 제일 끝에 아래와 같이 추가한다. 1consoleblank=0 번개모양(파워 약할때) 없애기라즈베리 정식 아답터를 쓰지 않고 컴퓨터 같은 usb 전원에 꽂으면 라즈베리가 부팅은 되지만 전압이 부족해서 UI에 번개표시가 나타난다. 이때 번개표시를 없애기 위해서 아래와 같이 설정할 수 있다.(제일 좋은건 정품 아답터 사용…) /boot/config.txt를 수정 마지막 줄에 아래와 같이 추가한다. 1avoid_warnings=1 참고로 avoid_warnings=1을 설정하면 경고를 없애주고 avoid_warnings=2를 설정하면 1설정에 추가로 저전압때도 터보를 사용 가능하게한다. Navigate to Preferences &gt; Add/Remove Software Search for Battery Disable the “battery monitor plugin for lxpanel” 시작시 프로그램 시작/etc/xdg/lxsession/LXDE-pi/autostart수정 1vim /etc/xdg/lxsession/LXDE-pi/autostart autostart 파일 가장 아래에 본인이 실행하고자 하는 파일을 lxterminal -e 명령어와 함께 작성한다. 1lxterminal -e /etc/autostart.sh 마우스커서 없애기1234sudo apt-get install uncluttersudo vim /etc/xdg/lxsession/LXDE-pi/autostart@unclutter -idle 0sudo reboot","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"라즈베리파이","slug":"기타/라즈베리파이","permalink":"http://jung-max.github.io/categories/기타/라즈베리파이/"}],"tags":[{"name":"raspberryPi","slug":"raspberryPi","permalink":"http://jung-max.github.io/tags/raspberryPi/"},{"name":"setting","slug":"setting","permalink":"http://jung-max.github.io/tags/setting/"}]},{"title":"라즈베리파이 pyWebView","slug":"라즈베리파이-pyWebView","date":"2021-04-16T01:51:22.000Z","updated":"2022-02-08T02:11:11.827Z","comments":true,"path":"2021/04/16/라즈베리파이-pyWebView/","link":"","permalink":"http://jung-max.github.io/2021/04/16/라즈베리파이-pyWebView/","excerpt":"","text":"pyWebView 설치1234apt-get install python3-webviewapt-get install python3-pyqt5apt-get install python3-pyqt5.qtwebkitapt-get install libqt5webkit5-dev 주기적으로 리로딩12345678910111213import webviewimport timedef reload(window): while True: time.sleep(5) window.load_url('index.html') if __name__ == '__main__':1 window = webview.create_window('hello', 'index.html') webview.start(reload, window, http_server=True)","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"라즈베리파이","slug":"기타/라즈베리파이","permalink":"http://jung-max.github.io/categories/기타/라즈베리파이/"}],"tags":[{"name":"raspberryPi","slug":"raspberryPi","permalink":"http://jung-max.github.io/tags/raspberryPi/"},{"name":"setting","slug":"setting","permalink":"http://jung-max.github.io/tags/setting/"}]},{"title":"라즈베리파이 숨겨진(히든)와이파이 설정하기","slug":"라즈베리파이-숨겨진(히든)와이파이-설정","date":"2021-04-08T06:40:12.000Z","updated":"2022-02-08T02:11:11.832Z","comments":true,"path":"2021/04/08/라즈베리파이-숨겨진(히든)와이파이-설정/","link":"","permalink":"http://jung-max.github.io/2021/04/08/라즈베리파이-숨겨진(히든)와이파이-설정/","excerpt":"","text":"라즈베리 파이 와이파이에서는 숨겨진 와이파이를 설정할 수 있는 GUI가 존재하지 않는다. 그래서 설정을 위해 구글링을 열심히 했으나 /etc/wpa_supplicant/wpa_supplicant.conf를 수정하면 됩니다! 라는 글이 대부분이다. 문제는 해당 파일을 수정하고 리붓 또는 네트워크서비스 재시작시 해당 파일이 저장하기 전으로 초기화되는 것이다. 이것때문에 라즈베리안 OS를 다시 깔고, 별짓을 다해봤는데 안되서 구글링을 한 끝에 찾은 방법 아래 방법은 라즈베리안 설정이 디폴트(국가 gb)일때 테스트입니다. 한국 설정에서 했을때 국가 선택의 오류인지 잘 모르겠지만 안되는 현상을 봤습니다. /boot/ 폴더 접근cd /boot를 통해 해당 폴더에 접근한다. 해당 폴더에는 wpa_supplicant.conf가 존재하지 않는다. 해당 폴더에 wpa_supplicant.conf을 생성하고 작성한다. 1$ sudo vim /boot/wpa_supplicant.conf 123456789country=GBctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123; ssid=&quot;yourssidname&quot; scan_ssid=1 psk=&quot;yourssidpassword&quot; key_mgmt=WPA-PSK&#125; 그 후 reboot 명령어로 리붓을한다. /boot/wpa_supplicant.conf은 사라지고 대신 /etc/wpa_supplicant/wpa_supplicant.conf의 내용이 변경되어 있는 것을 확인할 수 있다.물론 적어놓은 ssid로 자동 접속이 된다. 고정 IP 설정/etc/dhcpcd.conf 수정 1234interface wlan0static ip_adress=192.168.0.80/24static routers=192.168.0.254static domain_name_servers=8.8.8.8 9.9.9.9 서브넷 마스크는 static ip_adress=192.168.0.80/24에서 /24 부분을 수정하면 변경이 된다.숫자는 2의 제곱수를 뜻한다.자세한 내용은 아래 링크를 참조하자.https://www.raspberrypi.org/forums/viewtopic.php?t=159909 interface 수정아래 내용은 적용은 되지만 gui에 표시가 되지 않는다.그러니 되도록 추천하지는 않는다. 아래는 서브넷마스크까지 지정이 필요할때 시행한다.해당 사항을 수정하면 라즈베리파이 GUI에 표시가 되지 않을 수 있다. /etc/network/interfaces 수정 123456789101112131415161718192021# interfaces(5) file used by ifup(8) and ifdown(8) # Please note that this file is written to be used with dhcpcd # For static IP, consult /etc/dhcpcd.conf and &apos;man dhcpcd.conf&apos; # Include files from /etc/network/interfaces.d: source-directory /etc/network/interfaces.d auto lo iface lo inet loopback iface eth0 inet manual allow-hotplug wlan0 iface wlan0 inet static wpa-conf /etc/wpa_supplicant/wpa_supplicant.conf address 192.168.0.80 netmask:q 255.255.255.0 gateway 192.168.0.1 network 192.168.0.0 broadcast 192.168.0.255 고정 ip (유선)/etc/network/interfaces 수정 1234567891011121314151617# interfaces(5) file used by ifup(8) and ifdown(8) # Please note that this file is written to be used with dhcpcd # For static IP, consult /etc/dhcpcd.conf and &apos;man dhcpcd.conf&apos; # Include files from /etc/network/interfaces.d: source-directory /etc/network/interfaces.d auto lo iface lo inet loopback auto eth0iface eth0 inet static address 192.168.0.1 netmask 255.255.255.0 gateway 192.168.0.254 dns-nameservers 192.168.1.2 네트워크 재시작 1sudo service networking restart","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"라즈베리파이","slug":"기타/라즈베리파이","permalink":"http://jung-max.github.io/categories/기타/라즈베리파이/"}],"tags":[{"name":"Android raspberry pi","slug":"Android-raspberry-pi","permalink":"http://jung-max.github.io/tags/Android-raspberry-pi/"}]},{"title":"Centos에서 smb mount 하기","slug":"Centos에서-smb마운트하기","date":"2020-08-12T23:52:15.000Z","updated":"2022-02-08T02:11:11.786Z","comments":true,"path":"2020/08/13/Centos에서-smb마운트하기/","link":"","permalink":"http://jung-max.github.io/2020/08/13/Centos에서-smb마운트하기/","excerpt":"","text":"윈도우의 공유 서버를 centos에서 자기 폴더처럼 사용하는 방법이다. 윈도우에서 개발을 하고 배포를 centOs에 할때 해당 방법을 쓰면 편리하다. 설치mount하고자 하는 서버에 samba와 cifs를 설치한다. 12#yum install samba#yum install cifs-utils 마운트명령어 1#mount -t cifs -o user='사용자명',password='암호' \\\\\\\\서버주소\\\\공유폴더경로 /마운트경로 명령어 예시 12mkdir /winSamba#mount -t cifs -p user='ywjung',password='1' \\\\\\\\192.168.0.115\\\\libs /winSamba 만약 smb 버전을 지정하고 싶으면 아래와 같이 하면된다. 12#mount -t cifs -o user='사용자명',password='암호',ver=1.0 \\\\\\\\서버주소\\\\공유폴더경로 /마운트경로#mount -t cifs -o user='사용자명',password='암호',ver=2.0 \\\\\\\\서버주소\\\\공유폴더경로 /마운트경로 재부팅시 유지123#vi /etc/fstab\\\\\\\\192.168.0.152\\\\libs /winSamba cifs user=ywjung,pass=1,rw,vers=2.0 0 0","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"기타","slug":"기타/기타","permalink":"http://jung-max.github.io/categories/기타/기타/"}],"tags":[{"name":"VScode","slug":"VScode","permalink":"http://jung-max.github.io/tags/VScode/"}]},{"title":"CentOs7에 서버 환경 구성","slug":"Web-CentOs7에-환경구성","date":"2020-07-20T02:37:51.000Z","updated":"2022-02-08T02:11:11.823Z","comments":true,"path":"2020/07/20/Web-CentOs7에-환경구성/","link":"","permalink":"http://jung-max.github.io/2020/07/20/Web-CentOs7에-환경구성/","excerpt":"","text":"개요 설치 OS : CentOs7 Web/WAS : 아파치, 톰캣 DB : mariaDB tomcat 설치tomcat 다운로드https://tomcat.apache.org/download-80.cgi 압출 풀기 12gunzip apach-tomcat-8.x.xx.tar.gztar -xvf apach-tomcat-8.x.xx.tar 원하는 위치로 이동 1mv apach-tomcat-8.x.xx /usr/local/apach-tomcat-8.x.xx 톰캣을 위한 폴더 생성1234cd /usr/usernamemkdir srccd srcmkdir tomcat1 이후 이 곳에서 war파일을 배포한다. 톰캣 설정12cd /usr/local/apach-tomcat-8.x.xx/confvi server.xml 최 하단쪽에 아래 문구를 찾음 12&lt;Host name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"&gt; 여기서 unpackWARs와 autoDeploy는 성능에 영향을 미치기 때문에 사용하지 않는다.아래와 같이 수정한다. 1234&lt;Host name=\"localhost\" appBase=\".\" unpackWARs=\"false\" autoDeploy=\"false\"&gt; &lt;Context doocBase=\"/home/usrname/src/tomcat1\" path=\"\" reloadable=\"false\"/&gt; 톰캣 확인아래 명령어로 톰캣 실행 12/usr/local/apache-tomcat-8.x.xx/bin/startup.shtail -f /usr/local/apache-tomcat-8.x.xx/logs/catalina.out 정상적으로 로그가 나오는지 확인 수동으로 톰캣에 배포하기이클립스에서 빌드하기war 파일로 배포하는 것을 설명한다. jar → war 변경만약 프로젝트 배포가 jar로 배포하도록 초기 설정을 하였다면 아래와 같이 수정한다. gradle의 경우 아래와 같이 추가한다123456apply plugin: 'war'war &#123; baseName = 'gradle' version = '0.0.1'&#125; maven의 경우 아래와 같이 추가한다1234&lt;groupId&gt;com.example&lt;/groupId&gt;&lt;artifactId&gt;maven&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;war&lt;/packaging&gt; ServletInitializer를 추가한다스프링부트를 통해 만든 웹 애플리케이션의 경우 embeded 톰켓을 이용한다면 @SpringBootApplication을 구현한 클래스만 있으면 되지만, 따로 톰켓을 통해 배포하는 경우 SpringBootServletInitializer를 상속받은 클래스가 필요합니다. 12345678public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; return application.sources(DemoWarApplication.class); &#125;&#125; DemoWarApplication.class 부분은 본인의 @SpringBootApplication 구현체를 넣으시면 됩니다. (스프링부트 생성시 존재하는 클래스) ServletInitializer 추가 위와 같이 ServletInitializer를 추가해 주시면 됩니다.(war 패키징 되는 프로젝트로 생성하면 처음 초기화 시 위와 같이 ServletInitializer도 같이 생성되는 걸 볼 수 있습니다.) gadle 빌드하기이클립스 상단 Window &gt; Show View &gt; Other…를 선택한다. 여러가지 목록 중 Gradle &gt; Gradle Tasks를 선택하고 ok를 클릭하면 Gradle Tasks 뷰가 추가된다. build 메뉴를 우클릭하고 Run Gradle Tasks를 선택 그러면 이클립스에서 자동으로 Gradle Execution 뷰가 열리고 빌드가 진행된다. war 파일은 애플리케이션의 build 폴더 밑의 libs 폴더에 만들어 진다. 배포하기톰캣에 배포하는 것을 설명한다. 앞에서 만든 war파일을 서버에 전송하고 war파일의 압출을 푼다. 앞에서 만든 /home/username/src/tomcat1 폴더로 war파일을 전송한다. war 파일의 압출을 풀기 위해 아래와 같이 명령어를 실행한다. 1jar -xvf xxxx.war 만약 jar 명령어가 없다면 아래와 같이 설치한다. 1yum install java-1.8.0-openjdk-devel 이후 아래와 같이 재시작한다. 123/usr/local/apache-8.x.xx/bin/shutdown.sh/usr/local/apache-8.x.xx/bin/startup.shtail -f /usr/local/apache-tomcat-8.x.xx/logs/catalina.out 로그를 확인하고 정상적으로 동작하는지 확인한다. 서버 부팅시 Tomcat 자동 실행1. 실행 스크립트 작성12[root@tourWeb1 ~]# cd /etc/rc.d/init.d/[root@tourWeb1 ~]# vi tomcat 스크립트 내용 123456789101112131415161718192021222324252627#!/bin/bash# Startup script for the Tomcat Server# chkconfig: 345 50 50# description: Tomcat is a Web application server.# processname: java# directory : CATALINA_HOME=/usr/local/apache-tomcat-8.x.xxsource /etc/profileexport CATALINA_HOME=/usr/local/apache-tomcat-8.x.xxcase &quot;$1&quot; in start) echo &quot;Starting tomcat: &quot; su - test -c $CATALINA_HOME/bin/startup.sh ;; stop) echo &quot;Shutting down tomcat: &quot; su - test -c $CATALINA_HOME/bin/shutdown.sh ;; restart) echo &quot;Restarting tomcat: &quot; su - test -c $CATALINA_HOME/bin/shutdown.sh; su - test -c $CATALINA_HOME/bin/startup.sh ;; *) echo &quot;Usage: service tomcat &#123;start|stop|restart&#125;&quot; exit 1esacexit 0 위의 su - test 로 시작되는 문구는 해당 user 계정으로 톰캣을 실행하겠다는 의미이니, test 부분을 사용자 계정ID로 변경한다. su - test -c $CATALINA_HOME/bin/startup.sh su - test -c $CATALINA_HOME/bin/shutdown.sh su - test -c $CATALINA_HOME/bin/shutdown.sh; su - test -c $CATALINA_HOME/bin/startup.sh 2. 파일 소유권/실행권한 지정 및 run level 등록1234567891011# 사용자 계정에게 소유권 변경[root@tourWeb1 ~]# chown test:test tomcat# 실행권한 주기[root@tourWeb1 ~]# chmod 755 tomcat # runlevel 등록[root@tourWeb1 ~]# chkconfig --add tomcat# 등록확인[root@tourWeb1 ~]# chkconfig --list tomcat 3. tomcat 프로세스 수동 실행/정지 해보기.12[root@tourWeb1 ~]# service tomcat start[root@tourWeb1 ~]# service tomcat stop mariaDb 설치docker 설치docker 다운로드. 1sudo yum install docker docker 등록 12sudo systemctl start dockersudo systemctl enable docker docker 실행 확인 1sudo docker run hello-world 마리아db 이미지 다운로드1docker pull mariadb 컨테이너 시작1docker run --name=\"mariadb\" -d -p 3306:3306 -e MYSQL_ROOT_PASSWORD=1 mariadb –name은 Container의 이름 으로 mariadb로 설정하였습니다. -d 는 detached mode로 Container가 백그라운드로 실행됩니다. -p는 Host와 Container의 포트를 연결하는 것으로 Host에서 3306 포트로 접속시 Container 3306으로 포워딩 되도록 한 설정 입니다. -e는 Container 내에서 사용할 환경변수로 MYSQL_ROOT_PASSWORD는 root 계정의 password 를 설정하기 위한 환경변수 입니다. 마지막에 있는 mariadb는 위에서 pull한 image 이름 입니다. Container bash에 접속1docker exec -it mariadb /bin/bash exec를 통해 Container에 특정 명령을 실행할수 있습니다. -it는 -i와 -t의 옵션을 합친 것으로 Container에서 Bash를 사용할 수 있습니다. mariadb는 run시 지정한 Container의 이름입니다. /bin/bash는 bash Shell에 연결하겠다는 의미입니다. 명령을 실행 후 터미널을 보면 root 계정으로 Container Bash에 접속한 것을 알 수 있습니다. MariaDB 접속드디어 mysql -u root -p 를 통해 MariaDB에 접속할 수 있습니다. 비밀번호는 docker run시 환경변수로 설정한 MYSQL_ROOT_PASSWORD의 값입니다. MariaDB characterset 설정status 명령어를 사용해서 MariaDB의 설정정보를 볼수 있는데 characterset을 보면 Server와 DB의 characterset이 latin1로 되어 있는 것을 알 수 있습니다. latin1에서는 한글이 깨질 수 있기 때문에 UTF8로 변경해 줘야 합니다. /etc/mysql/my.cnf 파일에서 내용을 아래와 같이 추가/수정해 줍니다. 12345678910[client]default-character-set = utf8mb4[mysql]default-character-set = utf8mb4[mysqld]collation-server = utf8_unicode_ciinit-connect='SET NAMES utf8'character-set-server = utf8 종료시에는 exit로 나옵니다. 변경한 설정을 저장하기 위해 Container를 restart 해줍니다. Container의 ID는 docker ps 명령어를 사용해서 확인할 수 있습니다. 외부 접근 허용MariaDB 설치는 끝났다. 하지만 외부에서 DB로 접근이 아직 안된다. 방화벽 포트를 열어주고, MariaDB에서 권한을 부여해야한다. 1. 방화벽 포트 개방ssh를 위한 22번과 MySQL 3306포트가 열린것을 확인할 수 있다. 123456[jamong@localhost ~]$ sudo firewall-cmd --zone=public --add-port=3306/tcp --permanentsuccess[jamong@localhost ~]$ sudo firewall-cmd --reloadsuccess[jamong@localhost ~]$ sudo firewall-cmd --list-ports22/tcp 3306/tcp 2. MySQL 권한 부여mysql -u root -p 실행 -모든 ip 개방 12345mariadb&gt; GRANT ALL PRIVILEGES ON *.* TO root@&apos;%&apos; IDENTIFIED BY &apos;비밀번호&apos;;Query OK, 0 rows affected, 1 warning (0.00 sec)mariadb&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec)","categories":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/categories/Web/"},{"name":"SpringBoot","slug":"Web/SpringBoot","permalink":"http://jung-max.github.io/categories/Web/SpringBoot/"}],"tags":[{"name":"개발환경","slug":"개발환경","permalink":"http://jung-max.github.io/tags/개발환경/"},{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/tags/Web/"}]},{"title":"7. SpringBoot 게시판 만들기-3","slug":"Web-7_SpringBoot-게시판만들기-3","date":"2020-06-24T07:13:02.000Z","updated":"2022-02-08T02:11:11.822Z","comments":true,"path":"2020/06/24/Web-7_SpringBoot-게시판만들기-3/","link":"","permalink":"http://jung-max.github.io/2020/06/24/Web-7_SpringBoot-게시판만들기-3/","excerpt":"","text":"컨트롤러 영역컨트롤러는 클라이언트의 요청을 받아서 해당 요청을 수행하는데 필요한 비즈니스 로직을 호출하고 그 결과를 포함하여 응답을 해 주는 디스패처(Dispatcher) 역할을 수행한다. 컨트롤러는 다음의 과정을 거쳐서 구현한다. 컨트롤러 클래스에 @Controller 어노테이션을 적용한다. @RequestMapping 어노테이션을 이용하여 요청에 대한 주소를 지정한다. 요청에 필요한 비즈니스 로직을 호출한다. 실행된 비즈니스 로직의 결과를 뷰로 리턴한다. 일단 먼저 board.controller 패키지를 생성한다. 그 안에 BoardController 클래스를 생성한다. BoardController 클래스에 다음 내용을 작성한다. 12345678910111213141516171819202122232425262728package com.ckbs.MariaDbTest.board.controller;import java.util.List;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import com.ckbs.MariaDbTest.board.dto.BoardDto;import com.ckbs.MariaDbTest.board.service.BoardService;@Controller //①public class BoardController &#123; @Autowired private BoardService boardService; //② @RequestMapping(\"/board/openBoardList.do\") //③ public ModelAndView openBoardList() throws Exception&#123; ModelAndView mv = new ModelAndView(\"/board/boardList\"); //④ List&lt;BoardDto&gt; list = boardService.selectBoardList(); //⑤ mv.addObject(\"list\", list); //⑥ return mv; &#125;&#125; ① @Controller 어노테이션을 붙여줌으로서 해당 클래스가 컨트롤러로 동작하게 된다. ② boardService는 비즈니스로직을 처리하는 서비스 빈을 연결한다. 이는 아래 서비스 영역에서 다시 설명한다. ③ @RequestMapping(&quot;/board/openBoardList.do&quot;)은 어노테이션의 값으로 주소를 지정한다. 여기서는 웹브라우저에서 /board/openBoardList.do라는 주소를 호출하면 스프링 디스패처는 호출된 주소와 @RequestMapping 어노테이션의 값이 동일한 메서드를 찾아서 실행한다. ④ ModelAndView는 호출된 요청의 결과를 보여줄 뷰를 지정한다. 여기서는 /board/boardList로 지정했는데 이는 templates 폴더 아래있는 /board/boardList.html을 의미한다. Thymeleaf와 같은 템플릿을 사용할 경우 스프링 부트의 자동 설정 기능으로 .html과 같은 접미사를 생략할 수 있다. ⑤ List&lt;BoardDto&gt; list에서는 게시글 목록을 조회한다. “게시글 목록을 조회한다.”는 비즈니스 로직을 수행하기 위해서 BoardService 클래스의 selectBoardList 메서드를 호출한다. 게시글 목록을 저장하기 위해서 List 인터페이스를 사용했다. ⑥ 실행된 비즈니스 로직의 결과 값을 뷰에 list라는 이름으로 저장한다. 이 부분은 추후 뷰 영역 설명에서 다시 확인해보자. 서비스 영역서비스 영역은 일반적으로 두 개의 파일로 구성된다. Service 인터페이스와 ServiceImpl 클래스이다. 이와 같이 인터페이스를 실제로 구현하는 클래스와 인터페이스로 분리할 경우 여러가지 장점이 있다. 느슨한 결함(loose coupling)을 유지하여 각 기능 간의 의존관계를 최소화 한다. 의존 관계의 최소화로 인해 기능의 변화에도 최소한의 수정으로 개발할 수 있는 유연함을 가진다. 모듈화를 통해 어디서든 사용할 수 있도록 하여 재사용성을 높인다. 스프링의 IoC/DI(Inversion of Control / Dependency Injection) 기능을 이용한 빈 관리 기능을 사용할 수 있다. board.service 패키지를 생성한다. 그 안에 BoardService 인터페이스와 BoardServiceImpl 클래스를 생성한다. BoardService 인터페이스에 다음 내용을 작성한다. 12345678910package com.ckbs.MariaDbTest.board.service;import java.util.List;import com.ckbs.MariaDbTest.board.dto.BoardDto;public interface BoardService &#123; List&lt;BoardDto&gt; selectBoardList() throws Exception;&#125; BoardService 인터페이스에는 비즈니스 로직을 수행하기 위한 메서드를 정의한다. BoardServiceImpl에 다음 내용을 작성한다. 123456789101112131415161718192021package com.ckbs.MariaDbTest.board.service;import com.ckbs.MariaDbTest.board.dto.BoardDto;import com.ckbs.MariaDbTest.board.mapper.BoardMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Service //①public class BoardServiceImpl implements BoardService &#123; @Autowired private BoardMapper boardMapper; //② @Override public List&lt;BoardDto&gt; selectBoardList() throws Exception &#123; return boardMapper.selectBoardList(); //③ &#125;&#125; BoardServiceImpl 클래스에는 BoardService 인터페이스를 사용하여 실제 기능을 구현한다. ① @Service는 비즈니스 로직을 처리하는 서비스 클래스를 나타내는 어노테이션이다. ② 데이터 베이스에 접근하는 DAO bean을 선언한다. ③ 사용자 요청을 처리하기 위한 비즈니스 로직을 구현한다. 여기서는 데이터를 조회하도록 BoardMapper 클래스의 selectBoardList메서드를 호출한다.","categories":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/categories/Web/"},{"name":"SpringBoot","slug":"Web/SpringBoot","permalink":"http://jung-max.github.io/categories/Web/SpringBoot/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/tags/Web/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jung-max.github.io/tags/SpringBoot/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://jung-max.github.io/tags/MariaDB/"}]},{"title":"6. SpringBoot 게시판 만들기-2","slug":"Web-6_SpringBoot-게시판만들기-2","date":"2020-06-24T06:03:16.000Z","updated":"2022-02-08T02:11:11.821Z","comments":true,"path":"2020/06/24/Web-6_SpringBoot-게시판만들기-2/","link":"","permalink":"http://jung-max.github.io/2020/06/24/Web-6_SpringBoot-게시판만들기-2/","excerpt":"","text":"롬복(Lombok) 추가롬복(Lombok)은 자바클래스를 만들 때 흔히 만드는 코드들을 어노테이션을 이용해서 자동으로 만들어 주는 라이브러리이다. 흔히 만드는 코드란 DTO와 같은 모델에서 항상 만들게 되는 getter, setter 메서드나 상황에 따라 자주 만드는 toString, equals, hashcode와 같은 메서드를 의미한다. 이클립스와 같은 IDE에서는 이를 자동으로 만들어 주기도 하지만 소스가 길어지고 클래스가 변경되면 관련된 메서드를 수정해야 하는 단점이 있다. 롬복은 단순히 어노테이션만 붙여줌으로써 어노테이션에 맞는 코드를 자동으로 생성해준다. 자동 생성되는 코드는 소스 파일에서는 확인할 수 없지만 이클립스의 Outline과 같이 메서드 리스트를 확인할 수 있는 곳에서 자동으로 생성된 메서드를 볼 수 있다. 롬복을 설치하기 위해서는 사이트에서 플러그인 다운로드가 필요하다. https://projectlombok.org/download 플러그인은 이클립스 폴더안에 저장한다.(아무곳에 저장해도 상관없다.) 다음 명령어를 사용해 롬복 인스톨러를 실행한다. java -jar C:\\Users\\u\\eclipse\\jee-2020-03\\eclipse\\plugins\\lombok.jar IDE에 이클립스를 선택하고 인스톨을 완료한다. DTO 만들기DTO는 Data Transfer Object의 약자로 VO(Value Object)와 유사한 개념으로 사용된다.(VO라고 동일한 의미로 많은 사람들이 사용한다.) 애플리케이션내의 각 계층 간 데이터를 주고받는데 사용되는 객체이다. 각 계층이란 뷰, 컨트롤러, 서비스, DAO, DB등을 의미한다. board.dto 패키지를 생성하고 BoardDto 클래스를 생성한다. BoardDto 클래스에 다음 코드를 작성한다. 123456789101112131415package com.ckbs.MariaDbTest.board.dto;import lombok.Data;@Datapublic class BoardDto &#123; private int boardIdx; private String title; private String contents; private int hitCnt; private String creatorId; private String createdDatetime; private String updaterId; private String updatedDatetime;&#125; 앞서 설명한 롬복의 어노테이션 @Data를 사용해서 모든 필드에 자주사용하는 메서드를 생성한다. 각각의 변수는 DB의 게시판 테이블의 컬럼과 매칭된다. 일반적으로 자바는 카멜 표기법을 사용하지만 DB는 _를 사용하는 스네이크 표기법을 사용한다. 카멜 표기법은 각 단어의 첫글자를 대문자로 사용해 낙타 등처럼 보이기 때문에 카멜이란 이름이 붙었다. 둘의 차이는 아래 예시를 보면 이해하기 쉽다. 카멜 표기법 : boardIdx 스네이크 표기법 : board_idx 마이바티스 설정하기위에서 말한 것 처럼 java에서는 카멜 표기법을 사용하고 DB에서는 스네이크 표기법을 사용하기 때문에 이를 위한 설정이 필요하다. java에서는 boardIdx가 DB의 board_idx와 매핑을 시켜줄 필요가 있다는 것이다. 물론 DB에서 SELECT board_idx As boardIdx와 같이 조회할 수도 있지만 모든 쿼리를 이와같이 작성하긴 힘들다. 마이바티스에서는 이러한 문제를 해결할 수 있는 기능을 제공한다. application.properties에 설정 추가application.properties에 다음 설정을 추가한다. 1mybatis.configuration.map-underscore-to-camel-case=true bean 등록앞에서 설정한 map-underscore-to-camel-case 설정값을 적용해야한다. 먼저 DatabaseConfiguration 클래스를 열고 mybatisConfig()와 sqlSessionFactoryBean.setConfiguration(mybatisConfig());코드를 추가한다. 1234567891011121314@Bean@ConfigurationProperties(prefix = \"mybatis.configuration\") //①public org.apache.ibatis.session.Configuration mybatisConfig()&#123; return new org.apache.ibatis.session.Configuration(); //②&#125;@Beanpublic SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setMapperLocations(applicationContext.getResources(\"classpath:/mapper/**/*.xml\")); sqlSessionFactoryBean.setConfiguration(mybatisConfig()); ③ return sqlSessionFactoryBean.getObject();&#125; ① @ConfigurationProperties을 통해서 application.properties에서 prefix가 mybatis.configuration인 설정을 가져온다. ② 가져온 마이바티스 설정을 자바 클래스로 만들어 반환한다. ③ 해당 설정을 sqlSessionFactory에 설정해준다.","categories":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/categories/Web/"},{"name":"SpringBoot","slug":"Web/SpringBoot","permalink":"http://jung-max.github.io/categories/Web/SpringBoot/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/tags/Web/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jung-max.github.io/tags/SpringBoot/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://jung-max.github.io/tags/MariaDB/"}]},{"title":"5. SpringBoot 게시판 만들기-1","slug":"Web-5_SpringBoot-게시판만들기-1","date":"2020-06-24T06:02:16.000Z","updated":"2022-02-08T02:11:11.821Z","comments":true,"path":"2020/06/24/Web-5_SpringBoot-게시판만들기-1/","link":"","permalink":"http://jung-max.github.io/2020/06/24/Web-5_SpringBoot-게시판만들기-1/","excerpt":"","text":"게시판은 웹개발에서 필요한 기본적인 내용이 대부분 들어가 있다. 데이터 조회, 입력, 수정, 삭제뿐만 아니라 파일 업로드 및 다운로드등 웹 프로젝트에서 필요한 다양한 기능을 포함하기 때문이다. 게시판 만들기를 통해서 스프링 MVC 구조를 이해하고 이를 토대로 프로젝트를 진행하기에 적합한 예제이다. DB 구성하기일단 본격적으로 게시판을 만들기 위해서 DB를 구성해야 한다. 지난 포스트에서 설치한 DBeaver를 통해서 DB를 구성한다. Databases에서 Create New DataBase를 선택한다. database name은 t_board로 지정하고 DB를 생성한다. 그다음엔 F3을 누르거나 메뉴의 SQL편집기 &gt; SQL 편집기를 선택한다. SQL 편집기에 아래와 같이 입력을 한다. 1234567891011CREATE TABLE t_board ( board_idx INT(11) auto_increment NOT NULL COMMENT '글 번호' primary key, title VARCHAR(300) NOT NULL COMMENT '제목', contents TEXT NOT NULL COMMENT '내용', hiit_cnt SMALLINT(10) DEFAULT 0 NOT NULL COMMENT '조회수', created_datetime DATETIME NOT NULL COMMENT '작성시간', creator_id VARCHAR(50) NOT NULL COMMENT '작성자', updated_datetime varchar(100) DEFAULT NULL NULL COMMENT '수정시간', updater_id VARCHAR(50) DEFAULT NULL NULL COMMENT '수정자', deleted_yn CHAR(1) DEFAULT 'N' NOT NULL COMMENT '삭제여부'); 작성후 우클릭 후 실행을 한다. 아래와 같이 테이블이 생성된 것을 볼 수 있다. 스타일시트(css) 추가하기화면을 깔끔하게 보여주기 위해서 css를 추가한다. 여기서는 css의 문법을 설명하는 것이 아니기 때문에 미리 작성된 css를 스프링부트 프로젝트에 추가하는 것을 중점으로 설명하겠다. src/main/resources 폴더 밑의 static 폴더에 css폴더를 생성하고 style.css 파일을 생성한다. 그 후 아래의 내용을 복사해 넣는다. 1234567891011121314151617181920212223242526272829303132333435363738394041@CHARSET \"UTF-8\";@import url(http://fonts.googleapis.com/earlyaccess/nanumgothic.css);@import url(http://cdn.jsdelivr.net/font-nanum/1.0/nanumbarungothic/nanumbarungothic.css);html&#123;overflow:scorll;&#125;html, body, div, h1, h2, a, form, table, caption, thead, tbody, tr, th, td, submit &#123; margin:0; outline:0; border:0; padding:0; font-size:100%; vertical-align:baseline; background:transparent;&#125;body &#123; font-size:0.875em; line-height:1.5; color:#666; -webkit-text-size-adjust:none; min-width:320px; font-family:'NanumGothic','나눔고딕',dotum, \"Helvetica Neue\", Helvetica, Verdana, Arial, Sans-Serief;&#125;h1, h2, h3 &#123;font-size: 1.5em;&#125;p&#123;margin:0; padding:0;&#125;ul&#123;margin:0;&#125;a:link, a:visited &#123;text-decoration:none; color: #656565;&#125;input&#123;vertical-align:middle;&#125;input:focus &#123;outline:0;&#125;caption &#123;display:none; width:0; height:0; margin-top:-1px; overflow:hidden; visibility:hidden; font-size:0; line-height:0;&#125;.container &#123;max-width:1024px; margin:30px auto;&#125;.board_list &#123;width:100%; border-top:2px solid #252525; border-bottom:1px solid #ccc; margin:15px 0; border-collapse: collapse;&#125;.board_list thead th:first-child &#123;background-image:none;&#125;.board_list thead th &#123;border-bottom:1px solid #ccc; padding:13px 0; color:#3b3a3a; text-align: center; vertical-align:middle;&#125;.board_list tbody td &#123;border-top:1px solid #ccc; padding:13px 0; text-align:center; vertical-align:middle;&#125;.board_list tbody tr:first-child td &#123;border:none;&#125;.board_list tbody tr:hover&#123;background:#ffff99;&#125;.board_list tbody td.title &#123;text-align:left; padding-left:20px;&#125;.board_list tbody td a &#123;display:inline-block&#125;.board_detail &#123;width:100%; border-top:2px solid #252525; border-bottom:1px solid #ccc; border-collapse:collapse;&#125;.board_detail tbody input &#123;width:100%;&#125;.board_detail tbody th &#123;text-align:left; background:#f7f7f7; color:#3b3a3a; vertical-align:middle; text-align: center;&#125;.board_detail tbody th, .board_detail tbody td &#123;padding:10px 15px; border-bottom:1px solid #ccc;&#125;.board_detail tbody textarea &#123;width:100%; min-height:170px&#125;.btn &#123;margin:5px; padding:5px 11px; color:#fff !important; display:inline-block; background-color:#7D7F82; vertical-align:middle; border-radius:0 !important; cursor:pointer; border:none;&#125;.btn:hover &#123;background: #6b9ab8;&#125;.file_list a &#123;display:inherit !important;&#125; 스프링부트 프로젝트에서는 css, 자바스크립트, 이미지등 정적 리소스가 static 폴더에 들어간다.","categories":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/categories/Web/"},{"name":"SpringBoot","slug":"Web/SpringBoot","permalink":"http://jung-max.github.io/categories/Web/SpringBoot/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/tags/Web/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jung-max.github.io/tags/SpringBoot/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://jung-max.github.io/tags/MariaDB/"}]},{"title":"4. SpringBoot와 MyBatis 연동","slug":"Web-4_SpringBoot-Mybatis연동","date":"2020-06-24T02:09:15.000Z","updated":"2022-02-08T02:11:11.820Z","comments":true,"path":"2020/06/24/Web-4_SpringBoot-Mybatis연동/","link":"","permalink":"http://jung-max.github.io/2020/06/24/Web-4_SpringBoot-Mybatis연동/","excerpt":"","text":"마이바티스(MyBatis)란마이바티스는 쿼리 기반 웹 애플리케이션을 개발할 때 가장 많이 사용되는 SQL Mapper 프레임워크이다. 마이바티스는 기존의 JDBC를 이용하여 개발하는 방식에 비해 개발자의 부담을 덜어 주고 생산성을 향상시켜 준다. JDBC를 이용하여 프로그래밍 하는 방식은 글래스나 JSP와 같은 코드안에 SQL문을 작성하는 방식이었다. 따라서 SQL의 변경등이 발생할 경우 프로그램을 수정해야 하기 때문에 유연성이 좋지 못하고 여러가지 코드가 복잡하게 섞여 있어서 가독성이 매우 떨어졌다. 마이바티스에서는 SQL을 XML 파일에 작성하기 때문에, SQL의 변환이 자유롭고 가독성도 좋다는 장점이 있다. 마이바티스 설정앞에서 만들었던 DatabaseConfiguration 클래스를 아래와 같이 수정한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.ckbs.MariaDbTest.configuration;import javax.sql.DataSource;import org.apache.ibatis.session.SqlSessionFactory;import org.mybatis.spring.SqlSessionFactoryBean;import org.mybatis.spring.SqlSessionTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import com.zaxxer.hikari.HikariConfig;import com.zaxxer.hikari.HikariDataSource;@Configuration@PropertySource(\"classpath:/application.properties\")public class DatabaseConfiguration &#123; @Autowired private ApplicationContext applicationContext; @Bean @ConfigurationProperties(prefix=\"spring.datasource.hikari\") public HikariConfig hikariConfig() &#123; return new HikariConfig(); &#125; @Bean(destroyMethod = \"close\") public DataSource dataSource() throws Exception &#123; DataSource dataSource = new HikariDataSource(hikariConfig());// System.out.println(dataSource.toString()); return dataSource; &#125; @Bean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSource); sqlSessionFactoryBean.setMapperLocations(applicationContext.getResources(\"classpath:/mapper/**/*.xml\")); return sqlSessionFactoryBean.getObject(); &#125; @Bean public SqlSessionTemplate sqlSessionTemplate(SqlSessionFactory sqlSessionFactory) &#123; return new SqlSessionTemplate(sqlSessionFactory); &#125;&#125; 이를 처음과 비교하면 아래와 같다. @Autowired의존 객체 자동 주입(Automatic Dependency Injection)은 스프링 설정파일에서 &lt;constructor-arg&gt; 혹은 &lt;property&gt; 태그로 의존 객체 대상을 명시하지 않아도 스프링 컨테이너가 자동적으로 의존 대상 객체를 찾아 해당 객체에 필요한 의존성을 주입하는 것을 말한다. @Autowired는 주입하려고 하는 객체의 타입이 일치하는지를 찾고 객체를 자동으로 주입한다. 만약에 타입이 존재하지 않는다면 @Autowired에 위치한 속성명이 일치하는 bean을 컨테이너에서 찾는다. 그리고 이름이 없을 경우 @Qualifier 어노테이션의 유무를 찾아 그 어노테이션이 붙은 속성에 의존성을 주입한다. 타입 =&gt; 이름 =&gt; Qualifier =&gt; Fail @Configuration을 클래스에 적용하고 @Bean을 해당 클래스의 메소드에 적용하면 @Autowired로 빈을 부를 수 있다. SqlSessionFactory마이바티스에서는 SqlSession를 생성하기 위해 SqlSessionFactory를 사용한다. SqlSessionFactory는 데이터베이스와의 연결과 SQL의 실행에 대한 모든 것을 가진 가장 중요한 객체이다. SqlSessionFactory를 생성해주는 특별한 객체를 먼저 설정해주어야하는데, 이때 스프링-마이바티스에서는 SqlSessionFactoryBean이라는 클래스를 사용한다. 만약 스프링이 아닌 마이바티스 단독으로 사용할 경우에는 SqlSessionFactoryBuilder를 사용한다. 1sqlSessionFactoryBean.setDataSource(dataSource); 에서 앞에서 만든 데이터 소스를 설정한다. 1sqlSessionFactoryBean.setMapperLocations(applicationContext.getResources(\"classpath:/mapper/**/*.xml\")); 여기에서는 마이바티스 Mapper 파일의 위치를 설정한다. Mapper는 애플리케이션에서 사용할 SQL을 담고있는 XML파일을 의미한다. 애플리케이션에는 일반적으로 많은 수의 매퍼파일이 존재하고, 이를 하나씩 등록하기 어렵기 때문에 한번에 등록하기 위해 **을 사용한다. **은 하위 폴더를 모두 뜻하고, *.xml은 xml 파일 전체를 뜻한다. SqlSessionTemplateSqlSessionTemplate은 마이바티스 스프링 연동모듈의 핵심이다. SqlSessionTemplate은 SqlSession을 구현하고 코드에서 SqlSession를 대체하는 역할을 한다. SqlSessionTemplate 은 쓰레드에 안전하고 여러개의 DAO나 매퍼에서 공유할수 있다. getMapper()에 의해 리턴된 매퍼가 가진 메서드를 포함해서 SQL을 처리하는 마이바티스 메서드를 호출할때 SqlSessionTemplate은 SqlSession이 현재의 스프링 트랜잭션에서 사용될수 있도록 보장한다. 추가적으로 SqlSessionTemplate은 필요한 시점에 세션을 닫고, 커밋하거나 롤백하는 것을 포함한 세션의 생명주기를 관리한다. 또한 마이바티스 예외를 스프링의 DataAccessException로 변환하는 작업또한 처리한다. Mapper 폴더 생성다음으로 Mapper폴더를 생성한다. Mapper 폴더는 애플리케이션에서 사용할 쿼리를 담고 있는 XML 파일을 저장한다. src/main/resources 폴더 밑에 mapper 폴더를 생성한다. 아래는 추후에 설명할 게시판에서 사용될 mapper xml의 샘플이다. 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.ckbs.MariaDbTest.board.mapper.BoardMapper\"&gt; &lt;select id=\"selectBoardList\" resultType=\"com.ckbs.MariaDbTest.board.dto.BoardDto\"&gt; &lt;![CDATA[ SELECT board_idx, title, hit_cnt, DATE_FORMAT(created_datetime, '%Y.%m.%d %H:%i:%s') AS created_datetime FROM t_board WHERE deleted_yn = 'N' ORDER BY board_idx DESC ]]&gt; &lt;/select&gt;&lt;/mapper&gt; 위와같이 XML에는 SQL에 접근할 수 있는 쿼리문이 작성되어 있다. 이에 관한 자세한 설명은 추후 다른 포스트에서 계속 한다.","categories":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/categories/Web/"},{"name":"SpringBoot","slug":"Web/SpringBoot","permalink":"http://jung-max.github.io/categories/Web/SpringBoot/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/tags/Web/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jung-max.github.io/tags/SpringBoot/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://jung-max.github.io/tags/MariaDB/"}]},{"title":"3. SpringBoot와 MariaDB 연결","slug":"Web-3_SpringBoot-MariaDb연결","date":"2020-06-24T00:24:09.000Z","updated":"2022-02-08T02:11:11.820Z","comments":true,"path":"2020/06/24/Web-3_SpringBoot-MariaDb연결/","link":"","permalink":"http://jung-max.github.io/2020/06/24/Web-3_SpringBoot-MariaDb연결/","excerpt":"","text":"이번 포스트에서는 스프링 부트와 MariaDB를 연결하는 것에 대해서 살펴본다. MariaDB 설치https://downloads.mariadb.org/로 들어가 MariaDB를 다운받는다. 설치 버전을 사용한다면 .msi / 무설치 버전은 .zip을 다운받는다. 설치시 Next를 누르고 root 계정 입력시 passworld를 설정한다. 윈도우즈 서비스로 동작하며 서비스 이름은 기본값인 “MySQL” 을 그대로 사용한다. “Enable netwokring” 을 체크한다. 포트는 기본값인 “3306”을 그대로 사용한다. 그 후 설치를 완료하고 윈도우즈 시작버튼에서 잘 설치가 되었는지 확인한다. SLQ 개발툴 DBeaverMariaDB는 자체 툴인 HeidSQL이 있지만 여기서는 DBeaver에 대해서 설명한다. 다운로드는 https://dbeaver.io/download/에서 Communuty Edition을 다운받는다. DBeaver 를 실행하면 좌측에 Database Navigator 창이 있고, 전원연결 아이콘에 마우스를 올려 놓으면 &lt;새 데이터베이스 연결&gt; 문구를 확인할 수 있다. 앞서 다운받은 MariaDB로 데이터베이스를 선택하면, Connection Settings 창이 뜬다. MariaDB 설치하며 설정한 비밀번호와 동일하게 사용자이름, 비밀번호를 입력하고 저장한다. DBeaver 메뉴 중 파일 &gt; 새로 작성 을 클릭하면 데이터베이스 연결 마법사 창이 뜬다. DataBase Navigator 에서 마우스 우클릭 &gt; Create &gt; Connection 를 해도 된다. 단축키는 Ctrl+N. 데이터베이스 MariaDB 선택 DB 정보입력 및 port 입력 후 생성 완료 Test Connection &gt; Connected SpringBoot와 MariaDB 연결스프링부트와 마리아DB를 연결하기 위한 설정이다. gradle 설정마리아 DB를 설정하기 위한 gradle을 설정한다. 여기서는 implementation group: &#39;org.mariadb.jdbc&#39;, name: &#39;mariadb-java-client&#39;, version: &#39;2.4.1&#39;을 dependencies에 넣어줌으로서 마리아DB의 설정을 한다. 123456789101112dependencies &#123; implementation 'org.springframework.boot:spring-boot-starter-thymeleaf' implementation 'org.springframework.boot:spring-boot-starter-web' implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:2.1.0' compileOnly 'org.projectlombok:lombok' developmentOnly 'org.springframework.boot:spring-boot-devtools' implementation group: 'org.mariadb.jdbc', name: 'mariadb-java-client', version: '2.4.1' annotationProcessor 'org.projectlombok:lombok' testImplementation('org.springframework.boot:spring-boot-starter-test') &#123; exclude group: 'org.junit.vintage', module: 'junit-vintage-engine' &#125;&#125; 설정 후 gradle을 우클릭 후 refesh를 잊지 않는다. application.properties 설정src/main/resources에 있는 application.properties를 설정한다. 1234spring.datasource.hikari.driver-class-name=org.mariadb.jdbc.Driverspring.datasource.hikari.jdbc-url=jdbc:mariadb://localhost:3306/t_board?characterEncoding=UTF-8&amp;serverTimezone=UTCspring.datasource.hikari.username=rootspring.datasource.hikari.password=1234 여기서 localhost:3306/t_board에서 t_board 대신 설정된 db의 이름을 적어준다. username과 password는 mariaDB에서 설정한 것을 입력한다. DatabaseConfiguration 클래스 생성메인 패키지 밑에 configuration 패키지를 생성하고 DatabaseConfiguration 클래스를 만든다. 아래 코드와 같이 작성한다. 12345678910111213141516171819202122232425262728293031package com.ckbs.MariaDbTest.configuration;import javax.sql.DataSource;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import com.zaxxer.hikari.HikariConfig;import com.zaxxer.hikari.HikariDataSource;@Configuration@PropertySource(\"classpath:/application.properties\") //①public class DatabaseConfiguration &#123; //② @Bean @ConfigurationProperties(prefix=\"spring.datasource.hikari\") public HikariConfig hikariConfig() &#123; return new HikariConfig(); &#125; //③ @Bean public DataSource dataSource() throws Exception &#123; DataSource dataSource = new HikariDataSource(hikariConfig()); System.out.println(dataSource.toString()); return dataSource; &#125;&#125; ① application.properties를 사용할 수 있도록 설정 파일의 위치를 정해 준다. classpath:/는 src/main/resources 경로를 뜻한다. @PropertySource를 추가해서 다른 설정파일도 사용할 수 있다. ② application.properties에 설정했던 데이터베이스 관련 정보를 사용하도록 지정한다. @ConfigurationProperties 어노테이션에 prefix가 spring.datasource.hikari로 설정되었기 때문에 spring.datasource.hikari로 시작하는 설정을 이용해서 히카리CP의 설정파일을 만든다. ③ 앞에서 만든 히카리CP의 설정파일을 이용해서 데이터베이스와 연결하는 데이터 소스를 생성한다. 여기서는 데이터 소스가 정상적으로 생성되었는지 확인하기 위해서 데이터 소스를 출력했다. 1232020-06-24 10:58:10.005 INFO 3588 --- [ restartedMain] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Starting...2020-06-24 10:58:10.071 INFO 3588 --- [ restartedMain] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Start completed.HikariDataSource (HikariPool-1) 위와 같이 로그가 나온다면 DB와의 연결이 제대로 된 것이다.","categories":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/categories/Web/"},{"name":"SpringBoot","slug":"Web/SpringBoot","permalink":"http://jung-max.github.io/categories/Web/SpringBoot/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/tags/Web/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jung-max.github.io/tags/SpringBoot/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://jung-max.github.io/tags/MariaDB/"}]},{"title":"2. SpringBoot 프로젝트 생성(이클립스)","slug":"Web-2_SpringBoot프로젝트생성","date":"2020-06-23T23:07:09.000Z","updated":"2022-02-08T02:11:11.820Z","comments":true,"path":"2020/06/24/Web-2_SpringBoot프로젝트생성/","link":"","permalink":"http://jung-max.github.io/2020/06/24/Web-2_SpringBoot프로젝트생성/","excerpt":"","text":"저번 시간에는 스프링부트의 개발환경 구성을 살펴보았다. 이번 포스트에서는 이클립스로 스프링부트 프로젝트를 생성하는 것을 살펴본다. 스프링 부트로 프로젝트 생성하기먼저 File &gt; New &gt; Spring starter Project를 선택하여 새 스프링 부트 프로젝트를 생성한다. 그리고 프로젝트 이름 및 패키지를 설정한다. 여기서는 프로젝트의 이름, 빌드 관리 도구 및 아티팩트, 자바 버전, 패키지등 프로젝트의 기본적인 사항들을 설정할 수 있다. 일단 빌드 관리도구는 Gradle로 선택한다. 그외는 자유롭게 설정하면 된다. Next를 특릭하면 스프링 부트 버전 및 의존성을 설정할 수 있다. 일단 여기서는 Spring Web과 Spring Boot DevTools를 선택한다. 프로젝트에 필요한 의존성을 추가하면 그레이들을 이용하여 여러가지 라이브러리들을 자동으로 다운로드하고, 그 내역이 이클립스의 콘솔창과 Progress에 표시된다. 이제 만든 프로젝트가 정상적으로 생성되있는지 확인을 위해 프로젝트를 우클릭하고 Run As &gt; Spring Boot App을 선택한다. 이클립스의 콘솔창에 로그가 출력되면 정상적으로 프로젝트가 생성된 것이다. 브라우저에서 결과를 확인해보자. 웹브라우저에서 localhost:8080을 입력한다. 스프링 부트로 프로젝트를 생성하면 프로젝트의 실행에 관련된 기능이 자동으로 설정 된다. 그렇지만 화면에 보이는 부분은 자동으로 만들어지지 않기 때문에 에러화면이 나온다. Hello World 표시눈에 보이는 결과를 위해 Hello World를 웹에 표시해 보자. 일단 메인 패키지 밑에 controller 패키지를 생성한다. 메인 패키지에서 우클릭 후 New &gt; Package를 선택한다. Name 끝에 .controller를 입력 후 패키지를 생성한다. 그 후 HelloWorldController 클래스 생성한다. 다음과 같은 코드를 작성한다. 12345678910111213package com.ckbs.MariaDbTest.controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloWorldController &#123; @RequestMapping(\"/\") public String hello() &#123; return \"Hello World!\"; &#125;&#125; @RestController 어노테이션을 이용하여 해당 클래스가 REST 컨트롤러 기능을 수행하도록 한다. @RequestMapping 어노테이션은 해당 메서드를 실행할 수 있는 주소를 설정한다. 여기서는 애플리케이션의 기본 주소를 /로 지정했다. 실행시 앞서 실행시킨 것이 있기 때문에 중지 후 다시 시작해야 한다. 이는 메뉴에서 확인할 수 있다. 이후 localhost:8080 입력 시 Hello World!가 출력된 화면을 볼 수 있다.","categories":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/categories/Web/"},{"name":"SpringBoot","slug":"Web/SpringBoot","permalink":"http://jung-max.github.io/categories/Web/SpringBoot/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/tags/Web/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jung-max.github.io/tags/SpringBoot/"}]},{"title":"1. SpringBoot 개발환경 구성(이클립스)","slug":"Web-1_SpringBoot-환경설정","date":"2020-06-22T23:37:11.000Z","updated":"2022-02-08T02:11:11.819Z","comments":true,"path":"2020/06/23/Web-1_SpringBoot-환경설정/","link":"","permalink":"http://jung-max.github.io/2020/06/23/Web-1_SpringBoot-환경설정/","excerpt":"","text":"스프링부트를 처음 시작하기 위한 개발환경 구성에 대해서 설명한다. JDK 설치Spring Boot를 사용하기 위해서는 JDK 설치가 선행되어야 한다. 요즘은 오라클의 정책으로 인해서 OpenJDK가 권장된다. https://github.com/ojdkbuild/ojdkbuild에서 자신의 컴퓨터와 맞는 jdk를 다운받아 설치한다. 위와같이 자바 버전이 확인된다면 설치가 성공된 것이다. 이클립스 설치스프링부트를 사용하기 위한 IDE로서는 IntelliJ IDEA가 가장 좋다고 말한다. 하지만 구독료가 있기 때문에 여기서는 이클립스에 대해서 설명한다. 아래 링크에서 이클립스를 다운받는다. https://www.eclipse.org/downloads/ 설치시 스프링 프레임워크를 사용하기 위해서 JaveEE(Java Plaform, Enterprise Edition)을 설치한다. 플러그인 설치STS(Spiring Tool Suite)는 스프링 어플리케이션 개발을 위한 이클립스 기반의 개발환경이다. 이클립스 상단 메뉴중 Help &gt; Eclipse Marketplace…을 선택한다. Find 창에서 STS를 검색한다. 마켓플레이스 목록에서 최신 버전의 STS를 설치한다. STS 설치시 모든 기능을 선택 후 설치하면 된다. Gradle 설치라이브러리 관리를 위한 Gradle을 설치한다. 라이브러리 관리는 크게 Maven과 Gradle이 있지만 여기서는 Gradle을 중심으로 설명한다. 그 이유는 메이븐의 경우 xml로 이루어져 있어 사람이 알아보기는 쉽지만 라이브러리가 추가되거나 각각의 라이브러리가 서로 다른 버전의 라이브러리를 참조하는 종속성을 가지고 있을 경우에는 관리가 어려워지는 문제가 있다. 위에서 STS를 설치한 것처럼 마켓플레이스에서 gradle을 검색해 설치한다. 이미 설치가 되있다면 넘어가도 좋다. Gradle을 설치했다면 거기에 맞는 에디터 또한 설치한다. 여기서는 Minimalist Gradle Editor를 설치한다. 설치 후 그레이들 파일을 연결한다. 상단 메뉴에서 Windows &gt; Preferences를 선택하고 General &gt; Editors &gt; File Associations 메뉴에서 *.gradle을 찾아서 Minimalist Gradle Editor을 Defauilt로 선택한다. 이클립스 메뉴 변경아래는 필자가 추천하는 메뉴 구성 변경에 대해서 설명한다. Customize Perspective 변경하기Windows &gt; Preferences &gt; Customize Perspective를 선택한다. Shortcuts 메뉴에서 아래와 같이 선택한다. 패키지 보여주기 변경하기패키지의 계층 구조를 한눈에 파악하기 위해 패키지 보여주기 방법을 변경한다. Project Explorer에 ∨ 버튼을 누른 후 Package Presentation &gt; Hierarchical을 선택한다. 이클립스 뷰 변경하기소스코드외 여러 필요한 정보를 보기 위한 화면 구성이다. Windows &gt; Show View &gt; Other…를 선택한다. Console, Problems, Progress, Search, History, Package Explorer을 추가하고 사용하지 않는 메뉴는 삭제한다. Package Explorer는 Project Explorer뷰 옆으로 이동한다. 프로젝트 인코딩 설정하기한글등 여러 문제 발생을 피하기 위해서 UTF-8로 인코딩을 설정한다. Windows &gt; Preferences를 선택한 후 General &gt; Workspace를 선택한다. Text file encoding을 UTF-8로 변경한 후 OK를 누른다. 테마 변경하기(다크 테마)이클립스 상단 메뉴중 Help &gt; Eclipse Marketplace…을 선택한다. Find 창에서 Dark Theme를 검색한다. 해당 플러그인을 인스톨 후 재시작하면 다크 테마를 적용할 수 있다. 또한 클래식 또는 화이트 테마 역시 선택 가능하다. 추후 테마를 변경하고 싶다면 Windows &gt; Preferences를 선택한 후 DevStyle에서 Color Themes에서 변경 가능하다.","categories":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/categories/Web/"},{"name":"SpringBoot","slug":"Web/SpringBoot","permalink":"http://jung-max.github.io/categories/Web/SpringBoot/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/tags/Web/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jung-max.github.io/tags/SpringBoot/"}]},{"title":"python pyqt5 이미지 클릭","slug":"Python-pyqt5-이미지클릭","date":"2020-06-16T03:36:22.000Z","updated":"2022-02-08T02:11:11.817Z","comments":true,"path":"2020/06/16/Python-pyqt5-이미지클릭/","link":"","permalink":"http://jung-max.github.io/2020/06/16/Python-pyqt5-이미지클릭/","excerpt":"","text":"개요pyqt5에서 이미지는 QPixmap의 라이브러리를 사용한다. 하지만 해당 라이브러리로 이미지를 불러온다면 클릭시 연결 함수를 제공하지 않는다. 클릭을 가능하게 하려면 몇가지 수정이 필요하다. 이미지 로드아래와 같이 로드가 가능합니다. 12345678910111213141516171819202122232425262728293031from PyQt5.QtGui import *import os# 현재 폴더에 현재 날짜의 폴더 이름 만들기folderName = os.getcwd() + '\\\\' + str(time.localtime().tm_year) + '_' + str(time.localtime().tm_mon) + '_' + str( time.localtime().tm_mday)# 폴더 생성try: if not (os.path.isdir(folder_name)): os.makedirs(os.path.join(folder_name))except OSError as e: print(e)# 폴더에 있는 파일 리스트를 불러옴file_list = os.listdir(folder_name)if len(file_list) &gt; 0: png_list = [] # 그림파일 확장자 명만 찾아서 리스트에 추가 for file_name in file_list: if (file_name.find('.png') == len(file_name)-4) or (file_name.find('.jpg') == len(file_name)-4): png_list.append(file_name) # 그림파일을 하나씩 로드함 if len(png_list) &gt; 0: for png_file in png_list: pixmap = QPixmap(folder_name+'\\\\'+png_file) png_path = folder_name+'\\\\'+png_file PNG_LIST.append(png_path) 위 코드는 현재 날짜의 폴더를 생성하고 폴더안에 있는 그림파일을 하나씩 로드하는 코드입니다. 이미지 clickablepixmap을 만들었다면 해당 변수를 clickable로 만들어야 합니다. 1234567891011121314151617181920212223242526lbl_img = QLabel()clickable(lbl_img).connect(self.pictureListClicked)lbl_img.setAlignment(Qt.AlignCenter)lbl_img.setPixmap(pixmap)def clickable(widget):global FILE_LIST class Filter(QObject): clicked = pyqtSignal() def eventFilter(self, obj, event): if obj == widget: if event.type() == QEvent.MouseButtonRelease: if obj.rect().contains(event.pos()): self.clicked.emit() # The developer can opt for .emit(obj) to get the object within the slot. return True return False filter = Filter(widget) widget.installEventFilter(filter) FILE_LIST.append(filter) return filter.clicked 위 코드는 MouseButtonRelease 이벤트 발생시 signal을 보냄으로서 연결된 함수를 호출하는 코드입니다. 위 코드에서 글로벌 변수인 FILE_LIST에 filter를 추가한 것은 추후 연결된 함수에서 누가 보냈는지 구분하기 위함입니다. self.clicked.emit()에서 obj를 보내 구분도 가능할꺼 같지만 테스트 해보지는 않았습니다. 이미지 클릭시 함수에서 이미지 구분위 코드에서 여러 이미지의 파일을 반복문으로 부르고 한개의 함수에 이를 연결하고 있습니다. 이럴때 문제는 모든 이미지 클릭시 같은 동작을 실행한다는 것입니다. 이를 방지하기 위해서 위에서 저장했던 FILE_LIST를 이용했습니다. 1234567891011def pictureListClicked(self): global FILE_LIST global PNG_LIST png_path = '' for i, object_name in enumerate(FILE_LIST): if object_name == self.sender(): png_path = PNG_LIST[i] if png_path != '': self.grid.addWidget(self.pictureShowGroup(png_path), 0, 2, 9, 8) self.update() 원리는 sender를 이용해 클릭된 이미지의 순서를 알아내고 따로 저장된 PNG_LIST로 해당 파일을 불러와 그 이미지를 가지고 다른 위젯에 표시하는 함수입니다.","categories":[{"name":"python","slug":"python","permalink":"http://jung-max.github.io/categories/python/"},{"name":"GUI","slug":"python/GUI","permalink":"http://jung-max.github.io/categories/python/GUI/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jung-max.github.io/tags/python/"},{"name":"pyqt5","slug":"pyqt5","permalink":"http://jung-max.github.io/tags/pyqt5/"},{"name":"gui","slug":"gui","permalink":"http://jung-max.github.io/tags/gui/"}]},{"title":"Python-pip3 인스톨시 SSL에러","slug":"Python-pip3 인스톨시 SSL에러","date":"2020-06-15T06:03:09.000Z","updated":"2022-02-08T02:11:11.817Z","comments":true,"path":"2020/06/15/Python-pip3 인스톨시 SSL에러/","link":"","permalink":"http://jung-max.github.io/2020/06/15/Python-pip3 인스톨시 SSL에러/","excerpt":"","text":"파이썬으로 pip install시 SSL 관련 에러로 설치가 불가능할때가 있다. 그럴때 아래과 같이 입력하면 설치가 가능하다. 아래와 같이 입력해도 주황색으로 에러같은게 뜰 수 있다. 일단 기다리면 설치가 완료되니 기다리자. python21pip install --trusted-host pypi.org --trusted-host files.pythonhosted.org &lt;package_name&gt; python31pip3 install --trusted-host pypi.org --trusted-host files.pythonhosted.org &lt;package_name&gt;","categories":[{"name":"python","slug":"python","permalink":"http://jung-max.github.io/categories/python/"},{"name":"setting","slug":"python/setting","permalink":"http://jung-max.github.io/categories/python/setting/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jung-max.github.io/tags/python/"}]},{"title":"python 시리얼 통신 - 라즈베리파이4(raspberry pi 4)와 PC간 usb 시리얼 통신","slug":"Python-serial","date":"2020-06-15T06:03:09.000Z","updated":"2022-02-09T04:53:25.654Z","comments":true,"path":"2020/06/15/Python-serial/","link":"","permalink":"http://jung-max.github.io/2020/06/15/Python-serial/","excerpt":"","text":"개요라즈베리 파이4와 PC간에 USB 통신에 대한 방법에 대해서 살펴보겠다.(파이썬을 이용) 라즈베리 파이4는 이전 버전과는 달리 USB-C포트를 이용해서 USB to serial을 사용할 수 있다. 이는 기존에는 라즈베리파이 제로에만 있던 기능이다. 라즈베리 파이 4 USB Gadget Mode라즈베리 파이4는 라즈베리파이 제로와 같은 방법으로 USB to serial을 사용할 수 있다. 라즈베리 파이4의 USB-C 포트는 기본적으로 전원으로 사용하지만 해당 포트를 PC에 연결함으로서 USB를 사용한 여러가지 방법으로 사용할 수 있다. USB Gadget Mode를 사용하기 위한 셋팅은 아래와 같다. 1. config.txt 파일 수정boot/config.txt파일을 수정한다. 해당 파일의 마지막에 아래의 내용을 추가한다. 1dtoverlay=dwc2 2. modules 파일 수정/etc/modules파일을 수정한다. 해당 파일에 아래와 같이 추가한다. 12dwc2g_serial 시리얼을 콘솔로 사용하고 싶다면커맨드창에 sudo systemctl enable getty@ttyGS0.service을 입력한다. 기타 모듈시리얼 말고도 여러가지 방법으로 USB Gadget Mode를 사용 가능하다. 가능한 리스트는 아래와 같다. Serial (g_serial) Ethernet (g_ether) Mass storage (g_mass_storage) MIDI (g_midi) Audio (g_audio) Keyboard/Mouse (g_hid) Mass storage and Serial (g_acm_ms) Ethernet and Serial (g_cdc) Multi (g_multi) - Allows you to configure 2 from Ethernet, Mass storage and SerialIn addition to the above modules, a few other (less useful) modules are included. Webcam (g_webcam) Printer (g_printer) Gadget tester (g_zero) 더 자세한 내용은 아래 링크를 참조한다. https://gist.github.com/gbaman/50b6cca61dd1c3f88f41 pyserial파이썬에서 시리얼을 사용하기 위해선 pyserial을 사용한다. 인스톨은 아래와 같다. 1pip install pyserial pyserial을 사용하기 위해서 import는 다음과 같이 한다. 1import serial pyserial 접속라즈베리파이4에서 USB Gadget Mode로 연결하였다면 장치 파일은 /dev/ttyGS0이 된다. 아래와 같이 접속을 한다. 12345# 리눅스SER = serial.Serial('/dev/ttyGS0', 115200)# windowsSER = serial.Serial('COM-14', 115200) 첫번째 파라미터는 장치 파일을 뜻한다. window에서 사용한다면 ‘COM-14’와 같이 사용한다. 두번째 파라미터는 속도를 뜻한다. 시리얼 통신시 양측 모두 속도가 같아야 정상적으로 통신이 가능하다. 해당 PC 또는 라즈베리 파이에서 연결되어 있는 포트 또는 장치 파일을 찾는 것은 다음과 같이 가능하다. 123456789101112131415161718192021222324252627def serial_ports(self): \"\"\" Lists serial port names :raises EnvironmentError: On unsupported or unknown platforms :returns: A list of the serial ports available on the system \"\"\" if sys.platform.startswith('win'): ports = ['COM%s' % (i + 1) for i in range(256)] elif sys.platform.startswith('linux') or sys.platform.startswith('cygwin'): # this excludes your current terminal \"/dev/tty\" ports = glob.glob('/dev/tty[A-Za-z]*') elif sys.platform.startswith('darwin'): ports = glob.glob('/dev/tty.*') else: raise EnvironmentError('Unsupported platform') result = [] for port in ports: try: s = serial.Serial(port) s.close() result.append(port) except (OSError, serial.SerialException): pass return result pyserial 쓰기 및 읽기쓰기 및 읽기는 다음과 같이 사용한다. 12345# 읽기c = SER.read()# 쓰기SER.write(data) 읽고 쓰는 것은 간단하지만 시리얼 통신은 모두 byte로 이루어지기 때문에 변환이 필요하다. str 변환 방법파이썬에서 문자열을 바이트로 바꾸는 것은 아래와 같이 이루어진다. 1abc_str = b'abcd' 특정 문자열을 읽고 싶을때는 아래와 같이 사용하면 된다. 1234567891011LINE = bytearray() #라인 단위로 데이터 가져올 리스트 변수for c in ser.read(): #line 변수에 차곡차곡 추가하여 넣는다. LINE.append(c) byte_line = bytes(LINE) if byte_line.find(b'abcd') != -1: print(\"abcd = True\") LINE.clear() ser.flushInput() 읽은 문자열을 str 형식으로 변경하고 싶으면 아래와 같이 사용한다. 12345678910LINE = bytearray()for c in ser.read(): LINE.append(c) byte_line = bytes(LINE) if byte_line.find(b'abcd') != -1: str_decoded = byte_line.decode('ascii') LINE.clear() ser.flushInput() 반대로 특정 문자열을 쓰고 싶을때는 아래와 같이 사용한다. 12msg = abcdSER.write(msg.encode()) 위에서 encode 대신 b를 붙여 사용해도 된다. int 변환 방법int를 변경하기 위해서는 int.from_bytes() 와 int.to_bytes()를 사용한다. 12345# int → byte 변환foc_val = int.to_bytes(self.foc_slider.value(), length=len(str(self.foc_slider.value())), byteorder='big')# byte → int 변환foc_val_int = int.from_bytes(foc_val, byteorder='big')","categories":[{"name":"python","slug":"python","permalink":"http://jung-max.github.io/categories/python/"},{"name":"통신","slug":"python/통신","permalink":"http://jung-max.github.io/categories/python/통신/"}],"tags":[{"name":"python","slug":"python","permalink":"http://jung-max.github.io/tags/python/"},{"name":"serial","slug":"serial","permalink":"http://jung-max.github.io/tags/serial/"}]},{"title":"openCv page Dewarp 그림책인지 텍스트 책인지 구분 방법","slug":"opencv-PageDewarping-그림책-텍스트책-구분방법","date":"2020-04-29T06:58:29.000Z","updated":"2022-02-08T02:11:11.816Z","comments":true,"path":"2020/04/29/opencv-PageDewarping-그림책-텍스트책-구분방법/","link":"","permalink":"http://jung-max.github.io/2020/04/29/opencv-PageDewarping-그림책-텍스트책-구분방법/","excerpt":"","text":"개요현재의 이미지 처리 방식은 text을 기준으로 책을 피는 알고리즘을 사용하였습니다. 하지만 그림책의 경우에는 글자가 부족하고 그림의 특정부분을 윤곽선으로 인식하여 책을 제대로 펴지 못합니다. 그렇기 때문에 텍스트 기반의 책이 이미지와 그림 기반의 책의 이미지의 처리방식은 달라져야 합니다. 일단 이 포스트에서는 이미지가 텍스트 기반인지 그림 기반인지 어떻게 구분할까에 대해서 살펴보겠습니다. 색 분포 분석가장 처음으로 색에 대해서 분석해볼 가치가 있다고 생각했습니다. 보통 텍스트 기반의 책은 흰바탕에 검은색 텍스트를 가지고 있습니다. 그림 기반의 책은 어떤 색이 나올지 모릅니다. 그렇기 때문에 일정 이상의 흰색, 회색 계열의 색이 이미지에 많이 존재한다면 텍스트 기반의 책으로 볼수 있지 않을까 생각했습니다. 아래 코드는 k-means clustering 을 적용하여 이미지의 가장 대표적인 색상을 가진 팔레트를 만드는 예제입니다. 12345678910111213141516171819202122232425262728293031import matplotlib.pyplot as pltaverage = img.mean(axis=0).mean(axis=0)pixels = np.float32(img.reshape(-1, 3))n_colors = 5criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 200, .1)flags = cv2.KMEANS_RANDOM_CENTERS_, labels, palette = cv2.kmeans(pixels, n_colors, None, criteria, 10, flags)_, counts = np.unique(labels, return_counts=True)avg_patch = np.ones(shape=img.shape, dtype=np.uint8)*np.uint8(average)indices = np.argsort(counts)[::-1]freqs = np.cumsum(np.hstack([[0], counts[indices]/counts.sum()]))rows = np.int_(img.shape[0]*freqs)dom_patch = np.zeros(shape=img.shape, dtype=np.uint8)for i in range(len(rows) - 1): dom_patch[rows[i]:rows[i + 1], :, :] += np.uint8(palette[indices[i]])fig, (ax0, ax1) = plt.subplots(1, 2, figsize=(12,6))ax0.imshow(avg_patch)ax0.set_title('Average color')ax0.axis('off')ax1.imshow(dom_patch)ax1.set_title('Dominant colors')ax1.axis('off')plt.show(fig) 위 예제에서 팔레트를 분석하면 배경이 되는 검정색이 제일 많이 분포하는 것을 알 수 있습니다. 나머지 색상을 보면 회색빛으로 책의 색이 분포되고 있습니다. 이에 착안하여 2~4번째 색상이 회색빛인 (140,140,140) 이상이 되는 색으로 분포된다면 텍스트라고 판단할 수 있다고 생각했습니다. 12345img_paint = Falsefor i in range(3): if np.all(palette[indices[i+1]] &lt; 140): img_paint = True 가로줄 윤곽선 분포또하나의 기법으로는 책의 윤곽선의 갯수를 판별하는 것입니다. Page dewarping gitHub 위 소스에서 쓰인 함수를 바탕으로 아래와 같이 구성해 보았습니다. 123456789101112def text_mask(small): name = 'mask_temp' spans = [] height, width = small.shape[:2] pagemask = np.zeros((height, width), dtype=np.uint8) cv2.rectangle(pagemask, (0, 0), (width, height), (255, 255, 255), -1) cinfo_list = get_contours(name, small, pagemask, 'text') spans_text = assemble_spans(name, small, pagemask, cinfo_list) return len(spans_text) 위 코드 처럼 page dewarping에 쓰인 함수를 활용해서 몇개의 윤곽선을 탐지했는지 판단할 수 있습니다. 결론저의 경우는 위에서 판별한 평균 색상과 윤곽선의 갯수 두가지를 혼합하여 판별을 해보았습니다. 123456if tmp_len &lt; 15 and img_paint == True: IMAGE_TYPE = 'paint'elif tmp_len &lt; 3: IMAGE_TYPE = 'paint'else: IMAGE_TYPE = 'text' 윤곽선 갯수가 15개 미만이고 색상 판별에서 그림이라고 판별하면 그림이라고 판단했습니다. 색상에서 텍스트라고 판별했지만 윤곽선이 3개 미만이면 역시 그림이라고 판별했습니다. 두가지 모두 해당되지 않는다면 텍스트라고 판별했습니다. 아직까지는 샘플에서는 상당한 정확도를 보여주고 있습니다. 여러 테스트를 해보고 좀더 보완을 해볼 수 있는 방안을 생각해 봐야겠습니다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"openCv page Dewarp remapping을 이용한 가장자리 보정","slug":"openCV-pageDewarp-remapping을이용한-보정","date":"2020-04-29T01:42:48.000Z","updated":"2022-02-08T02:11:11.814Z","comments":true,"path":"2020/04/29/openCV-pageDewarp-remapping을이용한-보정/","link":"","permalink":"http://jung-max.github.io/2020/04/29/openCV-pageDewarp-remapping을이용한-보정/","excerpt":"","text":"개요저번 포스트에서는 remapping이 어떻게 이루어 지는가와 사다리꼴 결과물 보정에 대해서 분석해 보았습니다. 사다리꼴 결과물 보정에서는 가장자리의 선을 찾아 그 끝점으로 이미지를 와핑하는 방법을 사용하였습니다. 하지만 아래와 같이 그림책의 경우에는 선이 너무 많고 가장자리의 선을 못찾는 경우가 발생하였습니다. 이미지 보정 전을 보면 눈으로는 가장자리 선을 확인할 수 있습니다. 하지만 정작 선찾기를 해보면 쓸대 없는 선을 매우 많이 찾습니다. 특히 우리가 원하는 오른쪽 가장자리 선은 찾지 못하고 다른 엉뚱한 세로선의 모습을 볼 수 있습니다. 결국 이상한 선을 기준으로 자른 결과 오른쪽 내용의 상당수가 소실된채 이미지 와핑이 되게 됩니다. 그렇기 때문에 선찾기로는 한계가 있을 수 밖에 없습니다. 그래서 remapping시 이미지가 벗어나는 부분을 찾아서 이미지 와핑의 기준을 잡기로 했습니다. 이미지 영역을 벗어나는 곳 찾기이미지의 원본 소스를 img라고 합니다. 그러면 원본 소스의 넓이(x축)과 높이(y축)은 다음과 같습니다. 1height, width = img.shape[:2] 원본 소스의 remap 함수는 다음과 같이 쓰였습니다. 123remapped = cv2.remap(img, image_x_coords, image_y_coords, cv2.INTER_CUBIC, None, cv2.BORDER_REPLICATE) 우리는 x축에 관심이 있기 때문에 image_x_coords를 사용해서 이미지 영역 밖을 찾습니다. 이미지 영역을 찾기 위해선 numpy의 특정 요소를 찾는 np.where을 아래와 같이 써줍니다. 12corners_x1 = np.where(image_x_coords[0,:].astype(int) ==img.shape[1])corners_x2 = np.where(image_x_coords[height-1,:].astype(int) ==img.shape[1]) 해당 소스의 뜻은 corners_x1은 image_x_coords에서 y가 0인 x의 값과 원본 이미지의 넓이와 같은 좌표를 찾는 것입니다.corners_x2는 마찬가지로 y값이 remapping된 이미지의 높이일때 x의 값과 원본 이미지의 넓이와 같은 좌표를 찾는 것입니다. 이를 그림으로 표현하면 아래와 같습니다. 앞서 remapping 관련 포스트에서 설명한 것 처럼 image_x_coords에는 원본 소스의 좌표가 들어 있기 때문에 그 좌표와 같은 값이 remapped 이미지의 어느 좌표와 매칭되는 가를 찾는 것입니다. np.where의 결과는 tuple로 한번 감싸져 있습니다. 123print(\"corners_x1 = \", corners_x1)corners_x1 = (array([1249, 1250], dtype=int32),) 그렇기 때문에 결과의 가장 첫번째 값을 찾기 위해선 corners_x1[0][0]와 같이 써주면 됩니다. 위에서 corners_x1[0][0]을 해주면 1249의 값을 찾을 수 있습니다. 여기서 1249는 remapped된 이미지의 x값 좌표가 1249라는 의미입니다. corners_x2는 다음과 같습니다. corners_x2 = (array([1478, 1479, 1480], dtype=int32),) 위 결과를 그림으로 표현하면 아래와 같습니다. 만약 np.where의 값이 없다면 아래와 같이 리턴됩니다. corners_x1 = (array([], dtype=int32),) 이 값을 체크하기 위해서는 일단 np.where의 리턴은 tuple로 감싸있으므로 if corners_x1[0].size == 0 과 같이 체크할 수 있습니다. 이미지 펴기이제 이미지를 펴기 위해 4점을 특정해 줍니다. 여기서는 책의 왼쪽 페이지로 우측에 이미지의 손실이 일어난다고 가정합니다. 12345topLeft = [0,0]bottomLeft = [0, height]topRight = [corners_x1[0][0], 0]bottomRight = [corners_x2[0][0], height]src_pts = np.float32([topLeft, topRight, bottomLeft, bottomRight]) 이미지의 좌측은 원래 이미지의 기준인 (0,0), (0,height)로 잡았습니다. 우측은 우리가 구한 값인 (corners_x1[0][0], 0), (corners_x2[0][0], height)을 기준으로 잡았습니다. 이제 4점을 기준으로 펴주는 작업입니다. 12345678if corners_x1[0][0] &gt;= corners_x2[0][0]: dst_pts = np.float32([[0,0], [corners_x1[0][0],0], [0, height], [corners_x1[0][0], height]]) M = cv2.getPerspectiveTransform(src_pts, dst_pts) src = cv2.warpPerspective(src, M, (corners_x1[0][0], height))else: dst_pts = np.float32([[0,0], [corners_x2[0][0],0], [0, height], [corners_x2[0][0], height]]) M = cv2.getPerspectiveTransform(src_pts, dst_pts) src = cv2.warpPerspective(src, M, (corners_x2[0][0], height)) 구한 두 점중 더 긴 곳을 기준으로 이미지 펴기를 하였습니다. 해당 결과는 아래와 같습니다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"openCv page Dewarp remapping 분석","slug":"openCV-pageDewarp-remapping","date":"2020-04-23T01:58:59.000Z","updated":"2022-02-08T02:11:11.814Z","comments":true,"path":"2020/04/23/openCV-pageDewarp-remapping/","link":"","permalink":"http://jung-max.github.io/2020/04/23/openCV-pageDewarp-remapping/","excerpt":"","text":"개요해당 작업은 최적화 작업 후 기울기 α, β를 취득 한 후 어떻게 이미지가 remmaping 되는가에 대한 설명이다. get_page_dimsget_page_dims 전체 소스12345678910111213141516def get_page_dims(corners, rough_dims, params): dst_br = corners[2].flatten() dims = np.array(rough_dims) def objective(dims): proj_br = project_xy(dims, params) return np.sum((dst_br - proj_br.flatten())**2) res = scipy.optimize.minimize(objective, dims, method='Powell') dims = res.x print (\"got page dims\", dims[0], 'x', dims[1]) return dims get_page_dims 분석input parameter는 다음과 같다. corners : PCA를 통해 결정된 remapping될 이미지의 4개의 꼭지점의 좌표. debugmode에서 붉은 사각형으로 표시된다. rough_dims : corners의 넓이와 높이 값 params : 최적화를 통해 기울기 α, β값등이 들어있는 리스트 해당 작업의 진행은 아래와 같다. 12345def objective(dims): proj_br = project_xy(dims, params) return np.sum((dst_br - proj_br.flatten())**2)res = scipy.optimize.minimize(objective, dims, method='Powell') proj_br = project_xy(dims, params)dims(이미지를 만들 4개의 꼭지점 좌표)를 최적화를 통해 구한 α, β를 이용해 재투영하여 2D 좌표를 얻는다. scipy.optimize.minimize(objective, dims, method=’Powell’)4개의 꼭지점에 대해서 재투영된 좌표와 원래의 좌표를 비교한다. 비교 후 재투영 오류가 가장 작은 꼭지점의 좌표를 찾는다. 최종적으로 재투영 오류가 가장 적은 dims(넓이, 높이)값을 찾는 것이 목표이다. remap_imageremap_image 전체 소스12345678910111213141516171819202122232425262728293031323334353637383940def remap_image(name, img, small, page_dims, params): height = 0.5 * page_dims[1] * OUTPUT_ZOOM * img.shape[0] height = round_nearest_multiple(height, REMAP_DECIMATE) width = round_nearest_multiple(height * page_dims[0] / page_dims[1], REMAP_DECIMATE) print ' output will be &#123;&#125;x&#123;&#125;'.format(width, height) height_small = height / REMAP_DECIMATE width_small = width / REMAP_DECIMATE page_x_range = np.linspace(0, page_dims[0], width_small) page_y_range = np.linspace(0, page_dims[1], height_small) page_x_coords, page_y_coords = np.meshgrid(page_x_range, page_y_range) page_xy_coords = np.hstack((page_x_coords.flatten().reshape((-1, 1)), page_y_coords.flatten().reshape((-1, 1)))) page_xy_coords = page_xy_coords.astype(np.float32) image_points = project_xy(page_xy_coords, params) image_points = norm2pix(img.shape, image_points, False) image_x_coords = image_points[:, 0, 0].reshape(page_x_coords.shape) image_y_coords = image_points[:, 0, 1].reshape(page_y_coords.shape) image_x_coords = cv2.resize(image_x_coords, (width, height), interpolation=cv2.INTER_CUBIC) image_y_coords = cv2.resize(image_y_coords, (width, height), interpolation=cv2.INTER_CUBIC) img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) remapped = cv2.remap(img_gray, image_x_coords, image_y_coords, cv2.INTER_CUBIC, None, cv2.BORDER_REPLICATE) remap_image 분석height = 0.5 * page_dims[1] * OUTPUT_ZOOM * img.shape[0]여기서 page_dims[1]의 값은 remapping될 이미지의 높이의 값이다. 여기서 값은 픽셀이 아닌 scl = 2.0/(max(height, width))을 나눈 값으로 대략 1.x의 값을 가진다. 해당 값(비율)과 원래의 이미지 높이를 곱하고 2를 나누어줘 높이를 구한다. height = round_nearest_multiple(height, REMAP_DECIMATE)높이를 다운 스케일링을 위한 요소의 배수와 가장 가까운 값으로 올림한다. 다운스케일링시 나머지가 생기지 않도록 하기 위해서다. width = round_nearest_multiple(height * page_dims[0] / page_dims[1], REMAP_DECIMATE)넓이는 높이를 구했으므로 앞서 구한 리맵핑될 이미지의 넓이와 높이의 비를 곱해 간단히 구한다. 여기서도 다운스케일링을 위한 올림을 한다. np.linspace12345height_small = height // REMAP_DECIMATEwidth_small = width // REMAP_DECIMATEpage_x_range = np.linspace(0, page_dims[0], width_small)page_y_range = np.linspace(0, page_dims[1], height_small) 다운스케일링을 한 높이와 넓이를 구한다. 기본 REMAP_DECIMATE의 값은 16이다. np.linspace는 등간격을 뜻한다. numpy.linspace(start, end, num=개수, endpoint=True, retstep=False, dtype=자료형)을 사용하여 start ~ end 사이의 값을 개수만큼 생성하여 배열로 반환한다. endpoint가 True일 경우 end의 값이 마지막 값이 되며, False일 경우 end의 값을 마지막 값으로 사용하지 않는다. retstep이 True일 경우 값들의 간격을 배열에 포함된다. page_x_coords, page_y_coords = np.meshgrid(page_x_range, page_y_range)numpy의 meshgrid 명령을 통해 행단위와 열단위로 각각 해당 배열을 정방(square) 행렬로 선언한다. page_x_range.shape = (102,), page_y_range.shape = (170,)라면 page_x_coords.shape = (170, 102), page_y_coords.shape = (170, 102)의 형태로 변경시켜준다. np.hstack1234567page_x_coords.flatten().reshape((-1, 1)) = [[0. ] [0.00928807] [0.01857613] ... [0.91951848] [0.92880654] [0.93809461]] 형태 변환을 통해 위와 같은 형태로 변경시켜 준다. np.hstack은 배열을 위에서 아래로 붙이는 작업이다. 해당 작업의 결과물은 아래와 같다. 1234567page_xy_coords = [[0. 0. ] [0.00928807 0. ] [0.01857613 0. ] ... [0.91951848 1.57070085] [0.92880654 1.57070085] [0.93809461 1.57070085]] image_points 취득12image_points = project_xy(page_xy_coords, params)image_points = norm2pix(img.shape, image_points, False) 이제 위에서 얻은 좌표를 통해 재투영 작업을 한다. 재투영한 값은 norm의 값이므로 norm2pix 함수를 통해 실제 좌표로 변경한다. 이를 그림으로 표현하면 아래와 같다. 위 그림에서 초록색 점은 page_xy_coords의 좌표를 표현한 것이다. 개념 설명을 위한 것으로 점의 갯수는 무시한다. 점의 간격은 높이는 height_small, 넓이는 width_small만큼 떨어져 있다. 이 좌표는 결과물의 좌표를 표시하기 위한것이다. 그러므로 좌측 상단의 좌표는 (0,0), 우측하단은 (page_dims[0], page_dims[1])의 좌표로 매칭된다. 결과적으로 remapping을 위한 좌표 표시를 위한 행렬을 만든 결과가 page_xy_coords인 것이다. 여기서 page의 기준점 (0,0)의 좌표가 어디서 결정되는지 보면 main()함수에 아래와 같은 소스가 존재한다. 12dstpoints = np.vstack((corners[0].reshape((1, 1, 2)),) + tuple(span_points)) 여기서 coners[0]은 page_dims의 좌측 상단 좌표이다. 이점을 span point의 가장 처음에 넣고 해당 점의 포인트가 (0,0)으로 매칭되서 최적화 되도록 아래 함수에서 설정한다. 123456def project_keypoints(pvec, keypoint_index): xy_coords = pvec[keypoint_index] xy_coords[0, :] = 0 return project_xy(xy_coords, pvec) 여기서 xy_coords[0, :] = 0이 앞서 dstpoints의 첫번째 값인 coners[0]값과 대응된다. 결과적으로 coners[0]값이 remapping 후 (0,0)이 되도록 결정되는 것이다. remapping시 기준은 coners[0]값 (0,0)이되게 하고 coners의 높이와 넓이만큼 remapping을 하기 때문에 자동으로 우리가 원하는 지점에 대한 output을 얻을 수 있다. 해당 점은 디버그 모드시 확인할 수 있다. resize12345678image_x_coords = image_points[:, 0, 0].reshape(page_x_coords.shape)image_y_coords = image_points[:, 0, 1].reshape(page_y_coords.shape)image_x_coords = cv2.resize(image_x_coords, (width, height), interpolation=cv2.INTER_CUBIC)image_y_coords = cv2.resize(image_y_coords, (width, height), interpolation=cv2.INTER_CUBIC) 현재까지 좌표 image_x_coords, image_y_coords는 원본이미지가 small = resize_to_screen(img)로 축소된 이미지를 대상으로 변경한 것이다. 원본 이미지의 좌표에 대한 것으로 remapping을 하기 위해 cv2.resize를 통해 좌표를 변환해준다. cv2.remap이제 이동할 좌표를 모두 특정하였다. remap 함수에 대해서 설명하면 기본형은 다음과 같다. cv2.remap(src, map1, map2, interpolation[, dst[, borderMode[, borderValue]]]) → dst input 파라미터를 설명하면 아래와 같다. src : 원본 이미지 map1 : (x,y) 포인트 또는 x 값 map2 : y값 interpolation : 보간법 INTER_NEAREST - a nearest-neighbor interpolation INTER_LINEAR - a bilinear interpolation (used by default) INTER_AREA - resampling using pixel area relation. It may be a preferred method for image decimation, as it gives moire’-free results. But when the image is zoomed, it is similar to the INTER_NEAREST method. INTER_CUBIC - a bicubic interpolation over 4x4 pixel neighborhood INTER_LANCZOS4 - a Lanczos interpolation over 8x8 pixel neighborhood borderMode : 픽셀 외삽 법(Pixel extrapolation method). BORDER_TRANSPARENT` : 소스 이미지의 “특이치(outliers)”에 해당하는 대상 이미지의 픽셀이 함수에 의해 수정되지 않음을 의미. BORDER_CONSTANT : 이미지를 일정한 값으로 채움 (예 : 검은 색 또는 0) BORDER_REPLICATE : 원본의 가장 자리에있는 행 또는 열이 추가 테두리에 복제 borderValue : 경계가 일정한 경우에 사용되는 값. 기본적으로 0. remapped = cv2.remap(img, image_x_coords, image_y_coords, cv2.INTER_CUBIC, None, cv2.BORDER_REPLICATE) 해당 함수를 보면 보간법은 INTER_CUBIC, 픽셀 외삽법은 BORDER_REPLICATE로 가장자리에 있는 행 또는 열이 복제가 되는 것을 지정하였다. remapping에서 가장 중요한 것은 map1과 map2이다. map은 map1에 x좌표 또는 x,y좌표, map2에는 y좌표가 들어가 있다. map의 내용을 분석하기 위해서 image_x_coords을 print로 하면 다음과 같다. 1234567891011image_x_coords = [[1082.8455 1082.7078 1082.647 ... 2433.1545 2433.1294 2433.0715] [1082.8472 1082.7097 1082.6489 ... 2433.164 2433.139 2433.0808] [1082.848 1082.7104 1082.6497 ... 2433.1682 2433.143 2433.085 ] ... [1058.0674 1057.9417 1057.8861 ... 2305.5059 2305.4805 2305.4229] [1058.0681 1057.9423 1057.8867 ... 2305.5093 2305.4841 2305.4263] [1058.0697 1057.9438 1057.8884 ... 2305.5176 2305.4922 2305.4346]]image_x_coords.shape = (1920, 1488)remapped.shape = (1920, 1488, 3) 일단 shape를 보면 image_x_coords와 remapping 결과물인 remapped의 shape가 같은 것을 볼 수 있다. remapped.shape의 마지막 3은 RGB의 값이므로 높이=1920, 넓이=1488의 지도를 나타내는 것이 image_x_coords라고 할 수 있다. 그럼 image_x_coords의 내용의 의미는 무엇일까? 바로 원본 이미지의 좌표값이다. image_x_coords[0][0] = 1082.8455 이다. 해당 값은 resizing등 여러 계산에 의한 결과이기 때문에 실수로 표현되었다. 실제적으로 좌표의 값은 정수이다. 그러므로 image_x_coords[0][0] = 1082로 보면 된다. 이 뜻은 remapped의 이미지의 (0,0)의 좌표의 값의 x값이 원본 소스의 x값 1082와 매칭된다는 것을 뜻한다. 똑같은 의미로 image_y_coords[0][0]의 값의 의미는 remapped의 이미지의 (0,0)의 좌표의 값의 y값이 원본 소스의 y값 image_y_coords[0][0]의 값과 매칭된다는 것을 뜻한다. 실제적으로 remapped 이미지의 (0,0)의 RGB값은 원본 소스의 (image_x_coords[0][0],image_y_coords[0][0])의 RGB값이라는 의미이다. image_x_coords[0][0] = 1082, image_y_coords[0][0] = 1003이고 해당 좌표의 원본이미지의 RGB값이 (125,23,25)일때 remapping의 결과물은 아래 그림과 같다. convertMapsremap에서 x,y좌표가 따로 있기 때문에 파악이 힘든 경우가 있다. 이와 같은 경우 cv2.convertMaps을 사용할 수 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253mapXY, _ = cv2.convertMaps(image_x_coords, image_y_coords, cv2.CV_16SC2)print(mapXY)[[[1082 1003] [1082 1003] [1082 1003] ... [2433 1070] [2433 1070] [2433 1070]] [[1082 1003] [1082 1003] [1082 1003] ... [2433 1070] [2433 1070] [2433 1070]] [[1082 1003] [1082 1003] [1082 1003] ... [2433 1070] [2433 1070] [2433 1070]] ... [[1058 2804] [1057 2804] [1057 2804] ... [2305 2726] [2305 2726] [2305 2726]] [[1058 2804] [1057 2804] [1057 2804] ... [2305 2726] [2305 2726] [2305 2726]] [[1058 2804] [1057 2804] [1057 2804] ... [2305 2726] [2305 2726] [2305 2726]]] 위와 같이 x,y의 좌표가 매칭되서 결과를 확인할 수 있다. mapXY[0][0]의 값 [1082 1003]은 remaping 이미지의 (0,0)의 RGB값이 원본 소스 (1082,1003)의 RGB와 매칭된다는 것을 뜻한다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"openCv page Dewarp 사다리꼴 결과물 보정","slug":"openCV-pageDewarp-사다리꼴 결과물 보정","date":"2020-04-22T00:12:55.000Z","updated":"2022-02-08T02:11:11.815Z","comments":true,"path":"2020/04/22/openCV-pageDewarp-사다리꼴 결과물 보정/","link":"","permalink":"http://jung-max.github.io/2020/04/22/openCV-pageDewarp-사다리꼴 결과물 보정/","excerpt":"","text":"개요이미지 디워핑을 하다보면 가끔 이미지의 가장자리 부분이 잡아 끌려와서 이상하게 처리되 사다리꼴이 된 모습을 볼 수 있다. 이와 같이 노이즈가 경계면에 있는 이유는 마스킹 때 이미지를 벗어난 좌표까지 기준으로 했기 때문에 그렇다. 위 그림처럼 페이지를 새로 만들 부분을 이미지 경계면에서 벗어난 오른쪽 부분까지 지정한 것을 볼 수 있다. 그림에서는 이미지가 오른쪽으로 검은 부분이 더 있는 것처럼 보이지만 실제 input이미지는 책 오른쪽 검은쪽이 없다. 그렇기 때문에 해당 좌표를 기준으로 remmaping을 하면 없는 좌표의 것을 처리하기 때문에 오른쪽이 노이즈가 낀 것처럼 표시되는 것이다. 또한 책의 이미지가 사다리 꼴 모양으로 변해 가독성도 떨어지게 된다. 선 찾기해당 이미지를 노이즈를 제거하고 사각형 모양으로 만들기 위해서는 오른쪽 이미지와 노이즈 부분의 경계를 찾을 필요가 있다. 여기서 사용한 방법은 opnecv의 선찾기 방법인 cv2.HoughLines이다. 해당 방법을 사용해 위의 결과물에 적용하면 아래와 같이 선을 찾을 수 있다. 빨간 선이 찾은 선의 모습이다. 해당 선을 찾기 위한 소스코드는 아래와 같다. 123456789101112131415161718192021gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)edges = cv2.Canny(gray,50,50,apertureSize = 3)lines = cv2.HoughLines(edges,1,np.pi/180,140)if lines is None: return srcfor line in lines: rho,theta = line[0] a = np.cos(theta) b = np.sin(theta) x0 = a*rho y0 = b*rho x1 = int(x0 + 1000*(-b)) y1 = int(y0 + 1000*(a)) x2 = int(x0 - 1000*(-b)) y2 = int(y0 - 1000*(a)) if DEBUG_LEVEL &gt;= 3: cv2.line(img,(x1,y1),(x2,y2),(0,0,255),3)if DEBUG_LEVEL &gt;= 3: debug_show('HoughLines', 7, 'HoughLines', img) 위 코드를 간단히 설명하면 이미지를 gray → canny로 변경하여 선찾기를 위한 전처리 과정을 진행한다. canny로 변경한 이미지는 아래와 같다. 이 이미지를 기준으로 선을 찾게 된다. 기준이 되는 좌표 찾기사다리 꼴 모양을 똑바로 펴기 위해서는 네개의 모서리 점의 좌표가 필요하다. 일단 여기서 오른쪽의 좌표는 12topLeft = [0 ,0]bottomLeft = [0 , height] 와 같이 표현할 수 있다. 오른쪽 좌표를 찾기 위해서는 선의 끝점을 찾아야 한다. 여기서 처음에는 위에서 구한 (x1,y1), (x2,y2)가 끝점이 된다고 생각하였다. 하지만 해당 좌표를 print해보면 아래와 같은 값이 나오게 된다. x1 = 411, y1 = -1014 x2 = 481, y2 = 983 하지만 이미지 전체의 넓이와 높이는 아래와 같다. img_width = 496 img_height = 648 일단 y1은 -1014로 마이너스 값이기 때문에 이미지 좌표에서 벗어난다. y2또한 983으로 이미지의 높이인 648을 훨씬 초과하였다. 그렇기 때문에 우리는 y=0일때 x좌표와 y=img_height 일때 x좌표를 구해야한다. 아래의 수식을 통해 우리는 y좌표가 정해졌을 때 x값을 구할 수 있다. xcos(theta) + ysin(theta)= rho xcos(theta) = rho-ysin(theta) x = (rho - ysin(theta) ) / cos(theta) 위를 파이썬 코드로 풀어내면 다음과 같다. 12x1 = int(np.ceil(rho / np.cos(theta)))x2 = int(np.ceil((rho - img_height*np.sin(theta) ) / np.cos(theta))) 좌표는 정수여야만 하므로 올림을 했다. 이미지 와핑(Imgae Warping)하기이제 4개의 꼭지점을 알았으니 그 점을 기준으로 이미지 와핑을 하면 된다. 여기서 사용하는 방법은 투영변환(Perspective Transformation)이다. 소스로 보면 아래와 같다. 12345src_pts = np.float32([topLeft, topRight, bottomLeft, bottomRight])dst_pts = np.float32([[0,0], [width,0], [0, height], [width, height]])M = cv2.getPerspectiveTransform(src_pts, dst_pts)dst = cv2.warpPerspective(src, M, (width, height)) 기준이 되는 점(src_pts)와 목적지 점(dst_pts)를 지정한다. 두점을 가지고 cv2.getPerspectiveTransform를 사용해 변환 행렬을 구한다. 구한 변환행렬을 사용해 cv2.warpPerspective를 사용해 이미지 와핑을 해주면 끝난다. 결과물은 아래와 같다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"openCv page Dewarp 중심이론 설명","slug":"openCV-pageDewarp-중심이론설명","date":"2020-04-17T01:27:13.000Z","updated":"2022-02-08T02:11:11.815Z","comments":true,"path":"2020/04/17/openCV-pageDewarp-중심이론설명/","link":"","permalink":"http://jung-max.github.io/2020/04/17/openCV-pageDewarp-중심이론설명/","excerpt":"","text":"개요구부러진 책을 펴기 위해서는 몇가지 모델링 및 가정이 필요합니다. 간단한 요점은 다음과 같습니다. 3D상의 책은 높이(z) 0에 놓여 있는 평평한 종이라고 가정합니다. 가정한 3D상의 좌표를 기준으로 회전벡터(r), 평행이동벡터(T)를 구합니다. 책의 구부러짐을 3차원 방정식으로 표현된다고 가정합니다. 3차원 방정식은 f(0)=0, f(1)=0 으로 0~1사이의 그래프라고 가정하고 두개의 기울기 f’(0)=α, f’(1)=β라고 정합니다. α, β의 값에 따라서 3차원 방정식의 모양(책의 구부러진 모양과 동일하다 가정)이 결정됩니다. 회전벡터 r, 평행이동벡터 t, 두개의 기울기 α, β를 통해 얻은 z값을 가지고 카메라 재투영을 통해 이미지 좌표계의 점을 구합니다. 원래의 이미지 좌표계의 점 (x,y)와 위에서 구한 이미지 좌표계의 점 (x’, y’)와 비교합니다. 두개의 비교(거리차)가 최소가 되는 α, β의 값을 구합니다. 구한 α, β를 통해 z값을 구하고 평평한 종이라고 가정했을때 구한 회전벡터(r), 평행이동벡터(T)를 가지고 이미지 좌표계를 구합니다. 구한 이미지 좌표계로 픽셀을 이동(remap)합니다. 이동한 이미지는 평평한 이미지가 됩니다. 위의 내용은 글로는 이해하기 힘든 부분이 많습니다. 아래에서 그림과 함께 하나하나 설명하도록 하겠습니다. 왜곡 가정이미지 처리 기술중 카메라의 왜곡을 보정하는 기술이 존재합니다. 보통은 아래 그림처럼 카메라 렌즈에 의한 구부러진 왜곡을 실제 모습으로 펴기 위해 사용되는 기술입니다. 구부러진 책을 펴기위해 위의 왜곡 보정기술을 응용합니다. 원리는 간단합니다. “나의 책은 원래 평평한 평면상에 펴져있는 상태로 놓여져 있지만 카메라 때문에 왜곡이 일어나서 구부러져 보일 뿐이다”라고 가정하는 것입니다. 평면상에 놓여진 가정된 3D 좌표는 아래와 같습니다. [0, 0, 0], [page_width, 0, 0], [page_width, page_height, 0], [0, page_height, 0] 높이가 없는 종이라고 가정하였기 때문에 z축은 모두 0이 됩니다. 그러고 x,y축의 좌표는 책의 높이와 넓이가 됩니다. 가정된 3D 좌표상의 좌표 [0, 0, 0], [page_width, 0, 0], [page_width, page_height, 0], [0, page_height, 0]와 이미지 평면상의 좌표 [0,0], [page_width, 0], [page_width, page_height], [0, page_height]을 가지고 회전 벡터(R)과 평행이동 벡터(t)를 취득할 수 있습니다.(cv::solvePnP) 개념 설명을 위해 Camera Coordinate System을 간단히 설명하면 3가지 개념이 존재합니다. 카메라 좌표계, 이미지 평면, 월드 좌표계입니다. 카메라 좌표계는 카메라를 기준으로 한 좌표계입니다. 카메라 좌표계는카메라의 초점(렌즈의 중심)을 원점, 카메라의 정면 광학축 방향을 Z축, 카메라 아래쪽 방향을 Y축, 오른쪽 방향을 X축으로 잡습니다. 픽셀 좌표계의 x축, y축에 의해 결정되는 평면을 이미지 평면 (image plane)이라 부릅니다. 픽셀 좌표계는 우리가 실제 눈으로 보는 영상에 대한 좌표계로서 위 이미지의 왼쪽상단(left-top) 모서리를 원점, 오른쪽 방향을 x축 증가방향, 아래쪽 방향을 y축 증가방향으로 합니다. 월드 좌표계는 우리가 사물(물체)의 위치를 표현할 때 기준으로 삼는 좌표계입니다. 월드좌표계는 어디 하늘에서 주어져 있는 것이 아니라 문제에 따라서 우리가 임의로 잡아서 사용할 수 있는 좌표계입니다. 예를 들어, 자신의 안방 한쪽 모서리를 원점으로 잡고 한쪽 벽면 방향을 X축, 다른쪽 벽면 방향을 Y축, 하늘을 바라보는 방향을 Z축으로 잡을 수 있습니다. 위 개념을 크게 이해하실 필요는 없습니다. 다만 위에서 구한 회전벡터(R)과 평행이동 벡터(t)를 가지고 이미지 좌표계의 점(2D)을 월드좌표계(3D)로 변환 또는 3D → 2D 변환이 가능하다는 것을 기억하면 됩니다. 위에서 구한 두 벡터는 평평한 이미지를 위한 3D 좌표 변환을 위한 것입니다. 실제로 우리 책은 이미지 평면상에서 구부러져 보이고 있습니다. 이를 보정하기 위해서는 현재의 정확한 3D 좌표가 필요합니다. 책의 구부러짐을 3차원 방정식으로 표현된다고 가정현재 우리가 가지고 있는 정보는 구부러진 책의 이미지의 이미지 좌표계(x,y)입니다. 하지만 평평한 이미지로 보정을 위해서는 높이 z를 포함한 월드 좌표계의 정보가 필요합니다. 구부러진 책의 좌표를 보면 아래 그림과 같습니다. 여기서 우리는 책의 페이지는 구부러진 상태로 평면에 놓여 있다고 가정합니다. 여기서 우리는 책의 y축에 따른 z의 값은 일정하다고 가정합니다. 위 가정에 따라 y축을 지우면 아래 그림과 같은 곡선이 표시됩니다.여기서 책의 넓이는 1로 표준화 합니다. 여기서 또한가지 중요한 가정이 필요합니다. 위의 그래프가 3차원 그래프라고 가정하는 것입니다. 위 그래프는 f(0)=0, f(1)=0 입니다. 또한 x가 0일때의 기울기 f＇(0)=α, x가 1일때의 기울기 f＇(1)=β라고 정합니다. 3차 방정식 ax³+bx²+cx+d=0 과 f(0)=0, f(1)=0, f＇(0)=α, f＇(1)=β를 계산합니다. f(0)= 0이기 때문에 d=0이 됩니다. f(1)=0이기 때문에 a+b+c=0이 됩니다. f＇(x)는 3ax²+2bx+c입니다. f＇(0)=α 이므로 c=α 입니다. f＇(1)=β 이므로 3a+2b+α=β 입니다. 위 식을 풀면 a = α+β, b = -2α-β가 됩니다. 최종적으로 (α+β)x³-(2α+β)x²+αx=0의 방정식을 얻을 수 있습니다. 위의 방정식을 α, β의 변화에 따른 그래프를 그려보면 아래와 같습니다. 위의 곡선은 책이 구부러짐과 많이 비슷합니다. 그렇기 때문에 모든 책의 구부러짐은 3차 방정식의 그래프로 표현할 수 있다라고 가정하는 것입니다. 카메라 재투영 오류(reprojection error)이제 우리는 특정 α, β를 지정하면 거기에 따른 높이(z)를 구할 수 있습니다. 이미 우리는 이미지 평면상에서 점 (x,y)를 알고 있습니다. 거기에 위 3차원 방정식에 x값을 대입하면 높이 z를 구할 수 있고 최종적으로 3D 좌표점(x,y,z)를 구할 수 있습니다. α, β를 구하기 위해서 카메라 재투영의 오류를 최소화하는 값을 구해야 합니다. 카메라 재투영이란 쉽게 말해 월드 좌표계의 3D 좌표를 이미지 평면상의 2D 좌표로 변환하는 것입니다. 여기서 필요한 것은 월드 좌표계의 3D 좌표와 회전벡터(r), 평행이동 벡터(T)입니다. 우리는 앞서 회전벡터(r), 평행이동 벡터(T)를 구했습니다. 여기서 중요한 것은 회전벡터(r), 평행이동 벡터(T)이 이미지 자체가 평평하다 라고 가정하고 구한 값이라는 것입니다. 여기에 따라 우리는 α, β을 변환하며 z값을 구할 수 있습니다. 구한 z값의 3d 좌표 (x,y,z)와 회전벡터(r), 평행이동 벡터(T)을 가지고 재투영 기술(cv::projectPoints)을 사용하여 이미지좌표 (x’, y’)를 구합니다. 위에서 구한 이미지좌표 (x’,y’)와 원래의 이미지 좌표(x,y)를 비교합니다. 아래 이미지는 α, β가 0일때 빨간점은 원래의 이미지 좌표, 파란점은 재투영 후 이미지 좌표를 표시한 것입니다. 위를 보면 원래의 좌표와 재투영 후의 좌표가 차이가 나는 것을 알 수 있습니다. 따라서 우리는 α, β를 임의의 값으로 조정 후 원래의 좌표와 재투영 후의 좌표가 차이가 최소가 되는 α, β값을 찾아야 합니다. 이를 위해서는 최소값을 찾아주는 파이썬의 기술인 scipy.optimize.minimize의 Powell방식을 사용할 수 있습니다. 해당 방법은 간단히 말해 임의의 α, β값을 넣어준 후 구한 재투영 좌표와 원래의 좌표의 차를 계속 구해 최소가 되는 어떠한 α, β를 반복 작업을 통해 구하는 것입니다. 이를 통해 구한 α, β의 값으로 재투영을 하면 아래와 같이 두 좌표의 차이가 거의 사라진 것을 볼 수 있습니다. 이제 우리는 α, β의 값을 구했으므로 x,y에 따른 z값을 구할 수 있습니다. 이것은 3D좌표를 구할 수 있다는 의미입니다. 이미지 평탄화 작업앞서 말한 것 처럼 우리가 처음에 구했던 회전, 평행이동 벡터는 이미지 자체가 굴곡이 없이 평행하다고 가정하고 구한 값입니다. 그렇기 때문에 이미지 좌표(x,y)와 위에서 구한 α, β 값으로 구한 z값을 합한 3D좌표 (x,y,z)와 회전,평행이동 벡터를 가지고 재투영 기술(cv::projectPoints)을 사용하면 이미지 평면상의 2D 좌표 (x’, y’)를 구할 수 있습니다. 이와같이 모든 점(픽셀)에 대해서 (x,y) → (x’,y’)로 이동을 해줍니다. 이를 위해 리맵기술(cv::remap)을 사용할 수 있습니다. 위와 같은 작업을 한다면 우리는 굴곡된 이미지(x,y)에서 평탄화된 이미지 (x’,y’)를 얻을 수 있습니다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"openCv page Dewarp 책 반으로 자르기","slug":"opencv-PageDewarping-책 반으로 자르기","date":"2020-04-09T07:39:25.000Z","updated":"2022-02-08T02:11:11.817Z","comments":true,"path":"2020/04/09/opencv-PageDewarping-책 반으로 자르기/","link":"","permalink":"http://jung-max.github.io/2020/04/09/opencv-PageDewarping-책 반으로 자르기/","excerpt":"","text":"개요기존 소스는 책의 이미지가 반으로 잘린 것을 기준으로 동작하였습니다. 이번 포스팅에서는 책의 이미지를 반으로 자르는 것을 구현하는 것에 대해서 설명하겠습니다. 구현123456789101112131415161718192021def cut_half(img): height, width = img.shape[:2] gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY) edges = cv2.Canny(gray,50,150,apertureSize = 3) # 선을 추출 lines = cv2.HoughLinesP(edges,1,np.pi/180,100, minLineLength=80, maxLineGap=5) tmp_candy = [] tmp_abs = [] for i in range(len(lines)): for x1,y1,x2,y2 in lines[i]: gapY = np.abs(y2-y1) gapX = np.abs(x2-x1) # 선의 x축의 차이가 5이하 y축의 차이가 10이상이면 세로줄로 판별 if gapX &lt; 5 and gapY &gt; 50 : tmp_candy.append(x1) tmp_abs.append(np.abs(x1- width//2)) left_img = img[0:height,0:tmp_candy[np.argmin(tmp_abs)]] right_img = img[0:height,tmp_candy[np.argmin(tmp_abs)]+1:width] return left_img, right_img 입력으로 이미지를 받은 후 HoughLinesP함수를 통해 선을 추출한 후 세로선을 판별, 이미지 중간점에 가장 가까운 세로선을 선택해 자르는 내용입니다. 전처리123height, width = img.shape[:2]gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)edges = cv2.Canny(gray,50,150,apertureSize = 3) 기존의 이미지에서 높이와 넓이를 구합니다. 이는 나중에 자를때 기준을 정하기 위해서 사용됩니다. cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)를 통해 이미지를 회색조로 변경 합니다. 중간을 자르기 위한 세로선을 찾기 위해서 Canny로 이미지를 변경합니다. 세로 선 찾기1234567891011lines = cv2.HoughLinesP(edges,1,np.pi/180,100, minLineLength=80, maxLineGap=5)tmp_candy = []tmp_abs = []for i in range(len(lines)): for x1,y1,x2,y2 in lines[i]: gapY = np.abs(y2-y1) gapX = np.abs(x2-x1) # 선의 x축의 차이가 5이하 y축의 차이가 10이상이면 세로줄로 판별 if gapX &lt; 5 and gapY &gt; 50 : tmp_candy.append(x1) tmp_abs.append(np.abs(x1- width//2)) openCV에서 선을 찾기 위한 함수인 허프변환 cv2.HoughLines() , cv2.HoughLinesP()이 있습니다. 그중 확률적으로 선을 찾는 함수인 허프 변환 HoughLinesP을 사용하였습니다. cv2.HoughLinesP(image, rho, theta, threshold, minLineLength, maxLineGap) → lines image – 8bit, single-channel binary image, canny edge를 선 적용. rho – r 값의 범위 (0 ~ 1 실수) theta – 𝜃 값의 범위(0 ~ 180 정수) threshold – 만나는 점의 기준, 숫자가 작으면 많은 선이 검출되지만 정확도가 떨어지고, 숫자가 크면 정확도가 올라감. minLineLength – 선의 최소 길이. 이 값보다 작으면 reject. maxLineGap – 선과 선사이의 최대 허용간격. 이 값보다 작으며 reject. HoughLinesP의 결과는 두점의 좌표로 리턴됩니다. 두점을 이으면 선이 됩니다. 세로선인 것을 찾기 위해서는 간단히 두 점의 x축 차이는 매우 작고 y축 차이는 매우 크면됩니다. 두점의 좌표 차이를 구하기 위해서 절대값을 구하는 함수인 np.abs을 사용하였습니다. 제가 사용한 기준은 x축의 차이는 5픽셀 이하이고 y축의 차이는 50이상으로 잡았습니다. 또한 우리의 목표는 책을 반으로 자르는 것이기 때문에 해당 선의 x좌표가 이미지의 중간에 얼마나 근접해 있는지를 체크하였습니다. 최종 책 이미지 자르기1234left_img = img[0:height,0:tmp_candy[np.argmin(tmp_abs)]]right_img = img[0:height,tmp_candy[np.argmin(tmp_abs)]+1:width]return left_img, right_img 책의 좌우를 자르기 위해서 높이는 0부터 기존 이미지의 높이만큼을 할당하였습니다. 넓이는 왼쪽은 0부터 위에서 구한 세로선중 이미지의 가운데와 가장 근접한 선의 인덱스를 np.argmin(tmp_abs)로 찾았습니다. np.argmin은 입력된 리스트에서 가장 작은 값의 인덱스를 리턴하는 함수입니다. 이 알고리즘의 핵심은 세로줄 찾기와 책의 중간은 이미지 중간과 가장 근접한 세로줄로 표현된다 입니다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"openCv page Dewarp 동적 마스킹","slug":"opencv-PageDewarping-동적마스킹","date":"2020-04-09T07:04:36.000Z","updated":"2022-02-08T02:11:11.816Z","comments":true,"path":"2020/04/09/opencv-PageDewarping-동적마스킹/","link":"","permalink":"http://jung-max.github.io/2020/04/09/opencv-PageDewarping-동적마스킹/","excerpt":"","text":"개요동적 마스킹이란 기존 소스에서 하드 코딩값으로 가장자리의 부분을 잘라냈던 것을 텍스트 인지를 통해 동적으로 자르는 것을 목표로 합니다. 결과는 다음과 같습니다. 위의 알고리즘은 기존소스의 mask를 구하기 전에 먼저 spans를 구하고 거기에 따른 x,y 좌표의 최대 최소값을 구해 적용하는 것입니다. 구현123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657def text_mask(small): global DEBUG_LEVEL global TEXT_MIN_WIDTH global TEXT_MIN_HEIGHT global TEXT_MAX_THICKNESS tmp_debug_level = DEBUG_LEVEL DEBUG_LEVEL = 0 tmp_text_min_width = TEXT_MIN_WIDTH TEXT_MIN_WIDTH = 5 tmp_text_min_height = TEXT_MIN_HEIGHT TEXT_MIN_HEIGHT = 1 tmp_text_max_thickness = TEXT_MAX_THICKNESS TEXT_MAX_THICKNESS = 20 name = 'mask_temp' spans = [] height, width = small.shape[:2] pagemask = np.zeros((height, width), dtype=np.uint8) cv2.rectangle(pagemask, (0, 0), (width, height), (255, 255, 255), -1) # 윤곽선 정보 검출 cinfo_list = get_contours(name, small, pagemask, 'text') # 윤곽선을 길게 합침 spans_text = assemble_spans(name, small, pagemask, cinfo_list) # 텍스트가 없어서 span 갯수가 부족시 line을 디텍팅 하도록 설계 if len(spans_text) &lt; 3: print (' detecting lines because only', len(spans_text), 'text spans') cinfo_list = get_contours(name, small, pagemask, 'line') spans2 = assemble_spans(name, small, pagemask, cinfo_list) if len(spans2) &gt; len(spans_text): spans_text = spans2 # 윤곽선 각각의 넓이와 y축 위치 구하기. span_with_min = [] span_with_max = [] span_height_min = [] span_height_max = [] for i, span in enumerate(spans_text): # 한줄 빼오기 contours = [cinfo.contour for cinfo in span] # 빼온거에서 젤 왼쪽과 오른쪽 을 빼서 길이 재고 y축 값 구하기. contours_min = np.argmin(contours[0], axis = 0) contours_max = np.argmax(contours[0], axis = 0) span_with_min.append(contours[0][contours_min[0][0]][0][0]) span_with_max.append(contours[0][contours_max[0][0]][0][0]) span_height_min.append(contours[0][contours_min[0][1]][0][1]) span_height_max.append(contours[0][contours_max[0][1]][0][1]) DEBUG_LEVEL = tmp_debug_level TEXT_MIN_WIDTH = tmp_text_min_width TEXT_MIN_HEIGHT = tmp_text_min_height TEXT_MAX_THICKNESS = tmp_text_max_thickness # 리턴 값은 x축 최소값, x축 최대값, y축 최소값, y축 최대값 return np.min(span_with_min), np.max(span_with_max), np.min(span_height_min), np.max(span_height_max) 윤곽선 구하기12345678910111213global DEBUG_LEVELglobal TEXT_MIN_WIDTHglobal TEXT_MIN_HEIGHTglobal TEXT_MAX_THICKNESStmp_debug_level = DEBUG_LEVELDEBUG_LEVEL = 0tmp_text_min_width = TEXT_MIN_WIDTHTEXT_MIN_WIDTH = 5tmp_text_min_height = TEXT_MIN_HEIGHTTEXT_MIN_HEIGHT = 1tmp_text_max_thickness = TEXT_MAX_THICKNESSTEXT_MAX_THICKNESS = 20 기존에 정의되었던 TEXT 관련 검색 기준을 낮추어 더 많은 것을 찾도록 구현하였습니다. 디버그는 기존 소스의 디버그만 볼 수 있도록 0으로 지정하였습니다. 기존 값들을 저장하기 위해 tmp_xxx로 지정하여 보존하였습니다. 12345678910name = 'mask_temp'spans = []height, width = small.shape[:2]pagemask = np.zeros((height, width), dtype=np.uint8)cv2.rectangle(pagemask, (0, 0), (width, height), (255, 255, 255), -1)# 윤곽선 정보 검출cinfo_list = get_contours(name, small, pagemask, 'text')# 윤곽선을 길게 합침spans_text = assemble_spans(name, small, pagemask, cinfo_list) 당장 필요없는 파라미터를 더미값으로 주고 최종 윤곽선을 구하는 assemble_spans까지 진입하도록 하였습니다. 유효한 부분의 위치 구하기1234567891011121314151617181920212223# 윤곽선 각각의 넓이와 y축 위치 구하기.span_with_min = []span_with_max = []span_height_min = []span_height_max = []for i, span in enumerate(spans_text): # 한줄 빼오기 contours = [cinfo.contour for cinfo in span] # 빼온거에서 젤 왼쪽과 오른쪽 을 빼서 길이 재고 y축 값 구하기. contours_min = np.argmin(contours[0], axis = 0) contours_max = np.argmax(contours[0], axis = 0) span_with_min.append(contours[0][contours_min[0][0]][0][0]) span_with_max.append(contours[0][contours_max[0][0]][0][0]) span_height_min.append(contours[0][contours_min[0][1]][0][1]) span_height_max.append(contours[0][contours_max[0][1]][0][1])DEBUG_LEVEL = tmp_debug_levelTEXT_MIN_WIDTH = tmp_text_min_widthTEXT_MIN_HEIGHT = tmp_text_min_heightTEXT_MAX_THICKNESS = tmp_text_max_thickness# 리턴 값은 x축 최소값, x축 최대값, y축 최소값, y축 최대값return np.min(span_with_min), np.max(span_with_max), np.min(span_height_min), np.max(span_height_max) 해당 부분은 기존에 포스트 했던 opencv 윤곽선(Contours)값의 의미(내용) 최대값 최소값 구하기를 응용한 것입니다. 기존 spans에서 윤곽선을 하나씩 빼옵니다. 그 후 윤곽선의 최대 최소가 되는 좌표를 각각에 리스트에 넣어 줍니다. 그 후 최종적으로 리턴을 넣어준 리스트의 최소, 최대값으로 리턴 한다면 각각의 그림에서 유효한 영역의 부분을 구할 수 있습니다. masking1234567891011def get_page_extents(small): # 이미지의 높이, 넓이 취득 height, width = small.shape[:2] if IMAGE_TYPE == 'text': xmin, xmax, ymin, ymax= text_mask(small) xmin = xmin - PAGE_MARGIN_X ymin = ymin - PAGE_MARGIN_Y xmax = xmax + PAGE_MARGIN_X ymax = ymax + PAGE_MARGIN_Y 기존 소스에서 고정값으로 되있던 부분을 위에서 구한 값으로 대체하였습니다. 다만 기존에 구한 값으로 자르면 마진 없이 자르게 되어서 이상한 모습을 나타나게 됩니다. 저같은 경우는 10의 값을 주어서 output 이미지가 좀더 자연스럽게 나올 수 있도록 하였습니다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"opencv 윤곽선(Contours)값의 의미(내용) 최대값 최소값 구하기","slug":"opencv 윤곽선(Contours)값의 의미(내용) 최대값 최소값 구하기","date":"2020-04-07T23:32:48.000Z","updated":"2022-02-08T02:11:11.810Z","comments":true,"path":"2020/04/08/opencv 윤곽선(Contours)값의 의미(내용) 최대값 최소값 구하기/","link":"","permalink":"http://jung-max.github.io/2020/04/08/opencv 윤곽선(Contours)값의 의미(내용) 최대값 최소값 구하기/","excerpt":"","text":"윤곽선(Contours)이란영상이나 이미지의 윤곽선(컨투어)를 검출하기 위해서 사용합니다. 윤곽선은 외곽 뿐만 아니라 내곽도 검출 가능합니다. 컨투어(contour)란 동일한 색 또는 동일한 픽셀값(강도,intensity)을 가지고 있는 영역의 경계선 정보입니다. 물체의 윤곽선, 외형을 파악하는데 사용됩니다. 윤곽선 검출윤곽선의 검출 과정은 cv2.findContours을 사용해서 취득합니다. 해당 함수로 이미지의 컨투어 정보, 컨투어의 상하구조(hierachy) 정보를 출력합니다. 흑백이미지 또는 이진화된 이미지만 적용할 수 있습니다. images, contours, hierachy = cv2.findContours(image, mode, method) image: 흑백이미지 또는 이진화된 이미지 mode : 컨투어를 찾는 방법 cv2.RETR_EXTERNAL: 컨투어 라인 중 가장 바깥쪽의 라인만 찾음 cv2.RETR_LIST: 모든 컨투어 라인을 찾지만, 상하구조(hierachy)관계를 구성하지 않음 cv2.RETR_CCOMP: 모든 컨투어 라인을 찾고, 상하구조는 2 단계로 구성함 cv2.RETR_TREE: 모든 컨투어 라인을 찾고, 모든 상하구조를 구성함 method : 컨투어를 찾을 때 사용하는 근사화 방법 cv2.CHAIN_APPROX_NONE: 모든 컨투어 포인트를 반환 cv2.CHAIN_APPROX_SIMPLE: 컨투어 라인을 그릴 수 있는 포인트만 반환 cv2.CHAIN_APPROX_TC89_L1: Teh_Chin 연결 근사 알고리즘 L1 버전을 적용하여 컨투어 포인트를 줄임 cv2.CHAIN_APPROX_TC89_KCOS: Teh_Chin 연결 근사 알고리즘 KCOS 버전을 적용하여 컨투어 포인트를 줄임 실행 1234567891011121314151617import cv2src = cv2.imread(\"contours.jpg\", cv2.IMREAD_COLOR)gray = cv2.cvtColor(src, cv2.COLOR_RGB2GRAY)ret, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)binary = cv2.bitwise_not(binary)contours, hierachy = cv2.findContours(binary, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)print(\"contours = \", contours)cv2.drawContours(src, [contours[0]], 0, (0, 0, 255), 2)cv2.imshow(\"src\", src)cv2.waitKey(0)cv2.destroyAllWindows() 위 예제는 최외곽 윤곽선을 찾고 윤곽선을 빨간색으로 그려주는 소스입니다. 결과는 아래와 같습니다. drawContours 함수를 사용하면 컨투어 정보에서 비트맵 이미지를 만들 수 있습니다. cv2.drawContours(이미지, [윤곽선], 윤곽선 인덱스, (B, G, R), 두께, 선형 타입)을 의미합니다. print(“contours = “, contours)contours를 print하면 아래와 같은 결과를 보여줍니다. 12345678910111213contours = [array([[[116, 11]], [[115, 12]], [[114, 12]], ..., [[119, 11]], [[118, 11]], [[117, 11]]], dtype=int32)] contours는 3차원의 리스트로 이루어져 있습니다. 첫번째 차원은 윤곽선 인덱스을 의미합니다. 예제의 그림에서는 최외곽선 윤곽선 하나만을 추출하였기 때문에 첫번째 차원은 한개로 이루어져 있습니다. contours[0]을 print하면 다음과 같습니다. 12345678910111213contours[0] = [[[116 11]] [[115 12]] [[114 12]] ... [[119 11]] [[118 11]] [[117 11]]] 결과적으로 contours[i]에서 i값을 변경하면서 다른 윤곽선을 선택할 수 있습니다. 두번째 차원은 외곽선의 x,y좌표를 뜻합니다. contours[0][0], contours[0][1]을 print하면 다음과 같습니다. 12contours[0][0] = [[116 11]]contours[0][1] = [[115 12]] 각각의 의미는 컨투어(윤곽선)의 좌표를 뜻합니다. 해당 좌표들을 이어서 선을 만들어 지는 것이 윤곽선입니다. 이제 첫번째 좌표의 x,y값을 취득하려면 contours[0][0][0][0], contours[0][0][0][1]을 해주면 됩니다. 두번째 좌표의 x,y값은 두번째 차원의 값을 변경해 주면 됩니다. contours[0][1][0][0], contours[0][1][0][1] 해당 값을 print하면 다음과 같습니다. 1234contours[0][0][0][0] = 116 # 첫번째 윤곽선 좌표의 x값contours[0][0][0][1] = 11 # 첫번째 윤곽선 좌표의 y값contours[0][1][0][0] = 115 # 두번째 윤곽선 좌표의 x값contours[0][1][0][1] = 12 # 두번째 윤곽선 좌표의 y값 윤곽선의 최대,최소값 구하기이제 윤곽선의 x,y좌표를 구할 수 있으므로 x,y좌표의 최대 최소값 또한 구할 수 있습니다. 최대 최소값의 좌표를 구하기 위해서는 numpy의 argmin, argmax를 쓰면 됩니다. 해당 함수는 최소값, 최대값의 색인 위치를 리턴합니다. 12345678910111213141516import cv2import numpy as npsrc = cv2.imread(\"contours.jpg\", cv2.IMREAD_COLOR)gray = cv2.cvtColor(src, cv2.COLOR_RGB2GRAY)ret, binary = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY)binary = cv2.bitwise_not(binary)contours, hierachy = cv2.findContours(binary, cv2.RETR_TREE , cv2.CHAIN_APPROX_NONE)contours_min = np.argmin(contours[0], axis = 0)contours_max = np.argmax(contours[0], axis = 0)print(\"contours_min = \", contours_min)print(\"contours_max = \", contours_max) 위에서 결과는 다음과 같습니다. 12contours_min = [[119 0]]contours_max = [[488 245]] 해당 값의 뜻은 contours_min에서는 x값이 최소가 되는 색인은 119, y값의 최소가 되는 색인은 0입니다.최대 또한 x값이 최대가 되는 색인은 448, y값이 최대가 되는 색인은 245가 됩니다. 해당 값의 좌표를 구하면 아래와 같습니다. 123456789print(\"x-Min =\", contours[0][contours_min[0][0]][0][0])print(\"y-Min =\", contours[0][contours_min[0][1]][0][1])print(\"x-Max =\", contours[0][contours_max[0][0]][0][0])print(\"y-Max =\", contours[0][contours_max[0][1]][0][1])x-Min = 30y-Min = 11x-Max = 326y-Max = 189 위 처럼 numpy의 함수를 쓰면 윤곽선에서 좌표의 최대 최소값을 구할 수 있습니다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"지식","slug":"openCV/지식","permalink":"http://jung-max.github.io/categories/openCV/지식/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"Contours","slug":"Contours","permalink":"http://jung-max.github.io/tags/Contours/"}]},{"title":"VS코드 확장 오류 수정","slug":"VS 코드-확장-오류-수정","date":"2020-03-23T05:37:47.000Z","updated":"2022-02-08T02:11:11.818Z","comments":true,"path":"2020/03/23/VS 코드-확장-오류-수정/","link":"","permalink":"http://jung-max.github.io/2020/03/23/VS 코드-확장-오류-수정/","excerpt":"","text":"파이썬 도구 서버 충돌 최근에 Windows 10에서 실행되는 VS 코드에서 Python 도구가로드되지 않는 문제가 발생했습니다. 일부 연구 결과, 손상된 닷넷 설치로 인해 문제가 발생했습니다. VS Code의 Python Tools는 Python Tools 확장을 사용하여 런타임을 설치하므로 dotnet 런타임을 설치하여 문제를 해결할 수 없습니다. Python Tools 확장을 제거하거나 비활성화해도 도움이되지 않습니다. 아래 오류가 지속되었습니다. 123456Starting Microsoft Python language server.Error: An assembly specified in the application dependencies manifest (Microsoft.Python.LanguageServer.deps.json) was not found: package: &apos;runtime.win-x64.Microsoft.NETCore.App&apos;, version: &apos;2.2.4&apos; path: &apos;runtimes/win-x64/lib/netcoreapp2.2/System.Runtime.InteropServices.RuntimeInformation.dll&apos;[Info - 9:56:26 PM] Connection to server got closed. Server will restart. VS Code를 제거했다가 다시 설치해도 문제가 해결되지 않았습니다. 해결책해결책은 VS Code의 확장 폴더를 찾고 언어 서버 폴더를 수동으로 삭제하는 것입니다. 불행하게도 확장 프로그램을 제거해도이 폴더는 삭제되지 않습니다. 확장 폴더는 C:\\users\\yourname.vscode\\extensions\\name-of-extension 폴더를 삭제하면 languageServer.0.3.xx확장 프로그램이 다시 다운로드됩니다. VS Code 및 확장을 제거한 후에도 손상된 확장 파일을 유지하기위한 VS Code의 동작은 다른 플러그인에도 문제를 일으킬 수 있습니다. 플러그인이 이상하게 작동하거나 충돌하는 경우 .vscode홈 디렉토리에 있는 폴더 에서 시스템에서 확장 디렉토리를 삭제하십시오.","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"기타","slug":"기타/기타","permalink":"http://jung-max.github.io/categories/기타/기타/"}],"tags":[{"name":"VScode","slug":"VScode","permalink":"http://jung-max.github.io/tags/VScode/"}]},{"title":"openCv page Dewarp 분석 -7","slug":"openCV-pageDewarp-07","date":"2020-02-17T05:46:20.000Z","updated":"2022-02-08T02:11:11.814Z","comments":true,"path":"2020/02/17/openCV-pageDewarp-07/","link":"","permalink":"http://jung-max.github.io/2020/02/17/openCV-pageDewarp-07/","excerpt":"","text":"이번 포스트는 굴곡을 펴기 위해서 cv2.solvePnP를 사용하는 것을 알아보겠습니다. get_default_paramssolvePnP 함수는 영상을 획득한 카메라의 위치 및 방향 (camera pzose)을 알아낼 때 유용하게 사용할 수 있습니다.카메라 내부 파라미터 행렬 K와 3D 월드좌표 - 2D 픽셀좌표 매칭쌍들을 입력으로 주면, 카메라 외부 파라미터인 [R|t] 행렬을 계산해 줍니다. 최소 4개의 좌표쌍을 필요로 합니다. 기본형은 아래와 같습니다. 1retval, rvec, tvec = solvePnP(objectPoints, imagePoints, cameraMatrix, distCoeffs, rvec=None, tvec=None, useExtrinsicGuess=None, flags=None) 바탕이 되는 이론은 블로그와 openCV 사이트를 참고 바랍니다. 파라미터 설명은 다음과 같습니다. objectPoints : 객체 좌표 공간의 객체 포인트 배열, 3xN / Nx3 1 채널 또는 1xN / Nx1 3 채널. 여기서 N은 포인트 수입니다. vector &lt;Point3f&gt;도 여기에 전달할 수 있습니다. 월드 좌표계 (World Coordinate System)우리가 사물(물체)의 위치를 표현할 때 기준으로 삼는 좌표계입니다. 월드좌표계는 어디 하늘에서 주어져 있는 것이 아니라 문제에 따라서 우리가 임의로 잡아서 사용할 수 있는 좌표계입니다. 예를 들어, 자신의 안방 한쪽 모서리를 원점으로 잡고 한쪽 벽면 방향을 X축, 다른쪽 벽면 방향을 Y축, 하늘을 바라보는 방향을 Z축으로 잡을 수 있습니다. 좌표의 단위(unit)는 미터(meter)로 해도 되고 센티미터(centimeter)로 해도 됩니다. 중요한 점은 좌표계는 일종의 약속(protocol)이기 때문에 (3, 1, -10)이라고 했을 때 이 점이 어떤 위치인지 그 문제 내에서 만큼은 유일하게 결정될 수 있으면 되는 것입니다. imagePoints : 해당 이미지 포인트의 배열, 2xN / Nx2 1 채널 또는 1xN / Nx1 2 채널. 여기서 N은 포인트 수입니다. vector &lt;Point2f&gt;도 여기에 전달할 수 있습니다. 픽셀 좌표계 (Pixel Image Coordinate System)편의상 픽셀 좌표계라고 썼지만, 보통은 영상좌표계(Image Coordinate System)라고 불립니다. 픽셀 좌표계는 우리가 실제 눈으로 보는 영상에 대한 좌표계로서 아래 그림과 같이 이미지의 왼쪽상단(left-top) 모서리를 원점, 오른쪽 방향을 x축 증가방향, 아래쪽 방향을 y축 증가방향으로 합니다. 그리고 픽셀 좌표계의 x축, y축에 의해 결정되는 평면을 이미지 평면 (image plane)이라 부릅니다. 기하학적으로 볼 때, 3D 공간상의 한 점 P = (X,Y,Z)는 카메라의 초점 (또는 렌즈의 초점)을 지나서 이미지 평면의 한 점 pimg = (x, y)에 투영(projection) 됩니다. 알다시피 점 P와 점 pimg를 잊는 선(ray) 상에 있는 모든 3D 점들은 모두 pimg로 투영됩니다. 따라서 3D 점 P로부터 pimg는 유일하게 결정할 수 있지만, 반대로 영상 픽셀 pimg로부터 P를 구하는 것은 부가적인 정보 없이는 불가능합니다. 픽셀 좌표계의 단위는 픽셀(pixel)입니다. cameraMatrix : Input camera matrix 초점거리(focal length): fx, fy흔히 초점거리라 하면 볼록렌즈의 초점을 생각하기 쉬운데, 여기서(카메라 모델) 말하는 초점거리는 렌즈중심과 이미지센서(CCD, CMOS 등)와의 거리를 말합니다. 디지털 카메라 등에서 초점거리는 mm 단위로 표현되지만 카메라 모델에서 말하는 초점거리(f)는 픽셀(pixel) 단위로 표현됩니다. 즉, f의 단위로 픽셀이라는 의미입니다. 이미지의 픽셀(pixel)은 이미지 센서의 셀(cell)에 대응되기 때문에, 초점거리(f)가 픽셀(pixel) 단위라는 의미는 초점거리가 이미지 센서의 셀(cell) 크기에 대한 상대적인 값으로 표현된다는 의미입니다. 예를 들어, 이미지 센서의 셀(cell)의 크기가 0.1 mm이고 카메라의 초점거리가 f = 500 pixel이라고 하면 이 카메라의 렌즈 중심에서 이미지 센서까지의 거리는 이미지 센서 셀(cell) 크기의 500배 즉, 50 mm라는 의미입니다. 컴퓨터 비전 분야에서 카메라 초점거리를 물리단위(m, cm, mm, …)가 아닌 픽셀단위로 표현하는 이유는 (이미지 픽셀과 동일한 단위로 초점거리를 표현함으로써) 영상에서의 기하학적 해석을 용이하게 하기 위함입니다. 그런데, 카메라 모델에서 초점거리를 하나의 값으로 f라 표현하지 않고 fx, fy로 구분하여 표현하는 경우가 있는데(실제로 카메라 캘리브레이션을 수행하면 fx, fy를 구분하여 반환한다) 이는 이미지 센서의 물리적인 셀 간격이 가로 방향과 세로 방향이 서로 다를 수 있음을 모델링하기 위함입니다. 이 경우 fx는 초점거리(렌즈중심에서 이미지 센서까지의 거리)가 가로 방향 셀 크기(간격)의 몇 배인지를 나타내고 fy는 초점거리가 세로 방향 센서 셀 크기(간격)의 몇 배인지를 나타냅니다. fx와 fy 모두 단위는 픽셀(pixel)이며 현대의 일반적인 카메라는 가로방향 셀 간격과 세로방향 셀 간격의 차이가 없기 때문에 f = fx = fy라 놓아도 무방합니다. 참고로, 동일한 카메라로 캘리브레이션을 수행했을 때, 이미지 해상도를 1/2로 낮추면 캘리브레이션 결과의 초점거리도 1/2로 작아집니다. 실제 물리적 초점거리가 변하는 것은 아니지만 카메라 모델에서의 초점거리는 상대적인 개념이기 때문에 해상도를 바꾸면 한 픽셀(pixel)에 대응하는 물리크기가 변하고 따라서 초점거리도 변하게 됩니다. 예컨데, 이미지 해상도를 1/2로 낮추면 이미지 센서의 2 x 2 셀(cell)들이 합쳐서 하나의 이미지 픽셀이 되기 때문에 한 픽셀에 대응하는 물리크기가 2배가 됩니다. 따라서 초점거리는 1/2이 되어야 합니다. 카메라 모델의 렌즈중심(초점)은 핀홀 카메라 모델(그림 6)에서 핀홀(pinhole)에 해당됩니다. 핀홀 카메라 모델은 모든 빛은 한 점(초점)을 직선으로 통과하여 이미지 평면(센서)에 투영된다는 모델입니다. 이러한 핀홀 모델은 3D 공간과 2D 이미지 평면 사이의 기하학적 투영(projection) 관계를 매우 단순화시켜 줍니다. 초점으로부터 거리가 1(unit distance)인 평면을 normalized image plane이라고 부르며 이 평면상의 좌표를 보통 normalized image coordinate라고 부릅니다. 물론 이것은 실제는 존재하지 않는 가상의(상상의) 이미지 평면입니다. 카메라 좌표계 상의 한 점 (Xc, Yc, Zc)를 영상좌표계로 변환할 때 먼저 Xc, Yc를 Zc(카메라 초점에서의 거리)로 나누는 것은 이 normalized image plane 상의 좌표로 변환하는 것이며, 여기에 다시 초점거리 f를 곱하면 우리가 원하는 이미지 평면에서의 영상좌표(pixel)가 나옵니다 (그림 4 참조). 그런데, 이미지에서 픽셀좌표는 이미지의 중심이 아닌 이미지의 좌상단 모서리를 기준(원점)으로 하기 때문에 실제 최종적인 영상좌표는 여기에 (cx, cy)를 더한 값이 됩니다. 즉, x = fxX/Z+cx, y = fyY/Z+cy. 주점(principal point): cx, cy주점 cx, cy는 카메라 렌즈의 중심 즉, 핀홀에서 이미지 센서에 내린 수선의 발의 영상좌표(단위는 픽셀)로서 일반적으로 말하는 영상 중심점(image center)과는 다른 의미입니다. 예를 들어서, 카메라 조립과정에서 오차로 인해 렌즈와 이미지 센서가 수평이 어긋나면 주점과 영상중심은 다른 값을 가질 것입니다. 영상기하학에서는 단순한 이미지 센터보다는 principal point가 훨씬 중요하며 영상의 모든 기하학적 해석은 이 주점을 이용하여 이루어집니다. distCoeffs : 4, 5 또는 8 요소의 왜곡 계수 (k_1, k_2, p_1, p_2[, k_3[, k_4, k_5, k_6]])의 입력 벡터 벡터가 NULL / empty이면, 제로 왜곡 계수가 가정됩니다. (왜곡 보정 관련 링크) rvec : tvec과 함께 모델 좌표계에서 카메라 좌표계로 점을 가져 오는 출력 회전 벡터(Output rotation vector) (Rodrigues() 참조) Rodrigues’ rotation formulaopencv의 solvePnP 함수에서 반환되는 rvec는 Rodrigues를 컴팩트(compact)하게 표현한 벡터입니다. 먼저, Rodrigues가 무엇인지 살펴본 후 opencv에서 사용하는 Rodrigues 표현법에 대해 살펴보겠습니다. 3차원에서 회전변환은 보통 3 × 3 행렬로 표현됩니다. 그런데, Rodrigues를 사용하면 임의의 3차원 회전변환을 4개의 값(회전축 벡터 + 회전각) 만으로 표현할 수 있습니다. 3차원 공간에서 점 p를 회전축 v에 대하여 θ만큼 회전시킨 값은 다음 식에 의해 계산될 수 있는데, 이 식을 Rodrigues’ rotation formula라고 부릅니다 (Rodrigues는 이 식을 만든 프랑스 수학자의 이름). 이 때, v는 단위벡터(unit vector)이어야 하고 회전방향은 오른손 법칙을 따릅니다 (엄지를 펴고 오른손을 쥐었을 때 엄지의 방향이 회전축 방향, 쥔 손가락의 방향이 + 회전방향). 위식을 행렬 형태로 표현하면 다음과 같습니다. 위식으로부터 Rodrigues v = (vx,vy,vz), θ에 대응하는 회전변환 행렬 R이 다음과 같음을 알 수 있습니다. 위식은 우리가 임의의 회전축에 대한 회전을 회전변환 행렬로 표현할 수 있음을 나타냅니다. 반대의 경우로, 임의의 회전변환 행렬에 대한 Rodrigues 표현은 다음 수식을 이용하여 구할 수 있다고 합니다. opencv에서는 회전변환행렬 표현과 Rodrigues 표현 사이의 상호 변환을 위해 Rodrigues()란 함수를 제공합니다. 그런데, opencv에서 사용하는 Rodrigues 표현은 보다 컴팩트(compact)한 형태로서 단 3개의 값만으로 회전변환을 표현합니다. opencv API 설명문서에 따르면 원래 회전변환은 3 자유도이기 때문에 opencv에서는 회전변환을 rod2 = [a, b, c]의 3차원 벡터로 컴팩트하게 표현하고 이로부터 회전각(θ) 및 회전축 벡터(v)는 다음과 같이 추출합니다. 이와같이 solvePnP 함수에서 반환되는 rvec는 Rodrigues에 대한 3차원의 컴팩트한 표현법이므로 회전각 및 회전축을 알기 위해서는 위식을 이용해야 합니다. tvec – 출력 변환 벡터.(Output translation vector.) 12345678910111213141516171819202122232425262728293031def get_default_params(corners, ycoords, xcoords): # page width and height page_width = np.linalg.norm(corners[1] - corners[0]) page_height = np.linalg.norm(corners[-1] - corners[0]) rough_dims = (page_width, page_height) # our initial guess for the cubic has no slope cubic_slopes = [0.0, 0.0] # object points of flat page in 3D coordinates corners_object3d = np.array([ [0, 0, 0], [page_width, 0, 0], [page_width, page_height, 0], [0, page_height, 0]]) # estimate rotation and translation from four 2D-to-3D point # correspondences _, rvec, tvec = cv2.solvePnP(corners_object3d, corners, K, np.zeros(5)) span_counts = [len(xc) for xc in xcoords] params = np.hstack((np.array(rvec).flatten(), np.array(tvec).flatten(), np.array(cubic_slopes).flatten(), ycoords.flatten()) + tuple(xcoords)) return rough_dims, span_counts, params np.hstack은 두 배열을 왼쪽에서 오른쪽으로 붙이는 함수 입니다. 아래 예를 보면 이해가 쉽습니다. 123456789In [1]: import numpy as npIn [2]: a = np.array([1, 2, 3])In [3]: b = np.array([4, 5, 6])In [7]: np.hstack([a, b])Out[7]: array([1, 2, 3, 4, 5, 6]) 결론적으로 cv2.solvePnP에서 취득한 값들을 배열화해 params라는 배열로 리턴합니다. optimize_params1234567891011121314151617181920212223242526def project_xy(xy_coords, pvec): # get cubic polynomial coefficients given # # f(0) = 0, f'(0) = alpha # f(1) = 0, f'(1) = beta alpha, beta = tuple(pvec[CUBIC_IDX]) poly = np.array([ alpha + beta, -2*alpha - beta, alpha, 0]) xy_coords = xy_coords.reshape((-1, 2)) z_coords = np.polyval(poly, xy_coords[:, 0]) objpoints = np.hstack((xy_coords, z_coords.reshape((-1, 1)))) image_points, _ = cv2.projectPoints(objpoints, pvec[RVEC_IDX], pvec[TVEC_IDX], K, np.zeros(5)) return image_points np.polyval함수는 스칼라 값에서 다항식의 해를 구합니다. 기본형은 polyval(p, x)입니다. 첫번째 파라미터 p는 다항식을 의미합니다. 두번째 파라미터 x는 해를 뜻합니다. 예를 들어 np.polyval([1, -2, 1], 2)가 있다면 [1, -2, 1]은 x²-2x+1을 뜻하고 여기에 2를 대입한 결과 1을 리턴합니다.np.polyval([1, -12, 10, 7, -10], 3)가 있다면 [1, -12, 10, 7, -10] 은 x⁴-12x³+10x²+7x-10을 뜻하고 여기에 3을 대입한 결과 -142를 리턴합니다. cv2.projectPoints는 3차원 공간상의 객체의 Pose(rorcpdml dnlcldhk qkdgid)정보를 2차원 화면상의 이미지의 Pose 정보로 변경해 줍니다. 위에서 설명한 월드 좌표계(3D)의 값을 이미지 좌표계(2D)로 변환합니다. 기본형은 아래와 같습니다. 1imagePoints, jacobian = cv2.projectPoints(objectPoints, rvec, tvec, cameraMatrix, distCoeffs[, imagePoints[, jacobian[, aspectRatio]]]) 파라미터의 설명은 cv2.solvePnP에서 설명한 파라미터와 같습니다. 최적화 문제는 함수 f의 값을 최대화 혹은 최소화하는 변수 x의 값 x∗를 찾는 것입니다. 이 값 x∗ 를 최적화 문제의 해(solution)라고 합니다. 만약 최소화 문제를 풀 수 있다면 f(x) 를 −f(x) 로 바꾸어 위아래를 뒤집은 다음 최소화 문제를 풀면 f(x) 의 최대화 문제를 푼 것과 같습니다. 따라서 보통은 최소화 문제만 고려합니다. 최적화에 대한 설명 리스트입니다. scipy-lectures.org 데이터 사이언스 스쿨","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"openCv page Dewarp 분석 -6","slug":"openCV-pageDewarp-06","date":"2020-02-16T23:42:31.000Z","updated":"2022-02-08T02:11:11.813Z","comments":true,"path":"2020/02/17/openCV-pageDewarp-06/","link":"","permalink":"http://jung-max.github.io/2020/02/17/openCV-pageDewarp-06/","excerpt":"","text":"저번 포스트에서는 윤곽선을 합치는 것에대해서 살펴보았습니다. 이번 포스트에서는 키포인트 검출에대해서 살펴보겠습니다. sample_spans1span_points = sample_spans(small.shape, spans) sample_spans 함수로 앞서 만들었던 선(span)에서 포인트가 되는 부분을 생성합니다. input으로는 이미지의 차원 정보(smaa.shape)와 선(span)정보입니다. 123456789101112131415161718192021222324252627282930def sample_spans(shape, spans): span_points = [] for span in spans: contour_points = [] for cinfo in span: yvals = np.arange(cinfo.mask.shape[0]).reshape((-1, 1)) totals = (yvals * cinfo.mask).sum(axis=0) means = totals / cinfo.mask.sum(axis=0) xmin, ymin = cinfo.rect[:2] step = SPAN_PX_PER_STEP start = ((len(means)-1) % step) / 2 contour_points += [(x+xmin, means[x]+ymin) for x in range(start, len(means), step)] contour_points = np.array(contour_points, dtype=np.float32).reshape((-1, 1, 2)) contour_points = pix2norm(shape, contour_points) span_points.append(contour_points) return span_points 함수를 보면 for문을 통해서 선(span)의 윤곽선 정보를 하나씩 추출합니다. 처음으로 np.arange함수를 통해서 yvals를 구합니다. np.arange는 기본형 np.arange([start, ] stop, [step, ] dtype=None)로 stop은 필수이고 start와 step등은 선택입니다. start와 step이 설정되지 않으면 start = 0, step = 1입니다. 기능은 stop까지의 값을 array형태로 반환하는 것입니다. 여기서 input으로 들어온 값을 살펴보면 cinfo.mask의 차원을 리턴합니다. mask는 윤곽선이 그려져있는 작은 이미지입니다. 이미지 배열에서 shape를 하게되면 리턴의 뜻은 (y축, x축)입니다. 여기서는 y축의 값을 reshape를 통해 n x 1 차원의 배열로 재배열 합니다. 아래 예를 보면 이해가 빠릅니다. 123456cinfo.mask.shape = (5, 19)yvals = [[0] [1] [2] [3] [4]] 다음은 y축의 중간값을 구합니다. 윤곽선은 두께가 있기 때문에 윤곽선의 중심의 y축 좌표를 구하기 위해서 계산을 합니다. 앞서 구한 y축 값을 실제 이미지에 곱해 줍니다. 그러고 곱해준 값을 x축을 기준으로한 y축의 합과 나누면 중간값(평균값)을 취득할 수 있습니다. 123456789101112totals = (yvals * cinfo.mask).sum(axis=0)# yvals * cinfo.mask = [[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]# [0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]# [2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2]# [0 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3]# [0 4 4 4 4 4 4 4 4 4 4 4 0 0 0 0 0 0 0]]# totals = [ 2 9 10 10 10 10 10 10 10 10 10 10 6 6 6 6 6 6 6]means = totals // cinfo.mask.sum(axis=0)# cinfo.mask.sum(axis=0) = [1 3 4 4 4 4 4 4 4 5 5 5 4 4 4 4 4 4 4]# means = [2 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1] 다음으로 포인트의 좌표를 특정하기 위한 작업을 합니다. 처음으로 xmin, ymin = cinfo.rect[:2]를 통해 윤곽선을 둘러싸는 사각형의 좌측 상단 포인트 좌표 취득합니다. 여기서 기준이 되는 이미지 mask는 (0,0)을 기준으로한 이미지기 때문에 실제 좌표에 대입하기 위해서 xmin과 ymin을 더해줄 필요가 있습니다. 다음으로 start지점과 20px마다의 점의 좌표를 구합니다. 12345step = SPAN_PX_PER_STEPstart = ((len(means)-1) % step) // 2contour_points += [(x+xmin, means[x]+ymin) for x in range(start, len(means), step)] 다음으로 이미지에 대입할 실제값을 구하는 작업을 합니다. reshape((-1, 1, 2)의 의미는 opencv에서 쓰는 배열의 모양이 (x, 1, y)이기 때문입니다. 관련 자료는 여기를 참고하세요. 1234567891011# contour_points = [(365, 588), (385, 587), (405, 588)]contour_points = np.array(contour_points, dtype=np.float32).reshape((-1, 1, 2))# contour_points = [[[365. 588.]]# [[385. 587.]]# [[405. 588.]]]contour_points = pix2norm(shape, contour_points)# contour_points = [[[0.36753446 0.8009189 ]]# [[0.4287902 0.7978561 ]]# [[0.49004596 0.8009189 ]]] keypoints_from_samples1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def keypoints_from_samples(name, small, pagemask, page_outline, span_points): all_evecs = np.array([[0.0, 0.0]]) all_weights = 0 for points in span_points: _, evec = cv2.PCACompute(points.reshape((-1, 2)), None, maxComponents=1) weight = np.linalg.norm(points[-1] - points[0]) all_evecs += evec * weight all_weights += weight evec = all_evecs / all_weights x_dir = evec.flatten() if x_dir[0] &lt; 0: x_dir = -x_dir y_dir = np.array([-x_dir[1], x_dir[0]]) pagecoords = cv2.convexHull(page_outline) pagecoords = pix2norm(pagemask.shape, pagecoords.reshape((-1, 1, 2))) pagecoords = pagecoords.reshape((-1, 2)) px_coords = np.dot(pagecoords, x_dir) py_coords = np.dot(pagecoords, y_dir) px0 = px_coords.min() px1 = px_coords.max() py0 = py_coords.min() py1 = py_coords.max() p00 = px0 * x_dir + py0 * y_dir p10 = px1 * x_dir + py0 * y_dir p11 = px1 * x_dir + py1 * y_dir p01 = px0 * x_dir + py1 * y_dir corners = np.vstack((p00, p10, p11, p01)).reshape((-1, 1, 2)) ycoords = [] xcoords = [] for points in span_points: pts = points.reshape((-1, 2)) px_coords = np.dot(pts, x_dir) py_coords = np.dot(pts, y_dir) ycoords.append(py_coords.mean() - py0) xcoords.append(px_coords - px0) if DEBUG_LEVEL &gt;= 2: visualize_span_points(name, small, span_points, corners) return corners, np.array(ycoords), xcoords keypoints_from_samples함수에서는 일단 cv2.PCACompute를 통해 고유 벡터를 추출합니다. 그 후 norm을 통해 벡터의 크기를 구합니다.(norm 참고) 정해 진 값들을 통해 span의 평균 고유벡터를 추출합니다. 1234567891011evec = all_evecs / all_weights# evec = [[0.999134 0.00630164]]x_dir = evec.flatten()# x_dir = [0.999134 0.00630164]if x_dir[0] &lt; 0: x_dir = -x_diry_dir = np.array([-x_dir[1], x_dir[0]])# y_dir = [-0.00630164 0.999134 ] x_dir과 y_dir값을 보면 앞서 본 SVD(특이점 분해)에서 왼쪽 특이 벡터값과 비슷한 유형을 보입니다. 1pagecoords = cv2.convexHull(page_outline) cv2.convexHull는 외곽선의 오목한 부분을 볼록하게 만들어 줍니다. 아래 이미지를 참고 합니다. page_outline은 mask 사각형의 4꼭지점 입니다.(관련 포스트) 12345pagecoords = cv2.convexHull(page_outline)# pagecoords1 = [[[440 633]]# [[ 50 633]]# [[ 50 20]]# [[440 20]]] cv2.convexHull(page_outline)을 통해 mask의 4 꼭지점을 구합니다. 12345678910111213141516171819202122232425 # pagemask.shap = (653, 490) # pagecoords.reshape((-1, 1, 2)) = [[[440 633]] # [[ 50 633]] # [[ 50 20]] # [[440 20]]] pagecoords = pix2norm(pagemask.shape, pagecoords.reshape((-1, 1, 2))) # pagecoords = [[[ 0.59724349 0.93874426]] # [[-0.59724349 0.93874426]] # [[-0.59724349 -0.93874426]] # [[ 0.59724349 -0.93874426]]]def pix2norm(shape, pts): height, width = shape[:2] scl = 2.0/(max(height, width)) #scl = 0.0030627871362940277 offset = np.array([width, height], dtye=pts.dtype).reshape((-1, 1, 2))*0.5 # offset = [[[245. 326.5]]] return (pts - offset) * scl # pts - offset = [[[ 195. 306.5]] # [[-195. 306.5]] # [[-195. -306.5]] # [[ 195. -306.5]]] pix2norm는 첫번째 파라미터 값(pagemask)의 높이와 폭을 각각 height, width에 저장합니다.그후 높이와 폭중 큰값(여기선 653)을 2와 나누어 scl값을 구해줍니다. pagemask.shap은 pagemask의 크기가 됩니다. 123456789101112131415161718192021222324252627 pagecoords = pagecoords.reshape((-1, 2))# pagecoords = [[ 0.59724349 0.93874426]# [-0.59724349 0.93874426]# [-0.59724349 -0.93874426]# [ 0.59724349 -0.93874426]]px_coords = np.dot(pagecoords, x_dir)py_coords = np.dot(pagecoords, y_dir)# px_coords = [ 0.60264191 -0.59081064 -0.60264191 0.59081064] # py_coords = [ 0.93416769 0.94169492 -0.93416769 -0.94169492]px0 = px_coords.min()px1 = px_coords.max()py0 = py_coords.min()py1 = py_coords.max()p00 = px0 * x_dir + py0 * y_dirp10 = px1 * x_dir + py0 * y_dirp11 = px1 * x_dir + py1 * y_dirp01 = px0 * x_dir + py1 * y_dircorners = np.vstack((p00, p10, p11, p01)).reshape((-1, 1, 2))# corners = [[[-0.60559029 -0.93613581]]# [[ 0.59682445 -0.94174861]]# [[ 0.60559029 0.93613581]]# [[-0.59682445 0.94174861]]] corners를 검출하는 작업을 진행합니다. corners는 외곽선을 뜻합니다. np.vstack은 열의 수가 같은 두 개 이상의 배열을 위아래로 연결하여 행의 수가 더 많은 배열을 만듭니다. 연결할 배열은 마찬가지로 하나의 리스트에 담아야 합니다. 1234567891011121314151617181920In [39]:b1 = np.ones((2, 3))b1array([[1., 1., 1.], [1., 1., 1.]])In [40]:b2 = np.zeros((3, 3))b2array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])In [41]:np.vstack([b1, b2])array([[1., 1., 1.], [1., 1., 1.], [0., 0., 0.], [0., 0., 0.], [0., 0., 0.]])","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"openCv page Dewarp 분석 -5","slug":"openCV-pageDewarp-05","date":"2020-02-14T02:17:12.000Z","updated":"2022-02-08T02:11:11.813Z","comments":true,"path":"2020/02/14/openCV-pageDewarp-05/","link":"","permalink":"http://jung-max.github.io/2020/02/14/openCV-pageDewarp-05/","excerpt":"","text":"저번 포스트에서는 윤곽선 검출에 대해서 살펴보았습니다. 이번 포스트에서는 윤곽선을 합치는 것에대해서 살펴보겠습니다. assemble_spans1spans = assemble_spans(name, small, pagemask, cinfo_list) assemble_spans()를 통해 윤곽선을 합치게 됩니다. input으로는 파일 이름, resize된 이미지, 마스킹을 위한 이미지, 윤곽선 정보 클래스가 들어갑니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061def assemble_spans(name, small, pagemask, cinfo_list): # sort list cinfo_list = sorted(cinfo_list, key=lambda cinfo: cinfo.rect[1]) # generate all candidate edges candidate_edges = [] for i, cinfo_i in enumerate(cinfo_list): for j in range(i): # note e is of the form (score, left_cinfo, right_cinfo) edge = generate_candidate_edge(cinfo_i, cinfo_list[j]) if edge is not None: candidate_edges.append(edge) # sort candidate edges by score (lower is better) candidate_edges.sort() # for each candidate edge for _, cinfo_a, cinfo_b in candidate_edges: # if left and right are unassigned, join them if cinfo_a.succ is None and cinfo_b.pred is None: cinfo_a.succ = cinfo_b cinfo_b.pred = cinfo_a # generate list of spans as output spans = [] # until we have removed everything from the list while cinfo_list: # get the first on the list cinfo = cinfo_list[0] # keep following predecessors until none exists while cinfo.pred: cinfo = cinfo.pred # start a new span cur_span = [] width = 0.0 # follow successors til end of span while cinfo: # remove from list (sadly making this loop *also* O(n^2) cinfo_list.remove(cinfo) # add to span cur_span.append(cinfo) width += cinfo.local_xrng[1] - cinfo.local_xrng[0] # set successor cinfo = cinfo.succ # add if long enough if width &gt; SPAN_MIN_WIDTH: spans.append(cur_span) if DEBUG_LEVEL &gt;= 2: visualize_spans(name, small, pagemask, spans) return spans 기본적으로 함수의 이름인 assemble_spans은 폭을 모아준다는 뜻입니다. 이전 윤곽선 정보를 모은 최종적인 그림은 아래와 같습니다. 그림을 살펴보면 각 윤곽선 마다 색깔이 틀린 것을 알 수 있습니다. 같은 가로줄에 있어도 윤곽선이 연속되있이 않다고 판단하기 때문입니다. 원할환 처리를 위해서는 같은 가로줄의 윤곽선을 모아줄 필요가 있습니다. 윤곽선 정렬cinfo_list = sorted(cinfo_list, key=lambda cinfo: cinfo.rect[1]) 첫번째로 등장하는 것은 정렬입니다. sorted는 배열을 정렬된 리스트로 리턴해 줍니다. sort와 다른점은 원본은 유지된다는 것입니다. key=lambda cinfo: cinfo.rect[1]의 뜻은 cinfo.rect[1](ymin : 좌측 상단의 y값)에 대해서 정렬(내림차순)을 한다는 의미입니다. 윤곽선 후보군 선출123456for i, cinfo_i in enumerate(cinfo_list): for j in range(i): # range(i)는 0~(i-1)까지 # note e is of the form (score, left_cinfo, right_cinfo) edge = generate_candidate_edge(cinfo_i, cinfo_list[j]) if edge is not None: candidate_edges.append(edge) 위 for문은 각 윤곽선에 대해서 점수를 부여합니다. edge가 될 수 있는 후보군을 선출하고 알고리즘에 맞춘 점수를 부여합니다. 12345678910111213141516171819202122232425262728293031def generate_candidate_edge(cinfo_a, cinfo_b): # we want a left of b (so a's successor will be b and b's # predecessor will be a) make sure right endpoint of b is to the # right of left endpoint of a. if cinfo_a.point0[0] &gt; cinfo_b.point1[0]: tmp = cinfo_a cinfo_a = cinfo_b cinfo_b = tmp x_overlap_a = cinfo_a.local_overlap(cinfo_b) x_overlap_b = cinfo_b.local_overlap(cinfo_a) overall_tangent = cinfo_b.center - cinfo_a.center overall_angle = np.arctan2(overall_tangent[1], overall_tangent[0]) delta_angle = max(angle_dist(cinfo_a.angle, overall_angle), angle_dist(cinfo_b.angle, overall_angle)) * 180/np.pi # we want the largest overlap in x to be small x_overlap = max(x_overlap_a, x_overlap_b) dist = np.linalg.norm(cinfo_b.point0 - cinfo_a.point1) if (dist &gt; EDGE_MAX_LENGTH or x_overlap &gt; EDGE_MAX_OVERLAP or delta_angle &gt; EDGE_MAX_ANGLE): return None else: score = dist + delta_angle*EDGE_ANGLE_COST return (score, cinfo_a, cinfo_b) 첫번째 조건문은 주석에서 말한 것 처럼 윤곽선의 포인트를 비교해서 가장 좌측에 있는 윤곽선을 cinfo_a로 오게 합니다. 그래서 a의 계승자(successor)는 b가되고 b의 전임자(predecessor)는 a로 간주합니다. 1234567x_overlap_a = cinfo_a.local_overlap(cinfo_b)x_overlap_b = cinfo_b.local_overlap(cinfo_a)... # we want the largest overlap in x to be smallx_overlap = max(x_overlap_a, x_overlap_b) a와 b를 b와 a의 윤곽선을 포개어서 차이를 측정합니다. 측정한 것 중에 차이가 더 큰것을 x_overlap에 저장합니다. 그후 두 윤곽선의 각도의 차이를 계산한 후 노름(norm)함수를 통해서 길이를 구합니다. Norm(노름) : 벡터의 길이 혹은 크기를 측정하는 방법(함수)입니다. Norm이 측정한 벡터의 크기는 원점에서 벡터 좌표까지의 거리 혹은 Magnitude라고 합니다. 1234567if (dist &gt; EDGE_MAX_LENGTH or x_overlap &gt; EDGE_MAX_OVERLAP or delta_angle &gt; EDGE_MAX_ANGLE): return Noneelse: score = dist + delta_angle*EDGE_ANGLE_COST return (score, cinfo_a, cinfo_b) 거리가 100보다 크거나 제일큰 측정 간격 차이가 1보다 크거나 각도가 윤곽선 각도 차이가 7.5도 이상이 아니라면 해당 윤곽선들에 점수(score)를 매깁니다.해당 이유는 위 조건이 충족되지 않으면 연속적인 가로줄이라고 보기 힘들다고 판단하기 때문입니다. 윤곽선의 계승자와 전임자 설정123456789# sort candidate edges by score (lower is better)candidate_edges.sort()# for each candidate edgefor _, cinfo_a, cinfo_b in candidate_edges: # if left and right are unassigned, join them if cinfo_a.succ is None and cinfo_b.pred is None: cinfo_a.succ = cinfo_b cinfo_b.pred = cinfo_a 전에 측정한 점수(score)는 작은 값일 수록 더 좋다고 판단합니다. 그렇기 때문에 sort()로 정렬을 합니다. 그다음 for문을 통해 후보군 중 서로의 정보가 저장되있지 않는 후보군들의 윤곽선 정보 클래스에 서로의 정보를 저장합니다. 12345678910111213141516171819202122232425262728293031# generate list of spans as outputspans = []# until we have removed everything from the listwhile cinfo_list: # get the first on the list cinfo = cinfo_list[0] # keep following predecessors until none exists while cinfo.pred: cinfo = cinfo.pred # start a new span cur_span = [] width = 0.0 # follow successors til end of span while cinfo: # remove from list (sadly making this loop *also* O(n^2) cinfo_list.remove(cinfo) # add to span cur_span.append(cinfo) width += cinfo.local_xrng[1] - cinfo.local_xrng[0] # set successor cinfo = cinfo.succ # add if long enough if width &gt; SPAN_MIN_WIDTH: spans.append(cur_span) 이제 최종적으로 윤곽선을 붙이는 작업을 시작합니다. 앞에서 서로 이어 붙이기가 가능한 윤곽선 끼리는 서로의 정보를 cinfo.pred와 cinfo.succ로 저장했습니다.(윤곽선의 앞, 뒤정보) 이제 윤곽선을 while문으로 하나씩 탐색합니다. 12while cinfo.pred: cinfo = cinfo.pred 처음으로 가장 끝에있는 전임자(pred)를 찾습니다. 1234567891011121314151617 # follow successors til end of span while cinfo: # remove from list (sadly making this loop *also* O(n^2) cinfo_list.remove(cinfo) # add to span cur_span.append(cinfo) width += cinfo.local_xrng[1] - cinfo.local_xrng[0] # set successor cinfo = cinfo.succ``` 그러고 그 정보를 원래의 윤곽선 정보클래스(cinfo_list)에서 제거합니다. 그후 `cur_span`배열에 내용을 저장합니다. 그후 후임자(succ)로 이동하여(앞으로 이동) 계속 같은 작업을 반복합니다.```py # add if long enough if width &gt; SPAN_MIN_WIDTH: spans.append(cur_span) 마지막 까지 정보를 취합하고 총 넓이가 충분한지 판단합니다. 넓이가 충분하다면 값을 저장합니다. visualize_spans디버깅을 위해 생성한 span을 이미지를 통해 보여줍니다. 12345678def visualize_spans(name, small, pagemask, spans): regions = np.zeros_like(small) for i, span in enumerate(spans): contours = [cinfo.contour for cinfo in span] cv2.drawContours(regions, contours, -1, CCOLORS[i*3 % len(CCOLORS)], -1) 일단 이미지와 같은 크기의 (0으로 채운)배열을 생성합니다. 그후 for문을 통해 윤곽선을 그려줍니다. 1234567mask = (regions.max(axis=2) != 0)display = small.copy()display[mask] = (display[mask]/2) + (regions[mask]/2)display[pagemask == 0] /= 4debug_show(name, 2, 'spans', display) 다음으로 윤곽선이 그려진 좌표만을 mask배열에 저장합니다. resions는 기본적으로 검정색 배경(0,0,0)에 윤곽선이 그려진 형태이기 때문에 max(axis=2) != 0으로 판단하면 윤곽선의 좌표만을 취득할 수 있습니다. 그것을 기존 이미지에 덮습니다. 일단 기존이미지의 윤곽선 부분을 흐릿하게 만듭니다. 방법은 mask의 좌표 부분만 2를 나누어(display[mask]/2) 검정에 가깝게 만듭니다. 역시 기존 이미지에 윤곽선 부분(mask)에 색깔을 입힌 것(regions[mask]/2)을 설정합니다. 두 이미지를 합쳐 형광펜처럼 색깔을 입힌 후 테두리 부분을 나누기 4(display[pagemask == 0] //= 4)를 해서 액자처럼 테두리를 어둡게 만듭니다. 텍스트가 부족할때텍스트가 부족해서 충분한 윤곽선(3개 이상)이 확보되지 않으면 이미지에서 가로줄을 탐색합니다. 123456if len(spans) &lt; 3: print (' detecting lines because only', len(spans), 'text spans') cinfo_list = get_contours(name, small, pagemask, 'line') spans2 = assemble_spans(name, small, pagemask, cinfo_list) if len(spans2) &gt; len(spans): spans = spans2 아래 이미지처럼 텍스트로 가로 윤곽선이 부족하고 line을통해 찾을 수 있다면 line을 탐색합니다. 123if len(spans) &lt; 1: print ('skipping', name, 'because only', len(spans), 'spans') continue text와 line 모두 윤곽선 탐색이 불가능하면 page dewarp 작업을 중지합니다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"openCv page Dewarp 분석 -4","slug":"openCV-pageDewarp-04","date":"2020-02-12T06:21:07.000Z","updated":"2022-02-08T02:11:11.813Z","comments":true,"path":"2020/02/12/openCV-pageDewarp-04/","link":"","permalink":"http://jung-max.github.io/2020/02/12/openCV-pageDewarp-04/","excerpt":"","text":"저번 포스트에 이어서 계속 윤곽선 정보 검출에 대해서 알아보겠습니다. 1234567891011121314151617181920212223242526272829303132def get_contours(name, small, pagemask, masktype): mask = get_mask(name, small, pagemask, masktype) if DEBUG_LEVEL &gt;= 3: debug_show(name, 0.7, 'get_mask', mask) contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) contours_out = [] for contour in contours: rect = cv2.boundingRect(contour) xmin, ymin, width, height = rect if (width &lt; TEXT_MIN_WIDTH or height &lt; TEXT_MIN_HEIGHT or width &lt; TEXT_MIN_ASPECT*height): continue tight_mask = make_tight_mask(contour, xmin, ymin, width, height) if tight_mask.sum(axis=0).max() &gt; TEXT_MAX_THICKNESS: continue contours_out.append(ContourInfo(contour, rect, tight_mask)) if DEBUG_LEVEL &gt;= 2: visualize_contours(name, small, contours_out) return contours_out 윤곽선 검출1contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) openCV에서 윤곽선 검출은 cv2.findContours함수를 통해 이루어집니다. 기본형은 contours, hierarchy = findContours(image, mode, method, contours=None, hierarchy=None, offset=None)입니다. 리턴형은 다음을 뜻합니다. contours : 검출된 윤곽선 hierarchy : 계층 구조 파라미터는 다음을 뜻합니다. image : 이미지 mode : 윤곽선을 검출해 어떤 계층 구조의 형태를 사용할지 설정 cv2.RETR_EXTERNAL : 최외곽 윤곽선만 검색 method : 윤곽점의 표시 방법을 설정 cv2.CHAIN_APPROX_NONE : 검출된 윤곽선의 모든 윤곽점들을 좌푯값으로 반환한다. 반환된 좌푯값을 중심으로 8개의 이웃 중 하나 이상의 윤곽점들이 포함되 있습니다. 12345678910for contour in contours: rect = cv2.boundingRect(contour) xmin, ymin, width, height = rect if (width &lt; TEXT_MIN_WIDTH or height &lt; TEXT_MIN_HEIGHT or width &lt; TEXT_MIN_ASPECT*height): continue... for문을 통해서 윤곽선 정보를 하나식 처리합니다. 첫번째로 cv2.boundingRect함수를 통해 윤곽선 경계의 사각형을 그립니다. 윤곽선의 경계면을 둘러싸는 사각형을 구합니다. 반환되는 결과는 회전이 고려되지 않은 직사각형 형태를 띠는데, 경계면의 윤곽점들을 둘러싸는 최소 사각형의 형태를 뜁니다. openCV에서 좌표는 좌측 상단이 0,0 x축이 늘어나면 오른쪽으로, y축이 늘어나면 아래쪽으로 좌표가 이동됩니다. 따라서 사각형은 아래와 같이 표현할 수 있습니다. xmin, ymin : 사각형 좌측 상단 좌표 xmin + width, ymin + height : 사각형 우측 하단 좌표 다음 조건문을 통해서 외곽선을 분석해서 너무 길거나(15이상 또는 높이의 1.5배 이상) 텍스트가 되기엔 너무 두꺼운(2이상) 얼룩은 무시합니다. 윤곽선을 담은 최소크기의 이미지를 생성1tight_mask = make_tight_mask(contour, xmin, ymin, width, height) make_tight_mask을 통해서 윤곽선만을 담은 그림을 생성합니다. 12345678910def make_tight_mask(contour, xmin, ymin, width, height): tight_mask = np.zeros((height, width), dtype=np.uint8) tight_contour = contour - np.array((xmin, ymin)).reshape((-1, 1, 2)) cv2.drawContours(tight_mask, [tight_contour], 0, (1, 1, 1), -1) return tight_mask np.zeros((height, width), dtype=np.uint8)를 통해 높이, 넓이 만큼의 0으로 채워진 배열을 생성합니다.(윤곽선을 감싼 사각형 만큼의 캔버스 느낌으로) tight_contour = contour - np.array((xmin, ymin)).reshape((-1, 1, 2))에서 reshape는 새로운 차원의 배열을 생성합니다. 여기서 새로운 형태의 배열은 데이터의 총 갯수가 같아야합니다. -1의 의미는 다른 요소를 먼저 설정하고 거기에 최적화된 값으로 자동 선택 됩니다. 여기서는 (x, 1, 2)가 선정되고 x값은 자동 선택됩니다. tight_contour는 윤곽선을 좌측 상단(0,0)을 기준으로 한 좌표로 최대한 이동해서 그린 선의 좌표가 됩니다. cv2.drawContours(tight_mask, [tight_contour], 0, (1, 1, 1), -1)은 윤곽선을 그리는 함수입니다. 기본형은 drawContours(image, contours, contourIdx, color, thickness=None, lineType=None, hierarchy=None, maxLevel=None, offset=None)입니다. 여기서 contourIdx는 지정된 윤곽선 번호만 그림니다. 음수면 모든 윤곽선을 그립니다. 여기서는 0이기 때문에 첫번째 윤곽선을 그립니다. 결론적으로 윤곽선을 담은 최소크기의 이미지를 생성해서 리턴합니다. 윤곽선 결과 리턴123456789 if tight_mask.sum(axis=0).max() &gt; TEXT_MAX_THICKNESS: continue contours_out.append(ContourInfo(contour, rect, tight_mask))if DEBUG_LEVEL &gt;= 2: visualize_contours(name, small, contours_out)return contours_out sum(axis=0)의 뜻은 x축의 모든 요소를 더해서 배열로 만드는 것입다. 여기서는 x=0의 모든 y값을 더함. x=1의 모든 y값을 더함 …. 결국 같은 x축의 y값의 합이므로 두께가 됩니다. max는 요소중 최댓값을 구합니다. 결국 제일 두꺼운 값을 구합니다. text의 제일 두꺼운 길이를 10을 기준으로 했기 때문에 이보다 두꺼우면 text라 보지 않고 무시합니다. 최종적으로 append를 사용해서 contours_out에 자료를 추가한 후 리턴하게 됩니다. ContourInfo1234567891011121314151617181920212223242526272829303132class ContourInfo(object): def __init__(self, contour, rect, mask): self.contour = contour self.rect = rect self.mask = mask self.center, self.tangent = blob_mean_and_tangent(contour) self.angle = np.arctan2(self.tangent[1], self.tangent[0]) clx = [self.proj_x(point) for point in contour] lxmin = min(clx) lxmax = max(clx) self.local_xrng = (lxmin, lxmax) self.point0 = self.center + self.tangent * lxmin self.point1 = self.center + self.tangent * lxmax self.pred = None self.succ = None def proj_x(self, point): return np.dot(self.tangent, point.flatten()-self.center) def local_overlap(self, other): xmin = self.proj_x(other.point0) xmax = self.proj_x(other.point1) return interval_measure_overlap(self.local_xrng, (xmin, xmax)) ContourInfo클래스는 윤곽선의 정보를 담은 클래스입니다. input으로는 contour(윤곽선), rect(윤곽선을 둘러싼 사각형), mask(윤곽선만을 담은 작은 그림(배경은 검정(0))을 받습니다. 1234567891011121314151617181920def blob_mean_and_tangent(contour): moments = cv2.moments(contour) area = moments['m00'] mean_x = moments['m10'] / area mean_y = moments['m01'] / area moments_matrix = np.array([ [moments['mu20'], moments['mu11']], [moments['mu11'], moments['mu02']] ]) / area _, svd_u, _ = cv2.SVDecomp(moments_matrix) center = np.array([mean_x, mean_y]) tangent = svd_u[:, 0].flatten().copy() return center, tangent blob_mean_and_tangent은 무게중심과 탄젠트값을 구하기 위한 함수입니다. cv2.moments(contour)를 통해서 윤곽선의 모멘트값을 구합니다. 모멘트는 1XN 또는 Nx1의 형태, contour는 1xN입니다. 이미지 모멘트는 컨투어에 관한 특징값을 뜻합니다. OpenCV에서는 moments 함수로 이미지 모멘트를 구합니다. 컨투어 포인트 배열을 입력하면 해당 컨투어의 모멘트를 딕셔너리 타입으로 반환합니다. 반환하는 모멘트는 총 24개로 10개의 위치 모멘트, 7개의 중심 모멘트, 7개의 정규화된 중심 모멘트로 이루어져 있습니다. Spatial Moments : M00, M01, M02, M03, M10, M11, M12, M20, M21, M30 Central Moments : Mu02, Mu03, Mu11, Mu12, Mu20, Mu21, Mu30 Central Normalized Moments : Nu02, Nu03, Nu11, Nu12, Nu20, Nu21, Nu30 moments[&#39;m00&#39;]는 0차 모멘트로서 폐곡선의 면적을 뜻합니다. 12mean_x = moments['m10'] / area mean_y = moments['m01'] / area 위 부분은 윤곽선의 무게 중심을 구합니다. 다음은 2차 중심 모멘트의 covariance matrix(공분산 행렬)를 구합니다.해당 설명은 여기를 참조하세요. 1234moments_matrix = np.array([ [moments['mu20'], moments['mu11']], [moments['mu11'], moments['mu02']]]) / area _, svd_u, _ = cv2.SVDecomp(moments_matrix)를 사용해서 계산된 왼쪽 특이 벡터값을 구합니다.(calculated left singular vectors) cv2.SVDecomp의 설명은 링크를 참조하세요.SVD 특이값 분해설명입니다. 위키 설명openCV의 PCA설명입니다.PCA 설명입니다. 간단히 설명하면 PCA란 분포되어 있는 여러 데이터(좌표)의 의미있는 선 또는 축을 찾는 것 입니다.공분산 행렬은 데이터의 분포 형태를 나타냅니다. x축과 y축의 분산은 각 변수의 분산으로 표현되고, 대각선 방향의 분산은 공분산으로 표현됩니다. 위 그림은 여기를 참조했습니다. 위 그림에서 e₁ = svd_u으로 보면 가장 분산이 큰 방향의 벡터입니다. tangent = svd_u[:, 0].flatten().copy()에서 svd_u[:, 0]의 의미는 열에서 인덱스가 0인 값을 추출하는 것입니다.flatten()은 배열을 1차원으로 만들어 줍니다. 결과적으로 [[x₁, y₁] [x₂, y₂]]를 [x₁, x₂]로 변환합니다. 다음은 실제적인 한 윤곽선에 대한 결과값입니다. 12345moments_matrix = [[86.45154677 2.15778746] [ 2.15778746 1.94461791]]svd_u = [[ 0.99967459 -0.02550892] [ 0.02550892 0.99967459]]tangent = [0.99967459 0.02550892] self.angle = np.arctan2(self.tangent[1], self.tangent[0]) 아크탄젠트를 통해서 각도를 구합니다.아크탄젠트의 기본형은 p = np.arctan2(y,x)입니다. 12def proj_x(self, point): return np.dot(self.tangent, point.flatten()-self.center) np.dot()은 행렬의 곱을 뜻합니다. input으로 받는 point는 윤곽선의 좌표를 뜻합니다.함수를 풀어보면 tangent와 윤곽선 좌표에서 무게중심을 뺀 좌표값을 핼렬의 곱 연산을 합니다. 그후 나온 결과를 proj_x로 돌려줍니다. 123self.point0 = self.center + self.tangent * lxminself.point1 = self.center + self.tangent * lxmax point0은 x축은 contour의 좌측끝, y축은 contour의 중간을 뜻합니다. point1은 x축은 contour의 우측끝, y축은 contour의 중간을 뜻합니다. 1234567 def local_overlap(self, other): xmin = self.proj_x(other.point0) xmax = self.proj_x(other.point1) return interval_measure_overlap(self.local_xrng, (xmin, xmax))def interval_measure_overlap(int_a, int_b): return min(int_a[1], int_b[1]) - max(int_a[0], int_b[0]) local_overlap은 input값 두개의 차이값을 돌려줍니다. 여기서 차이 값은 x좌표에 한합니다. visualize_contours디버그를 위해 이미지에서 윤곽선을 보여주기 위해서 사용하는 함수입니다. 12345678910111213141516171819202122232425def visualize_contours(name, small, cinfo_list): regions = np.zeros_like(small) for j, cinfo in enumerate(cinfo_list): cv2.drawContours(regions, [cinfo.contour], 0, CCOLORS[j % len(CCOLORS)], -1) mask = (regions.max(axis=2) != 0) display = small.copy() display[mask] = (display[mask]/2) + (regions[mask]/2) for j, cinfo in enumerate(cinfo_list): color = CCOLORS[j % len(CCOLORS)] color = tuple([c/4 for c in color]) cv2.circle(display, fltp(cinfo.center), 3, (255, 255, 255), 1, cv2.LINE_AA) cv2.line(display, fltp(cinfo.point0), fltp(cinfo.point1), (255, 255, 255), 1, cv2.LINE_AA) debug_show(name, 1, 'contours', display) regions = np.zeros_like(small) : np.zeros_like는 input array와 같은 크기를 가지는 0으로 채워진 배열을 생성합니다. enumerate : 반복문을 사용할때 몇번째 반복문인지 알 필요가 있을때 사용합니다. j값은 0~ 순서를 나타냅니다. cv2.drawContours(regions, [cinfo.contour], 0, CCOLORS[j % len(CCOLORS)], -1) : for문을 통해 윤곽선에 색깔을 입힙니다. 결과는 아래와 같습니다. mask = (regions.max(axis=2) != 0) : max(axis=2) : z축 기준으로 각열의 요소를 그룹으로 해서 그중 제일 큰 값을 나타냅니다. axis에 관해서 더 알아보고 싶으면 여기를 참고 바랍니다. display[mask] = (display[mask]/2) + (regions[mask]/2) : 색깔을 입히는 작업을 합니다. 아래 그림을 참고 하세요. 마지막으로 cv2.circle을 통해 무게 중심점을 찍고 cv2.line을 통해 하얀 선을 그립니다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"openCv page Dewarp 분석 -3","slug":"openCV-pageDewarp-03","date":"2020-02-12T05:12:08.000Z","updated":"2022-02-08T02:11:11.812Z","comments":true,"path":"2020/02/12/openCV-pageDewarp-03/","link":"","permalink":"http://jung-max.github.io/2020/02/12/openCV-pageDewarp-03/","excerpt":"","text":"지난 포스트에서는 마스킹 이미지 생성을 알아보았습니다. 이번 포스트에서는 윤곽선 정보 검출에 대해서 알아보겠습니다. 윤곽선 검출12# 윤곽선 정보 검출cinfo_list = get_contours(name, small, pagemask, 'text') get_contours() 함수를 통해 윤곽선 정보를 취득합니다. 파라미터로는 name : 파일 이름 small : 이미지 pagemask : 마스킹을 위한 이미지(2번째 포스트에서 생성한) ‘text’ : text 이미지를 검출하기 위한 설정. text가 아니라면 함수내에서 line으로 다시 검색합니다. 1234567891011121314151617181920212223242526272829303132def get_contours(name, small, pagemask, masktype): mask = get_mask(name, small, pagemask, masktype) if DEBUG_LEVEL &gt;= 3: debug_show(name, 0.7, 'get_mask', mask) contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE) contours_out = [] for contour in contours: rect = cv2.boundingRect(contour) xmin, ymin, width, height = rect if (width &lt; TEXT_MIN_WIDTH or height &lt; TEXT_MIN_HEIGHT or width &lt; TEXT_MIN_ASPECT*height): continue tight_mask = make_tight_mask(contour, xmin, ymin, width, height) if tight_mask.sum(axis=0).max() &gt; TEXT_MAX_THICKNESS: continue contours_out.append(ContourInfo(contour, rect, tight_mask)) if DEBUG_LEVEL &gt;= 2: visualize_contours(name, small, contours_out) return contours_out get maskmask = get_mask(name, small, pagemask, masktype)를 통해서 mask를 취득합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445def get_mask(name, small, pagemask, masktype): sgray = cv2.cvtColor(small, cv2.COLOR_RGB2GRAY) if masktype == 'text': mask = cv2.adaptiveThreshold(sgray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, ADAPTIVE_WINSZ, 25) if DEBUG_LEVEL &gt;= 3: debug_show(name, 0.1, 'thresholded', mask) mask = cv2.dilate(mask, box(9, 1)) if DEBUG_LEVEL &gt;= 3: debug_show(name, 0.2, 'dilated', mask) mask = cv2.erode(mask, box(1, 3)) if DEBUG_LEVEL &gt;= 3: debug_show(name, 0.3, 'eroded', mask) else: mask = cv2.adaptiveThreshold(sgray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, ADAPTIVE_WINSZ, 7) if DEBUG_LEVEL &gt;= 3: debug_show(name, 0.4, 'thresholded', mask) mask = cv2.erode(mask, box(3, 1), iterations=3) if DEBUG_LEVEL &gt;= 3: debug_show(name, 0.5, 'eroded', mask) mask = cv2.dilate(mask, box(8, 2)) if DEBUG_LEVEL &gt;= 3: debug_show(name, 0.6, 'dilated', mask) return np.minimum(mask, pagemask) 이미지 색상 변환첫번째로 이미지 전처리 과정으로 이미지를 흑백으로 변환합니다. sgray = cv2.cvtColor(small, cv2.COLOR_RGB2GRAY)를 통해 흑백 이미지를 취득합니다. cvtColor(src, code, dst=None, dstCn=None)는 이미지 색상을 변환하기 위한 함수입니다. 여기서는 cv2.COLOR_RGB2GRAY를 통해서 RGB를 GRAY로 변경하였습니다. 이미지 이진화mask = cv2.adaptiveThreshold(sgray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY_INV, ADAPTIVE_WINSZ, 25)을 통해 이진화를 진행합니다. 기본형은 adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C, dst=None)입니다. 적응형 이진화 알고리즘 함수로서 입력 이미지에 따라 임곗값이 스스로 다른값을 할당할 수 있도록 구성된 이미지 알고리즘 이미지에 따라 어떠한 임곗값을 주더라도 이진화 처리가 어려운 이미지가 존재합니다. 예를 들어 조명의 변화나 반사가 심한 경우 이미지내 밝기 분포가 달라 국소적으로 임곗값을 적용해야 원하는 결과를 얻을 수 있습니다. 임곗값(thresh) : 임곗값 보다 낮은 픽셀값은 0(검정), 높은 픽셀값은 최댓값(maxval 여기선 255 흰색)으로 변경(cv2.THRESH_BINARY의 경우) cv2.ADAPTIVE_THRESH_MEAN_C : blockSize 영역의 모든 픽셀에 평균 가중치를 적용 cv2.THRESH_BINARY_INV : 반전 이진화 코드. 임곗값을 초과할 경우 0, 아닐경우 maxval(255)로 변경. ADAPTIVE_WINSZ : block size 여기서는 55 -&gt; 55x55 크기 내의 영역을 분석해 적절한 임곗값을 설정 상수값 25 : 상수값이 크면(양수) 밝아지고 작으면(음수) 어두워짐 이미지 팽창1mask = cv2.dilate(mask, box(9, 1)) cv2.dilate는 이미지를 팽창시키는 함수입니다. 기본형은 dilate(src, kernel, dst=None, anchor=None, iterations=None, borderType=None, borderValue=None)입니다. kernel에 설정된 값에 따라 팽창을 진행합니다. 여기서는 box(9,1)로 설정하였으므로 x축은 9, y축은 1만큼팽창합니다. x축을 팽창시켜서 가로줄을 만드는 것을 목적으로 합니다. 이미지 축소1mask = cv2.erode(mask, box(1, 3)) cv2.erode는 이미지를 침식시키는 함수입니다. 기본형은 rode(src, kernel, dst=None, anchor=None, iterations=None, borderType=None, borderValue=None)입니다. 이미지 팽창과 마찬가지로 kernel에 설정된 값을 통해 침식을 진행합니다. 여기서는 box(1,3)을 설정했기 때문에 y축을 축소시켜 블립을 제거할 목적으로 사용하고 있습니다. 외곽 이미지 제거1return np.minimum(mask, pagemask) np.minimum은 요소별 최소값을 돌려주는 함수입니다. 앞에서 말한것 처럼 pagemask는 마진만큼(x축 50, y축 20) 검정 테두리(0,0,0)이 둘러있다. 안에는 흰색 사각형(255,255,255)가 있다. 기존 그림(mask)와 pagemask의 최소값을 비교해서 돌려준다면 pagemask의 외곽선 검정 부분이 기존 부분에 덧칠해지는 효과를 볼 수 있다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"openCv page Dewarp 분석 -2","slug":"openCV-pageDewarp-02","date":"2020-02-12T02:43:47.000Z","updated":"2022-02-08T02:11:11.812Z","comments":true,"path":"2020/02/12/openCV-pageDewarp-02/","link":"","permalink":"http://jung-max.github.io/2020/02/12/openCV-pageDewarp-02/","excerpt":"","text":"저번 포스트에는 프로젝트 개요 부터 이미지 입력, 이미지 resize까지 살펴 보았습니다. 이번 포스트에선 마스킹 이미지 생성을 알아보겠습니다. 파일 이름 구하기12345678basename = os.path.basename(imgfile)name, _ = os.path.splitext(basename)print (\"loaded\", basename, \"with size\", imgsize(img),)print ('and resized to', imgsize(small))if DEBUG_LEVEL &gt;= 3: debug_show(name, 0.0, 'original', small) os.path.basename : 입력받은 경로의 기본 이름(base name)을 반환합니다. os.path.splitext : 입력 받은 경로를 확장자 부분과 그 외의 부분으로 나눕니다.단순한 문자열 연산이므로 실제 파일의 존재 여부는 확인하지 않습니다. debug_show를 통해서 DEBUG_LEVEL을 설정했으면 중간 결과물을 file 또는 screen으로 보여줍니다. 여기서는 resize된 결과물을 보여줍니다. 123456789101112131415161718192021222324def debug_show(name, step, text, display): if DEBUG_OUTPUT != 'screen': filetext = text.replace(' ', '_') outfile = name + '_debug_' + str(step) + '_' + filetext + '.png' cv2.imwrite(outfile, display) if DEBUG_OUTPUT != 'file': image = display.copy() height = image.shape[0] cv2.putText(image, text, (16, height-16), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (0, 0, 0), 3, cv2.LINE_AA) cv2.putText(image, text, (16, height-16), cv2.FONT_HERSHEY_SIMPLEX, 1.0, (255, 255, 255), 1, cv2.LINE_AA) cv2.imshow(WINDOW_NAME, image) while cv2.waitKey(5) &lt; 0: pass DEBUG_OUTPUT이 file로 설정되어 있다면 중간 결과물을 file로 저장합니다. cv2.imwrite는 이미지를 파일로 저장하기 위한 함수입니다. 기본형은 imwrite(filename, img, params=None)입니다. DEBUG_OUTPUT이 screen으로 설정되어 있다면 중간 결과물을 윈도우창으로 보여줍니다. cv2.putText은 이미지에 TEXT를 넣습니다. 기본형은 putText(img, text, org, fontFace, fontScale, color, thickness=None, lineType=None, bottomLeftOrigin=None)입니다. img : 문자열을 그릴 이미지 text : 문자열 org : 출력 문자 시작 위치 좌표(좌측 하단) fontFace : 폰트 타입 cv2.FONT_HERSHEY_SIMPLEX : normal size sans-serif font cv2.FONT_HERSHEY_PLAIN : small size sans-serif font cv2.FONT_HERSHEY_DUPLEX : normal size sans-serif font (more complex than FONT_HERSHEY_SIMPLEX) cv2.FONT_HERSHEY_COMPLEX : normal size serif font cv2.FONT_HERSHEY_TRIPLEX : normal size serif font (more complex than FONT_HERSHEY_COMPLEX) cv2.FONT_HERSHEY_COMPLEX_SMALL : smaller version of FONT_HERSHEY_COMPLEX cv2.FONT_HERSHEY_SCRIPT_SIMPLEX : hand-writing style font cv2.FONT_HERSHEY_SCRIPT_COMPLEX : more complex variant of FONT_HERSHEY_SCRIPT_SIMPLEX cv2.FONT_ITALIC : flag for italic font fontScale : 폰트 기본 크기에 곱해질 폰트 스케일 팩터(Font scale factor) color : 글자 색 thickness : 폰트 두께. 디폴트값 1 lineType : 선 종류. 디폴트값 cv2.LINE_8(=8-connected line) bottomLeftOrigin : org 사용 옵션. Ture : 좌측하단, False : 좌측 상단. 디폴트값 false cv2.imshow(WINDOW_NAME, image)으로 이미지를 screen에 보여줍니다. 기본형은 imshow(winname, mat)입니다. winname : 윈도우 창의 이름을 설정합니다. mat : 보여줄 이미지 masking을 위한 준비1pagemask, page_outline = get_page_extents(small) get_page_extents() 함수를 통해서 making을 위한 그림을 그립니다. 12345678910111213141516171819202122def get_page_extents(small): height, width = small.shape[:2] xmin = PAGE_MARGIN_X #50 ymin = PAGE_MARGIN_Y #20 xmax = width-PAGE_MARGIN_X ymax = height-PAGE_MARGIN_Y page = np.zeros((height, width), dtype=np.uint8) cv2.rectangle(page, (xmin, ymin), (xmax, ymax), (255, 255, 255), -1) print(\"page show\") cv2.imshow(\"page\", page) outline = np.array([ [xmin, ymin], [xmin, ymax], [xmax, ymax], [xmax, ymin]]) return page, outline height, width = small.shape[:2]를 통해 이미지의 높이와 폭을 구한다. Numpy array에서 shape는 몇행 몇열로 이루어져있는지 차원을 알 수 있습니다. 여기서는 페이지의 마진을 폭에는 50, 높이에는 20을 고정값으로 주고 있습니다. page = np.zeros((height, width), dtype=np.uint8)를 통해 0으로 채워진 배열을 생성한다. RGB에서 0은 검정을 의미합니다. cv2.rectangle(page, (xmin, ymin), (xmax, ymax), (255, 255, 255), -1)를 통해 사각형을 그립니다. cv2.rectangle는 이미지에 사각형을 그리는 함수입니다. 기본형은 rectangle(img, pt1, pt2, color, thickness=None, lineType=None, shift=None)입니다. img – 그림을 그릴 이미지 start – 시작 좌표(ex; (0,0)) 좌측 상단 기준. end – 종료 좌표(ex; (500. 500)) 우측 하단 기준. color – BGR형태의 Color(ex; (255, 0, 0) -&gt; Blue) thickness (int) – 선의 두께. pixel. 음수일 경우 안의 내용을 가득 채웁니다. 여기서는 사각형은 높이 20, 폭 50의 마진을 가진 흰색 사각형이 만들어 집니다. 그후 사각형 이미지와 사각형의 4 꼭지점을 저장한 배열을 리턴합니다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"openCv page Dewarp 분석 -1","slug":"openCV-pageDewarp-01","date":"2020-02-12T01:55:21.000Z","updated":"2022-02-08T02:11:11.811Z","comments":true,"path":"2020/02/12/openCV-pageDewarp-01/","link":"","permalink":"http://jung-max.github.io/2020/02/12/openCV-pageDewarp-01/","excerpt":"","text":"개요 이번에는 openCV를 이용해서 북스캔을 구현하는 오픈소스를 분석해 보겠습니다. 해당 프로젝트의 기능은 기존에 구부려져 있는 책의 이미지를 피는 북스캔을 목적으로 하고 있습니다. 해당 정보는 아래를 참고 부탁드립니다. Page dewarping blog Page dewarping gitHub 이미지 파일 로딩이 프로젝트는 page_dewarp.py 파일 하나로 이루어져 있습니다.이 프로젝트를 구동하기 위해서는 아래와 같은 커맨드를 입력합니다. python page_dewarp.py IMAGE1 [IMAGE2 ...] 기본적으로 python과 openCV 모듈이 PC에 탑재되어야 합니다. IMAGE1 IMAGE2는 파일 이름입니다. 여러개의 파일을 한꺼번에 처리할 수 있습니다. 프로젝트의 시작은 main()에서 시작합니다. 1234567891011121314151617def main(): # ① 파라미터 값은 이미지 파일 하나 이상이 들어와야 함 if len(sys.argv) &lt; 2: print 'usage:', sys.argv[0], 'IMAGE1 [IMAGE2 ...]' sys.exit(0) # ② 결과를 파일이 아닌 스크린으로 보여줄때 윈도우 창 이름 설정 if DEBUG_LEVEL &gt; 0 and DEBUG_OUTPUT != 'file': cv2.namedWindow(WINDOW_NAME) outfiles = [] # 아웃풋 파일을 List로 설정 # ③ input 파일 개수만큼 for문을 돌림 (한개일땐 한번만...) for imgfile in sys.argv[1:]: # ④ 파일 이름으로 openCV에서 파일을 읽음 img = cv2.imread(imgfile) ... ①은 파라미터의 길이로 이미지 파일 이름이 설정되어 있지 않으면 안내 문구를 돌려줍니다. ② 는프로젝트에는 DEBUG_LEVEL이 있어 설정에 따라 중간 결과물들을 볼 수 있습니다. 중간 결과물을 file이 아닌 screen으로 보고 싶으면 openCV에서 생성할 window 창의 이름을 설정해 줍니다. ③은 이미지 파일이 여러개가 로드되었을때 for문을 통해 모듈을 반복해서 돌립니다. 이미지가 하나라면 한번만 실행됩니다. ④는 cv.imread()를 통해서 입력된 이미지 파일을 openCV에서 처리할 numpy배열(img)로 변환합니다. 이미지 resize1small = resize_to_screen(img) resize_to_screen() 함수를 통해서 이미지 resize를 실행합니다. 123456789101112131415161718def resize_to_screen(src, maxw=1280, maxh=700, copy=False): height, width = src.shape[:2] scl_x = float(width)/maxw scl_y = float(height)/maxh scl = int(np.ceil(max(scl_x, scl_y))) if scl &gt; 1.0: inv_scl = 1.0/scl img = cv2.resize(src, (0, 0), None, inv_scl, inv_scl, cv2.INTER_AREA) elif copy: img = src.copy() else: img = src return img 해당 함수의 기능은 입력 받은 이미지의 높이와 폭을 원본 비율을 유지시키는 선에서 기준크기1280x700과 비교해서 더 작게 resize하는 것입니다. 기본적으로 함수를 사용할 때 파라미터로 src만 입력했기 때문에 maxw=1280, maxh=700, copy=False값은 유지됩니다. 처음으로 scl_x = float(width)/maxw, scl_y = float(height)/maxh 을 통해서 폭과 높이에 대해서 기준 크기와의 차이를 비교합니다. scl = int(np.ceil(max(scl_x, scl_y))) 에서는 비교된 스케일 중 큰 값을 기준으로 올림 처리를 해서 최종 스케일을 취득합니다. if scl &gt; 1.0: 만약 스케일이 기준크기보다 크다면 resize를 통해 원본 이미지를 줄여줍니다. 기준크기 이하로 만들기 위한 스케일 비율을 구하기 위해 inv_scl = 1.0/scl을 실행합니다. img = cv2.resize(src, (0, 0), None, inv_scl, inv_scl, cv2.INTER_AREA)를 통해서 이미지 resize를 실행합니다. cv2.resize의 기본형은 resize(src, dsize, dst=None, fx=None, fy=None, interpolation=None)입니다. src : input 이미지 입니다. dsize : resize를 위한 절대 크기가 입력됩니다. 여기서는 절대가 아닌 상대 크기로 변환하기 때문에 (0,0)을 입력하였습니다. dst : 리턴으로 img를 받기때문에 dst값을 따로 입력하지 않습니다. fx, fy : 폭과 높이를 resize 하기 위한 상대 비율을 입력합니다. interpolation : 이미지 크기를 조절할때 사용할 보간법을 지정합니다. cv2.INTER_NEAREST : 이웃 보간법 cv2.INTER_LINEAR : 쌍 선형 보간법 cv2.INTER_LINEAR_EXACT : 비트 쌍 선형 보간법 cv2.INTER_CUBIC : 바이큐빅 보간법 cv2.INTER_AREA : 영역 보간법 cv2.INTER_LANCZOS4 : Lanczos 보간법 여기서는 cv2.INTER_AREA를 사용해 영역 보간법을 사용하습니다. 기본적으로 쌍 선형 보간법이 가장 많이 사용됩니다. 이미지를 확대하는 경우, 바이큐빅 보간법이나 쌍 선형 보간법을 가장 많이 사용합니다. 이미지를 축소하는 경우, 영역 보간법을 가장 많이 사용합니다. 영역 보간법에서 이미지를 확대하는 경우, 이웃 보간법과 비슷한 결과를 반환합니다.","categories":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"}],"tags":[{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"}]},{"title":"Android SurfaceFlinger 분석","slug":"Android-Surfaceflinger","date":"2020-01-16T05:29:19.000Z","updated":"2022-02-08T02:11:11.778Z","comments":true,"path":"2020/01/16/Android-Surfaceflinger/","link":"","permalink":"http://jung-max.github.io/2020/01/16/Android-Surfaceflinger/","excerpt":"","text":"개요안드로이드는 응용 프로그램에서 만든 메뉴나 다이얼로그 박스, 사용자 인터페이스 구성 요소들을 SurfaceFlinger를 통하여 리눅스 커널에 위치한 LCD 디스플레이 드라이버인 프레임 버퍼 드라이버를 통해 그림을 그리게 됩니다. 안드로이드 GDI의 구조를 이해하기 위해서 하위레벨에서 상위레벨로 접근하여 살펴보도록 하겠습니다. FrameBuffer커널 영역에 위치한 프레임 버퍼는 LCD 등의 출력 장치를 위한 디스플레이 하드웨어를 제어하기 위한 디바이스 드라이버입니다. 사용자 영역에서 프레임 버퍼로 그래픽 데이터를 출력 장치에 표시합니다. 프레임 버퍼는 출력장치에 표시될 그래픽 데이터가 가장 마지막으로 보관되며 출력 장치에 같은 해상도의 크기와 픽셀 포멧으로 설정됩니다. 프레임 버퍼의 데이터는 출력장치에서 요구하는 기준에 맞춰 주기적으로 출력 장치에 출력됩니다. 안드로이드에서 /dev/graphics/fb0 형태로 프레임 버퍼 드라이버를 오픈 하여 mmap() 함수를 사용하여 프레임 버퍼에 대한 직접적인 제어를 통해 LCD를 제어할 수 있도록 하고 있습니다.프레임 버퍼 드라이버는 리눅스 시스템에서 사용자 레벨의 응용 프로그램에서 제어할 수 있도록 만들어진 디바이스 드라이버입니다. 또한 open, mmap과 같은 표준 인터페이스 함수를 통해 이용할 수 있는 구조로 구성되어 있습니다. 위 그림에서는 프레임 버퍼 드라이버의 동작 모습을 사용자의 응용 프로그램 관점에서 보여줍니다. 사용자의 응용 프로그램에서 작성한 화면은 프레임 버퍼 드라이버를 거쳐, 프로세서 내부에 있는 LCD 컨트롤러를 통해 LCD에 표시되게 됩니다. 물론 안드로이드 시스템에서는 프로그램을 작성하여 운영할 수 있지만, 앱이나 사용자의 프로세스에서 만들어진 모든 동작들은 SurfaceFlinger를 통해 운영이 됩니다. 즉, 사용자의 응용 프로그램과 프레임 버퍼 드라이버상에 위치하여 관리하게 됩니다. 따라서 프레임 버퍼에 대한 윈리의 이해, SurfaceFlinger에 대한 정확한 동작의 이해가 필요합니다. 프레임 버퍼 드라이버의 일반적인 사항 디바이스 드라이버로써 이식성을 높이기 위해 사용됨 표시장치의 종류가 많고, 이러한 여러 하드웨어를 고려하지 않고 표준화된 인터페이스를 제공하기 위함 통상 /dev/fb0, dev/graphics/fb0 형태로 장치 드라이버가 구성되어 있고 드라이버가 할당한 메모리를 사용자 응용 프로그램에서 사용할 수 있도록 메모리 매핑하여 사용함 사용자 응용 프로그램에서 전송한 프레임 버퍼 데이터를 LCD 드라이버가 수신하여 LCD 컨트롤러를 통해 TFT LCD나 다른 표시 장치에 출력하는 역할을 함 안드로이드 시스템에서 프레임 버퍼 드라이버의 특이사항 기존 리눅스 프레임 버퍼 드라이버에 struct fp_ops와 fb_ pan_display 함수가 추가로 구현되어야 함 실제 프레임 버퍼 크기보다 두 배의 메모리 할당 필요 해당 함수는 프레임 버퍼의 디스플레이 포인터를 옮기는 기능을 제공한다. 즉, 실제 화면보다 넓은 가상 디스플레이를 구현 가능하도록 함 안드로이드 시스템의 프레임 버퍼 드라이버는 고속 처리를 위해 반드시 더블 버퍼링(Double Buffering)을 사용하도록 구성됨 Android 7.0 기준 프레임버퍼(fb)제어Android 7.0 기준 프레임버퍼(fb)제어는 아래 폴더를 통해 제어 가능합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445rk3328_box:/sys/devices/fb.17/graphics/fb0 # ls -altotal 0drwxr-xr-x 3 root root 0 1970-01-01 00:00 .drwxr-xr-x 7 root root 0 1970-01-01 00:00 ..-rw-rw-r-- 1 root system 4096 1970-01-01 00:00 bcsh-rw-r--r-- 1 root root 4096 1970-01-01 00:33 bits_per_pixel-rw-r--r-- 1 root root 4096 1970-01-01 00:33 blank-rw-r--r-- 1 root root 4096 1970-01-01 00:33 cabc-rw-r--r-- 1 root root 4096 1970-01-01 00:33 cabc_lut--w------- 1 root root 4096 1970-01-01 00:33 car_reverse-rw-r--r-- 1 root root 4096 1970-01-01 00:33 console-rw-r--r-- 1 root root 4096 1970-01-01 00:33 cursor-r--r--r-- 1 root root 4096 1970-01-01 00:33 devlrwxrwxrwx 1 root root 0 1970-01-01 00:33 device -&gt; ../../../fb.17-r--r--r-- 1 root root 4096 1970-01-01 00:33 disp_info-rw-r--r-- 1 root root 4096 1970-01-01 00:33 dsp_buf-rw-rw-r-- 1 root system 4096 1970-01-01 00:00 dsp_lut-r--r--r-- 1 root root 4096 1970-01-01 00:33 dsp_mode-r--r--r-- 1 root root 4096 1970-01-01 00:33 dual_mode-rw-r--r-- 1 root root 4096 1970-01-01 00:33 dump_buf-rw-r--r-- 1 root root 4096 1970-01-01 00:33 enable-rw-r--r-- 1 root root 4096 1970-01-01 00:00 fps-rw-rw-r-- 1 root system 4096 1970-01-01 00:00 hdr_bt1886eotf-rw-rw-r-- 1 root system 4096 1970-01-01 00:00 hdr_st2084oetf-rw-r--r-- 1 root root 4096 1970-01-01 00:33 hwc_lut-r--r--r-- 1 root root 4096 1970-01-01 00:00 lcdcid-rw-rw-r-- 1 root system 4096 1970-01-01 00:00 map-rw-r--r-- 1 root root 4096 1970-01-01 00:33 mode-rw-r--r-- 1 root root 4096 1970-01-01 00:33 modes-r--r--r-- 1 root root 4096 1970-01-01 00:33 name-rw-r--r-- 1 root root 4096 1970-01-01 00:33 overlay-rw-r--r-- 1 root root 4096 1970-01-01 00:33 pan-r--r--r-- 1 root root 4096 1970-01-01 00:33 phys_addrdrwxr-xr-x 2 root root 0 1970-01-01 00:00 power-rw-r--r-- 1 root root 4096 1970-01-01 00:33 rotate-rw-rw-r-- 1 system graphics 4096 1970-01-01 00:00 scale-rw-r--r-- 1 root root 4096 1970-01-01 00:00 screen_info-rw-r--r-- 1 root root 4096 1970-01-01 00:33 state-r--r--r-- 1 root root 4096 1970-01-01 00:33 stridelrwxrwxrwx 1 root root 0 1970-01-01 00:33 subsystem -&gt; ../../../../class/graphics-rw-r--r-- 1 root root 4096 1970-01-01 00:00 uevent-r--r--r-- 1 root root 4096 1970-01-01 00:33 virt_addr-rw-r--r-- 1 root root 4096 1970-01-01 00:33 virtual_size-r--r--r-- 1 root root 4096 1970-01-01 00:00 vsync-r--r--r-- 1 root root 4096 1970-01-01 00:33 win_property 상기 폴더의 파일을 read 함으로서 fb의 정보를 얻을 수 있습니다.아래는 screen_info를 read한 것입니다. 123456rk3328_box:/sys/devices/fb.17/graphics/fb0 # cat screen_infoxres:1920yres:1080fps:60type:6interlace:0 몇몇 파일은 write 함으로서 fb를 제어할 수 있습니다. 1234567rk3328_box:/sys/devices/fb.17/graphics/fb0 # cat scalexscale=100 yscale=100left=100 top=100 right=100 bottom=100rk3328_box:/sys/devices/fb.17/graphics/fb0 # echo xscale=70 &gt; scalerk3328_box:/sys/devices/fb.17/graphics/fb0 # cat scalexscale=70 yscale=100left=70 top=100 right=70 bottom=100 위 명령은 화면의 x축 크기를 70%로 줄인 것입니다.위 명령을 통해서 화면의 크기가 축소된 것을 확인할 수 있습니다. SurfaceFlingerSurfaceFlinger의 역할은 앞에서 앱이나 사용자의 응용 프로그램에서 생성한 화면(여기에서는 Surface라는 용어를 사용함) 합성 관리하는 역할입니다. “Surface+Flinger”의 합성입니다. Surface의 “표면”이라는 의미와 Flinger의 “던지는 사람”이라는 조합으로 SurfaceFlinger 기능을 이 두 단어가 모두 함축하고 있습니다. 즉, 생성된 여러 개의 Surface를 하나의 Surface로 만들고 이 만든 화면을 프레임 버퍼 드라이버와 연계하여 프레임 버퍼로 만들고, LCD 화면에 표시하는 역할을 하는 것입니다. Surface는 2D나 3D일 ㅅ 있고, RGB888 또는 RGB565등 다양한 형태의 포멧일 수 있습니다. SurfaceFlinger는 이러한 Surface를 지원하며, Framebuffer에서 원하는 형태의 포멧으로 합성하여 FrameBuffer에 던져줍니다. SurfaceFlinger 관련 용어Surface하나의 화면을 이야기합니다. 일반적인 윈도우 개념으로 생각하면 됩니다. 실제로는 소프트웨어적인 Overlay를 이야기합니다. Surface는 클라이언트쪽(어플리케이션) 입장에서만 사용하는 용어입니다. 서버쪽에서는 실제로 옵션에 따라 적절한 Layer를 생성합니다. SurfaceComposerSurface와 SurfaceFlinger와의 연결을 처리하고, 여러가지 Surface로부터 SurfaceFlinger로 전달되는 제어 오퍼레이션을 담당합니다.(연결, 클라이언트로부터 트랜잭션등 처리.) Surface를 생성할 때는 반드시 SurfaceComposer에 대한 접속 포인트인 SurfaceComposerClient 클래스를 생성한 후에 Surface를 생성합니다. SurfaceFlinger클라이언트인 Surface로부터 전달된 데이터를 합성 후 HAL로 전달하는 역할을 하는 안드로이드의 디스플레이 서버입니다. 이 서버는 시작된 후에는 스레드 루프를 돌면서 Surface로부터 데이터가 입력되거나, 화면이 업데이트되어야 하는 경우에 입력된 데이터의 좌표(X,Y,Z축)에 따라 Surface를 합성하고 이를 HAL로 전달해서 LCD 화면에 디스플레이할 수 있도록 제어합니다. LayerSurface를 구성하는 클래스로 Surface의 용도의 특성을 결정짓습니다. SurfaceFlinger쪽에서 사용되고 생성되는 클래스틑 LayerBase클래스에서 상속된 Layer, LayerBuffer, LayerDim, LayerBlur의 네종류의 클래스가 생성됩니다. grallocSurfaceFlinger를 구성하는 HAL의 하나로, 그래픽 버퍼용 메모리를 매핑하고 디스플레이 device driver를 제어합니다. 대부분의 칩 벤더에서는 이 부분을 바이너리 형태로 제공해 디버깅하는데 제약사항이 생기는 경우가 많습니다. OverlaySurfaceFlinger를 구성하는 HAL의 하나로, LayerBuffer의 하부 구조 중 일부를 담당합니다. 실제로는 일반적으로 표현되는 하드웨어 Overlay를 이야기하며, 주로 멀티미디어 관련 연산에 사용되는 경우가 많습니다. SurfaceFlinger 관련 소스 리스트클라이언트 frameworks/base/services/core/java/com/android/server/wm/WindowManagerService.java frameworks/base/core/java/android/view/* 라이브러리 frameworks/base/core/jni/android_view_Surface.cpp frameworks/native/libs/gui/Surface.cpp Surface* / ISurface*들 frameworks/native/services/surfaceflinger/*","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform SurfaceFlinger","slug":"Android/Platform-SurfaceFlinger","permalink":"http://jung-max.github.io/categories/Android/Platform-SurfaceFlinger/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"SurfaceFlinger","slug":"SurfaceFlinger","permalink":"http://jung-max.github.io/tags/SurfaceFlinger/"}]},{"title":"Android TabLayout backgroud color 설정하기","slug":"Android-Tablayout-background-color","date":"2020-01-03T07:29:20.000Z","updated":"2022-02-08T02:11:11.780Z","comments":true,"path":"2020/01/03/Android-Tablayout-background-color/","link":"","permalink":"http://jung-max.github.io/2020/01/03/Android-Tablayout-background-color/","excerpt":"","text":"TabLayout을 보면 Tab이 선택될때 배경을 바꿀 수 있는 함수등이 없다. 아래 방법을 사용하면 탭의 선택 유무에 따라 배경을 바꿀 수 있다. drawable 폴더에 tab_background.xml selector 생성 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:drawable=\"@drawable/tab_background_selected\" android:state_selected=\"true\" /&gt; &lt;item android:drawable=\"@drawable/tab_background_unselected\" android:state_selected=\"false\" android:state_focused=\"false\" android:state_pressed=\"false\" /&gt;&lt;/selector&gt; drawable 폴더에 tab_background_selected.xml 생성 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;solid android:color=\"#d13fdd1a\" /&gt;&lt;/shape&gt; drawable 폴더에 tab_background_unselected.xml 생성 1234&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;solid android:color=\"#3F51B5\" /&gt;&lt;/shape&gt; styles.xml에 다음을 추가. 12345&lt;style name=\"Base.Widget.Design.TabLayout\" parent=\"android:Widget\"&gt; &lt;item name=\"tabBackground\"&gt;@drawable/tab_background&lt;/item&gt; &lt;item name=\"tabIndicatorColor\"&gt;#ff00ff&lt;/item&gt; &lt;item name=\"tabIndicatorHeight\"&gt;2dp&lt;/item&gt;&lt;/style&gt; xml의 칼라 값을 변경함으로서 백그라운드 칼라를 설정할 수 있다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"TabLayout","slug":"TabLayout","permalink":"http://jung-max.github.io/tags/TabLayout/"}]},{"title":"Android thread에서 Toast 호출하기","slug":"Android-Thread안에서_Toast사용","date":"2020-01-03T07:11:31.000Z","updated":"2022-02-08T02:11:11.779Z","comments":true,"path":"2020/01/03/Android-Thread안에서_Toast사용/","link":"","permalink":"http://jung-max.github.io/2020/01/03/Android-Thread안에서_Toast사용/","excerpt":"","text":"쓰레드에서 Toast 호출이 필요할때가 있습니다. 하지만 그냥 Toast 메세지 호출시 제대로 실행이 되지 않습니다. 그럴때 아래와 같이 해당 스레드 내에서 Activity의 runOnUiThread 메소드를 호출하면 됩니다. 12345MainActivity.this.runOnUiThread(new Runnable() &#123; public void run() &#123; Toast.makeText(MainActivity.this, \"Hello\", Toast.LENGTH_SHORT).show(); &#125;&#125;);","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"Thread","slug":"Thread","permalink":"http://jung-max.github.io/tags/Thread/"},{"name":"Toast","slug":"Toast","permalink":"http://jung-max.github.io/tags/Toast/"}]},{"title":"Linux kernel ADC Battery","slug":"Linux-ADC-Battery","date":"2019-12-13T06:23:48.000Z","updated":"2022-02-08T02:11:11.811Z","comments":true,"path":"2019/12/13/Linux-ADC-Battery/","link":"","permalink":"http://jung-max.github.io/2019/12/13/Linux-ADC-Battery/","excerpt":"","text":"ADC란?ADC란 Analog to Digital Converter의 약자로서 실생활에서 연속적으로 측정되는 신호를 프로세서가 그 값을 읽을 수 있도록 디지털 신호로 변환해주는 장치입니다. ADC 관련 용어 Sampling(표본화)아날로그 신호를 일정 주기로 추출하는 과정연속시간 → 이산시간 Quantizing[양자화, 분해능]표본화된 각각의 신호의 대표값을 변환하는 과정연속적인 신호의 크기 -&gt; 이산적인 신호의 크기10bit,8bit의 고정된 분해능이 있다. Sampling(표본화) Quantizing [양자화] 분해능 8bit 10bit 표현개수 256개 (0~255) 1024개 (0~1023) 예 : ADC의 기준 전압이 5V일때 bit당 전압은? 8bit : 5V/256 = 0.01953125 V/bit 10bit : 5V/1024 = 0.0048828125 V/bit 전압 분배예제에 쓰인 배터리의 전압은 7.4V입니다. 보통 최대 전압이 이와 같이 높지 않기 때문에 전압 분배기를 만들어 해결하는 것이 보통입니다.저항이 만나는 접점은 두 전압을 합친 전압의 절반을 같습니다. 총 전압이 V인 두개의 저항(R1 및 R2)이 직렬로 연결된 경우 R1의 전압은 다음과 같습니다. V1 = (V*R1)/(R1 + R1) 이 접근법의 단점은 배터리가 전압 분배기를 통해 지속적으로 방전된다는 것입니다. 그러나 큰 저항 값을 사용하면 전류를 낮게 유지할 수 있습니다. rk3328 ADC 스팩 6-channel signal-ended 10bit 50KS/s sampling rk30_factory_adc_battert 드라이버 분석DTS 분석1234567891011121314151617181920&amp;adc &#123; status = \"okay\"; adc-battery &#123; status = \"okay\"; compatible = \"rk30-adc-battery\"; io-channels = &lt;&amp;adc 1&gt;, &lt;&amp;adc 3&gt;; dc_det_gpio = &lt;&amp;gpio2 GPIO_C3 GPIO_ACTIVE_LOW&gt;; auto_calibration = &lt;0&gt;; ref_voltage = &lt;3300&gt;; led-gpio = &lt;&amp;gpio3 GPIO_A2 GPIO_ACTIVE_LOW&gt;; //bat_low_gpio = &lt;&amp;gpio0 GPIO_A7 GPIO_ACTIVE_LOW&gt;; chg_ok_gpio = &lt;&amp;gpio2 GPIO_C0 GPIO_ACTIVE_HIGH&gt;; bat_table = &lt;0x0000 0x0000 0x0000 0x0000 0x01d6 0x005d 0x283c 0x29cc 0x2a80 0x2b3e 0x2bc0 0x2c2e 0x2cc4 0x2da0 0x2e7c 0x2f50 0x3048 0x2ac6 0x2bca 0x2c60 0x2cec 0x2d82 0x2e0e 0x2e72 0x2f26 0x2fda 0x30c0 0x3138&gt;; is_dc_charge = &lt;1&gt;; is_usb_charge = &lt;0&gt;; &#125;;&#125;; status : 해당 부분의 사용 여부 compatible : 해당 값과 일치하는 compatible가진 드라이버를 사용. 여기서는 rk30_factory_adc_battert드라이버 io-channels : adc channels dc_det_gpio : soc와 연결된 dc_det gpio port. DC irq 관련 auto_calibration : voltage 계산시 DTS에 지정된 ref_voltage의 값을 쓸지 여부 판별 ref_voltage : voltage과 관계된 기준 전압값. 입력전압과 기준전압을 비교하여 디지털로 변환한다. 0 ~ Vref 측정 가능. Vref = 0xffffffffff(10bit일때) led-gpio : ?? chg_ok_gpio : 충전중의 여부를 판별 bat_table : 충전량을 판별하기 위한 table.0-3은 쓰이지 않음.4-5는 ADC 샘플링 전압 분배기 저항(4는 pull_up, 5는 pull_down).6-16은 충전중이 아닐때 최소-최대 전압값17-27은 충전중일때 최소-최대 전압값 is_dc_charge : dc 충전을 사용하는지 여부 is_usb_charge : usb 충전을 사용하는지 여부 voltage값 구하는 부분1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static void rk30_adc_battery_voltage_samples(struct rk30_adc_battery_data *bat)&#123; int value; int i,*pStart = bat-&gt;adc_samples, num = 0; int level = bat-&gt;charge_level; value = bat-&gt;adc_val; //adc 측정값 bat-&gt;adc_val = rk_adc_battery_iio_read(bat-&gt;pdata); *(bat-&gt;pSamples++) = rk_adc_voltage(bat,value); //adc 측정값을 저장(samplig 때문) bat-&gt;bat_status_cnt++; if (bat-&gt;bat_status_cnt &gt; NUM_VOLTAGE_SAMPLE) bat-&gt;bat_status_cnt = NUM_VOLTAGE_SAMPLE + 1; num = bat-&gt;pSamples - pStart; if (num &gt;= NUM_VOLTAGE_SAMPLE)&#123; bat -&gt;pSamples = pStart; num = NUM_VOLTAGE_SAMPLE; &#125; value = 0; for (i = 0; i &lt; num; i++)&#123; value += bat-&gt;adc_samples[i]; &#125; bat-&gt;bat_voltage = value / num; //sampling값에 따른 기준값의 평균값을 구함 /*handle ripple */ if(0 == bat-&gt;pdata-&gt;use_board_table)&#123; if(1 == level)&#123; //충전중 if(bat-&gt;bat_voltage &gt;= batt_table[2*BATT_NUM +5])&#123; //측정 값이 테이블의 최대값 이상시 테이블 최대값으로 조정 bat-&gt;bat_voltage = batt_table[2*BATT_NUM +5]; &#125; else if(bat-&gt;bat_voltage &lt;= batt_table[BATT_NUM +6])&#123; //측정 값이 테이블의 최소값 이하시 테이블 최소값으로 조정 bat-&gt;bat_voltage = batt_table[BATT_NUM +6]; &#125; &#125; else&#123; //충전X if(bat-&gt;bat_voltage &gt;= batt_table[BATT_NUM +5])&#123; //측정 값이 테이블의 최대값 이상시 테이블 최대값으로 조정 bat-&gt;bat_voltage = batt_table[BATT_NUM +5]; &#125; else if(bat-&gt;bat_voltage &lt;= batt_table[6])&#123; //측정 값이 테이블의 최소값 이하시 테이블 최소값으로 조정 bat-&gt;bat_voltage = batt_table[6]; &#125; &#125; &#125;else&#123; rk_handle_ripple(bat, level); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Kernel","slug":"Android/Platform-Kernel","permalink":"http://jung-max.github.io/categories/Android/Platform-Kernel/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"}]},{"title":"Android Kernel powerkey 인터럽트 설정","slug":"Android-kernel-powerKey-인터럽트","date":"2019-11-20T07:18:23.000Z","updated":"2022-02-08T02:11:11.750Z","comments":true,"path":"2019/11/20/Android-kernel-powerKey-인터럽트/","link":"","permalink":"http://jung-max.github.io/2019/11/20/Android-kernel-powerKey-인터럽트/","excerpt":"","text":"안드로이드를 포팅하다 잘되던 power key가 어느 순간 작동하지 않았다. 원인은 g-sensor를 인터럽트로 신호를 받았더니 power key가 동작을 하지 않는 것이다. g-sensor에 인터럽트가 필요했기 때문에 power key또한 인터럽트가 작동하도록 만드는 것이 필요했다. 일단 dts의 power-key 부분을 보면 12345678910111213141516171819202122&amp;adc &#123; status = \"okay\"; rk_key: rockchip-key &#123; compatible = \"rockchip,key\"; io-channels = &lt;&amp;adc 0&gt;; status = \"okay\"; vol-up-key &#123; linux,code = &lt;113&gt;; label = \"F12\"; rockchip,adc_value = &lt;4&gt;; &#125;; power-key &#123; gpios = &lt;&amp;gpio0 GPIO_A2 GPIO_ACTIVE_LOW&gt;; linux,code = &lt;116&gt;; label = \"POWER\"; gpio-key,wakeup; // rockchip,adc_value = &lt;4&gt;; &#125;; &#125;;&#125;; 이렇게 되어있다. 기존 sdk의 dts는 power-key를 adc로 받았던 것 같은데 우리의 디바이스는 gpio0_a2와 key가 연결되어 있기 때문에 수정을 하였다. 여기서 잠깐 설명을 하면 linux,code = &lt;116&gt;은 KEY_POWER를 의미한다. 이는 linux/input.h에 정의되어 있다. 다시 돌아와서 여기서 dts를 잘 살펴보면 compatible = &quot;rockchip,key&quot;;이 보인다. rockchip,key라는 compatible이 설정되어 있는 driver와 연결되어 있다는 의미이다. kernel/drivers를 열심히 검색했더니 rk_keys.c라는 파일에 compatible = &quot;rockchip,key&quot;;이 설정되어 있는 것을 확인했다. 1234567891011121314151617static const struct of_device_id rk_key_match[] = &#123; &#123; .compatible = \"rockchip,key\", .data = NULL&#125;, &#123;&#125;,&#125;;static struct platform_driver keys_device_driver = &#123; .probe = keys_probe, .remove = keys_remove, .driver = &#123; .name = \"rk-keypad\", .owner = THIS_MODULE, .of_match_table = rk_key_match,#ifdef CONFIG_PM .pm = &amp;keys_pm_ops,#endif &#125;&#125;; 이제 해당 소스에서 key의 interrupt 관련된 부분을 찾아 봤다. 이에 앞서 먼저 g-sensor의 interrupt부분은 다음과 같이 이루어져 있었다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869static void sensor_delaywork_func(struct work_struct *work)&#123; struct delayed_work *delaywork = container_of(work, struct delayed_work, work); struct sensor_private_data *sensor = container_of(delaywork, struct sensor_private_data, delaywork); struct i2c_client *client = sensor-&gt;client; mutex_lock(&amp;sensor-&gt;sensor_mutex); if (sensor_get_data(client) &lt; 0) DBG(KERN_ERR \"%s: Get data failed\\n\",__func__); if(!sensor-&gt;pdata-&gt;irq_enable)//restart work while polling schedule_delayed_work(&amp;sensor-&gt;delaywork, msecs_to_jiffies(sensor-&gt;pdata-&gt;poll_delay_ms)); //else //&#123; //if((sensor-&gt;ops-&gt;trig == IRQF_TRIGGER_LOW) || (sensor-&gt;ops-&gt;trig == IRQF_TRIGGER_HIGH)) //enable_irq(sensor-&gt;client-&gt;irq); //&#125; mutex_unlock(&amp;sensor-&gt;sensor_mutex); DBG(\"%s:%s\\n\",__func__,sensor-&gt;i2c_id-&gt;name);&#125;static int sensor_irq_init(struct i2c_client *client)&#123; struct sensor_private_data *sensor = (struct sensor_private_data *) i2c_get_clientdata(client); int result = 0; int irq; if((sensor-&gt;pdata-&gt;irq_enable)&amp;&amp;(sensor-&gt;pdata-&gt;irq_flags!= SENSOR_UNKNOW_DATA)) &#123; INIT_DELAYED_WORK(&amp;sensor-&gt;delaywork, sensor_delaywork_func); if(sensor-&gt;pdata-&gt;poll_delay_ms &lt; 0) sensor-&gt;pdata-&gt;poll_delay_ms = 30; result = gpio_request(client-&gt;irq, sensor-&gt;i2c_id-&gt;name); if (result) &#123; printk(\"%s:fail to request gpio :%d\\n\",__func__,client-&gt;irq); &#125; //gpio_pull_updown(client-&gt;irq, PullEnable); irq = gpio_to_irq(client-&gt;irq); //result = request_irq(irq, sensor_interrupt, sensor-&gt;ops-&gt;trig, sensor-&gt;ops-&gt;name, sensor); result = request_threaded_irq(irq, NULL, sensor_interrupt, sensor-&gt;ops-&gt;trig, sensor-&gt;ops-&gt;name, sensor); //result = devm_request_threaded_irq(&amp;client-&gt;dev, irq, NULL, sensor_interrupt, sensor-&gt;pdata-&gt;irq_flags | IRQF_ONESHOT, sensor-&gt;ops-&gt;name, sensor); if (result) &#123; printk(KERN_INFO \"%s:fail to request irq = %d, ret = 0x%x\\n\",__func__, irq, result); goto error; &#125; client-&gt;irq = irq; if((sensor-&gt;pdata-&gt;type == SENSOR_TYPE_GYROSCOPE) || (sensor-&gt;pdata-&gt;type == SENSOR_TYPE_ACCEL) || (sensor-&gt;pdata-&gt;type == SENSOR_TYPE_ANGLE)) disable_irq_nosync(client-&gt;irq);//disable irq if(((sensor-&gt;pdata-&gt;type == SENSOR_TYPE_LIGHT) || (sensor-&gt;pdata-&gt;type == SENSOR_TYPE_PROXIMITY))&amp;&amp; (!(sensor-&gt;ops-&gt;trig &amp; IRQF_SHARED))) disable_irq_nosync(client-&gt;irq);//disable irq if(((sensor-&gt;pdata-&gt;type == SENSOR_TYPE_TEMPERATURE) || (sensor-&gt;pdata-&gt;type == SENSOR_TYPE_PRESSURE))&amp;&amp; (!(sensor-&gt;ops-&gt;trig &amp; IRQF_SHARED))) disable_irq_nosync(client-&gt;irq);//disable irq DBG(\"%s:use irq=%d\\n\",__func__,irq); &#125; else if(!sensor-&gt;pdata-&gt;irq_enable) &#123; INIT_DELAYED_WORK(&amp;sensor-&gt;delaywork, sensor_delaywork_func); if(sensor-&gt;pdata-&gt;poll_delay_ms &lt; 0) sensor-&gt;pdata-&gt;poll_delay_ms = 30; DBG(\"%s:use polling,delay=%d ms\\n\",__func__,sensor-&gt;pdata-&gt;poll_delay_ms); &#125;error: return result;&#125; 소스가 길지만 여기서 눈여겨 볼 것은 INIT_DELAYED_WORK와 schedule_delayed_work이다. 이 인터럽트는 위 함수를 쓴거와 같이 workqueue 인터럽트를 사용했다. workqueue 인터럽트는 바톰 하프의 한 종류로서 softirq, tasklet, workqueue_struct중 세번째에 해당된다. 특징으로는 사용자 편의성이 높고 지연된 작업이 프로세스 컨텍스트에서 수행되어야 하는 경우 네트워크 서브시스템과 같이 초당 수천번의 인터럽트가 발생하는 상황에는 적합하지 않음 지연된 작업을 처리하기 위해 스케줄 가능한 요소, 즉 휴면(blocking)해야할 필요가 있는 경우에 적합하다. 다시 돌아와서 내가 관심같는 key의 소스를 보면 역시 interrupt가 구현되어 있다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465static int keys_probe(struct platform_device *pdev)&#123; ... for (i = 0; i &lt; ddata-&gt;nbuttons; i++) &#123; struct rk_keys_button *button = &amp;ddata-&gt;button[i]; button-&gt;dev = &amp;pdev-&gt;dev; if (button-&gt;type == TYPE_GPIO) &#123; int irq; error = devm_gpio_request(dev, button-&gt;gpio, button-&gt;desc ? : \"keys\"); if (error &lt; 0) &#123; pr_err(\"gpio-keys: failed to request GPIO %d, error %d\\n\", button-&gt;gpio, error); goto fail1; &#125; error = gpio_direction_input(button-&gt;gpio); if (error &lt; 0) &#123; pr_err(\"gpio-keys: failed to configure input direction for GPIO %d, error %d\\n\", button-&gt;gpio, error); gpio_free(button-&gt;gpio); goto fail1; &#125; irq = gpio_to_irq(button-&gt;gpio); if (irq &lt; 0) &#123; error = irq; pr_err(\"gpio-keys: Unable to get irq number for GPIO %d, error %d\\n\", button-&gt;gpio, error); gpio_free(button-&gt;gpio); goto fail1; &#125; error = devm_request_irq(dev, irq, keys_isr, button-&gt;active_low ? IRQF_TRIGGER_FALLING : IRQF_TRIGGER_RISING, button-&gt;desc ? button-&gt;desc : \"keys\", button); if (error) &#123; pr_err(\"gpio-keys: Unable to claim irq %d; error %d\\n\", irq, error); gpio_free(button-&gt;gpio); goto fail1; &#125; &#125; &#125; input_set_capability(input, EV_KEY, KEY_WAKEUP); /* adc polling work */ if (ddata-&gt;chan) &#123; INIT_DELAYED_WORK(&amp;ddata-&gt;adc_poll_work, adc_key_poll); schedule_delayed_work(&amp;ddata-&gt;adc_poll_work, ADC_SAMPLE_JIFFIES); &#125; ...&#125; 해당 소스를 보면 열심히 key와 관련되어서 초기화 시 interrupt를 설정하였다. 그런데 왜 power-key가 작동하지 않았을까… 결론은 마지막에 if (ddata-&gt;chan)의 조건문을 만족하지 못해서 workqueue가 등록되지 안았다. 여기서 chan은 chan = iio_channel_get(&amp;pdev-&gt;dev, NULL);에서 얻어온다. io-chaanel인가를 뜻하는 거 같은데… 잘 모르겠다.하여튼 내가 쓰는 key는 일단 power-key 하나이므로 과감히 해당 조건문을 주석처리 했다. 결론적으로 g-sensor와 power-key가 동시에 잘 동작하는 것을 확인했다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Kernel","slug":"Android/Platform-Kernel","permalink":"http://jung-max.github.io/categories/Android/Platform-Kernel/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"}]},{"title":"Git 하위폴더의 git 지우기","slug":"Git-하위폴더의-git지우기","date":"2019-11-13T07:15:33.000Z","updated":"2022-02-08T02:11:11.789Z","comments":true,"path":"2019/11/13/Git-하위폴더의-git지우기/","link":"","permalink":"http://jung-max.github.io/2019/11/13/Git-하위폴더의-git지우기/","excerpt":"","text":"기존에 있는 프로젝터를 다운받고 최상위 폴더에서 내가 git을 생성했을 때 GitLab등의 버전 관리 페이지에서 다음과 같은 표시와 함께 폴더에 접근이 불가한 경우가 있습니다. 여기서 @표시가 된것은 common폴더가 이미 git으로 관리되고 있기 때문입니다. 보통은 이와 같이 하위 폴더에서 또다른 git으로 버전 관리를 하는 것을 submodule이라고 합니다. 하지만 지금 설명하는 것은 정상적으로 submodule을 추가한 것이 아닌 기존 하위폴더들에서 git으로 버전관리를 하고 있을 때 상위 폴더에 git을 새로 생성되었을 때를 설명합니다. 이때 기존 하위폴더의 git을 살리는 것도 한 방법이지만 따로 버전관리를 하고 싶지 않을때가 있습니다. 이럴때 다음과 같은 방법으로 하위 폴더의 git을 지우고 나의 버전 관리 안에 포함할 수 있습니다. 다만 이 방법은 기존의 하위폴더의 git의 이력을 포함하지 못합니다. 아래와 같은 방법으로 하위 폴더의 cache를 지워줍니다.git rm -r --cached path_to_your_folder/ 하위 폴더로 진입하고 .git폴더를 지워줍니다. 이때 중요한 것은 최상위 폴더의 .git폴더가 아닌 내가 지우고 싶은 폴더에 있는 .git폴더 입니다. git add .등의 방법으로 하위 폴더를 추가하고 git commit -m &quot;commit&quot;등으로 커밋해 줍니다. 그후 push를 하면 gitLab이나 gitHub등에서 폴더에 접근이 가능한 것을 확인 할 수 있습니다.","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"Git","slug":"기타/Git","permalink":"http://jung-max.github.io/categories/기타/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://jung-max.github.io/tags/Git/"},{"name":"submodule","slug":"submodule","permalink":"http://jung-max.github.io/tags/submodule/"}]},{"title":"Android 부팅시 동작하는 service app","slug":"Android-부팅시동작하는-service앱","date":"2019-11-12T00:32:02.000Z","updated":"2022-02-08T02:11:11.780Z","comments":true,"path":"2019/11/12/Android-부팅시동작하는-service앱/","link":"","permalink":"http://jung-max.github.io/2019/11/12/Android-부팅시동작하는-service앱/","excerpt":"","text":"개요Booting시 동작하는 Service App을 안드로이드 AOSP에 탑재하는 것을 설명한다. 이는 Activity를 삭제하고 Service로만 이루어진 App으로서 Android AOSP(플랫폼)에 탑재하여 부팅시 Service를 구동시키는 것이다. 이 방법으로 App을 탑재하면 사용자는 App목록에서 볼 수 없고 디버깅 또는 현재 동작하는 서비스를 확인하여 구동을 확인할 수 있다. AOSP에 탑재하기BroadcastReceiver 설정AOSP에 탑재하면 일단 Activity가 필요가 없다. 그렇기 때문에 manifests를 다음과 같이 구성 할 수 있다. 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.service&quot; android:sharedUserId=&quot;android.uid.system&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; &lt;application android:allowBackup=&quot;true&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:label=&quot;@string/app_name&quot; android:roundIcon=&quot;@mipmap/ic_launcher_round&quot; android:supportsRtl=&quot;true&quot; android:theme=&quot;@style/AppTheme&quot;&gt; &lt;service android:name=&quot;.BootService&quot;/&gt; &lt;receiver android:name=&quot;.Autostart&quot; android:enabled=&quot;true&quot; android:exported=&quot;false&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;/application&gt;&lt;/manifest&gt; Activity가 없는 App으로 부팅을 감지하는 BroadcastReceiver와 Service로 이루어져 있다. Boot를 감지하는 BroadcastReceiver는 다음과 같이 이루어 진다. 123456789101112131415import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;public class Autostart extends BroadcastReceiver&#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction().equals(Intent.ACTION_BOOT_COMPLETED)) &#123; Intent i = new Intent(context, BootService.class); context.startService(i); &#125; &#125;&#125; ACTION_BOOT_COMPLETED를 수신시 BootService 서비스를 실행하는 동작을 수행하게 된다. APK로 빌드 후 AOSP에 탑재하기 위와 같이 Android Studio에서 APK로 빌드한다. 그 후 프로젝터폴더\\app\\build\\outputs\\apk\\debug를 보면 app-debug.apk가 생성되어 있다. 해당 apk를 아래 폴더에 저장한다.AOSP폴더\\vendor\\제조사\\common\\apps\\프로젝트이름 apps폴더의 apps.mk에 추가한 프로젝트이름 폴더를 추가한다. 해당 폴더에 apk를 저장한 후 Android.mk를 추가한다.예시는 아래와 같다. 1234567891011121314LOCAL_PATH := $(call my-dir)include $(CLEAR_VARS)LOCAL_MODULE := 프로젝트이름LOCAL_MODULE_CLASS := APPSLOCAL_MODULE_TAGS := optionalLOCAL_BUILT_MODULE_STEM := package.apkLOCAL_MODULE_SUFFIX := $(COMMON_ANDROID_PACKAGE_SUFFIX)#LOCAL_PRIVILEGED_MODULE :=LOCAL_CERTIFICATE := platform#LOCAL_OVERRIDES_PACKAGES := LOCAL_SRC_FILES := $(LOCAL_MODULE).apk#LOCAL_REQUIRED_MODULES :=#LOCAL_PREBUILT_JNI_LIBS :=include $(BUILD_PREBUILT)","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"Service","slug":"Service","permalink":"http://jung-max.github.io/tags/Service/"},{"name":"Booting","slug":"Booting","permalink":"http://jung-max.github.io/tags/Booting/"}]},{"title":"Rockchip U-Boot 분석","slug":"Rockchip_uBoot_분석","date":"2019-11-06T00:59:34.000Z","updated":"2022-02-08T02:11:11.819Z","comments":true,"path":"2019/11/06/Rockchip_uBoot_분석/","link":"","permalink":"http://jung-max.github.io/2019/11/06/Rockchip_uBoot_분석/","excerpt":"","text":"U-Boot 소개Rockchip U-Boot는 다음을 지원하는 오픈 소스 UBoot 2014.10 공식 버전을 기반으로합니다. 지원 칩 : RK3288, RK3036, RK312X, RK3368, RK322X, RK3366, RK3399, RK3328, RK322XH 등 Android 플랫폼의 펌웨어 시작을 지원합니다. 프로그램에 ROCKUSB 및 Google Fastboot 지원; 보안 부팅 펌웨어 서명 암호화 보호 메커니즘을 지원합니다. LVDS, EDP, MIPI, HDMI, CVBS와 같은 디스플레이 장치 지원; SDCard, Emmc, Nand Flash 및 U 디스크와 같은 저장 장치를 지원합니다. 부팅 로고 디스플레이, 충전 애니메이션 디스플레이, 저전력 관리, 전원 관리를 지원합니다. I2C, SPI, PMIC, CHARGE, GUAGE, USB, GPIO, PWM, DMA, GMAC, EMMC, NAND 인터럽트 및 기타 드라이버 지원; 플랫폼 아키텍처 지원Rockchip U-Boot는 U-Boot 2014.10의 공식 버전을 기반으로하며 주요 지점의 일부 주요 업데이트를 업데이트하고 새로운 구성 및 컴파일 아키텍처를 지원하며 여러 플랫폼을 동시에 개발할 수 있도록합니다. 컴파일과 설정툴체인 구성Rockchip U-Boot는 U-BOOT 루트 디렉토리의 Makefile에 지정된 Google Android에서 제공하는 GCC ToolChain으로 기본 설정됩니다. 참고 : ARCHV는 64 비트와 32 비트 GCC 툴체인을 구별하고 ARCHV = aarch64 매개 변수를 추가 할 때 추가합니다. 플랫폼 구성플랫폼 구성 파일은 U-Boot 루트 디렉토리 아래의 configs 폴더에 있으며 Rockchip 관련은 RK로 시작하며 제품 형태에 따라 MID와 BOX로 나뉩니다. rk3288_defconfigrk3126_defconfigrk3128_defconfigrk3368_defconfigrk3288_box_defconfigrk3128_box_defconfigrk3036_box_defconfigrk3368_box_defconfigrk322x_box_defconfigrk322xh_box_defconfigrk3328_box_defconfig Rockchip 칩 플랫폼의 구성은 주로 칩 유형이며 Rockchip의 일부 주요 구성은 savedefconfig 모드로 저장됩니다. rk322x_box_defconfig를 예로 들어 관련 구성의 의미를 설명하십시오. 12345CONFIG_SYS_EXTRA_OPTIONS=&quot;RKCHIP_RK322X,PRODUCT_BOX,NORMAL_WORLD,SECOND_LEVEL_BOOTLOADER,BAUDRATE=1500000&quot; CONFIG_ARM=y CONFIG_ROCKCHIP=y CONFIG_ROCKCHIP_ARCH32=y CONFIG_SYS_EXTRA_OPTIONS=&quot;RKCHIP_RK322X,PRODUCT_BOX,NORMAL_WORLD,SECOND_LEVEL_BOOTLOADER, BAUDRATE=1500000&quot; 이 옵션의 구성은 매크로 정의로 컴파일되고 관련 항목 앞에 자동으로 CONFIG_가 추가됩니다 U-BOOT 자동 생성 구성 파일 (include/config.h)에서 생성 된 매크로 정의를 볼 수 있습니다. 시스템의 구성 파일을 관리하는 구성 파일. RKCHIP_RK322X : RK322x의 칩 유형을 정의하고 컴파일하고 CONFIG_ RKCHIP_RK322X로 확장하십시오. PRODUCT_BOX : BOX 제품을 정의합니다. 현재 제품 양식에는 MID 및 BOX가 있으며, 컴파일하고 CONFIG_PRODUCT_BOX로 확장합니다. NORMAL_WORLD : U-BOOT가 일반 세계에서 실행되도록 정의합니다. SECOND_LEVEL_BOOTLOADER : U-BOOT를 보조 로더 모드로 정의이 옵션은 NAND Flash 프로젝트 및 보안 프레임 워크 드라이버를 사용할 때 정의해야합니다. CONFIG_SECOND_LEVEL_BOOTLOADER 로의 확장 확장; BAUDRATE = 1500000 : 디버그 직렬 포트의 전송 속도를 정의하며 기본값은 115200이며 1.5M으로 구성됩니다. CONFIG_BAUDRATE = 1500000으로 확장을 컴파일하십시오. CONFIG_ARM = yARM 플랫폼을 정의하십시오. CONFIG_ROCKCHIP = yRockchip의 플랫폼을 정의하십시오. CONFIG_ROCKCHIP_ARCH32 = yRK 칩 시리즈 유형 플랫폼, RK30 시리즈, RK32 시리즈 및 기타 32 비트 칩을 정의하십시오. CONFIG_ROCKCHIP_ARCH64 = yRK33 시리즈와 같은 64 비트 칩인 RK 칩 시리즈 유형의 플랫폼을 정의하십시오. 시스템 구성시스템 구성 파일은 U-Boot 루트 디렉토리 아래의 include\\configs 폴더에 있으며 RK로 시작합니다. rk_default_config.hrk30plat.hrk32plat.hrk33plat.h Rk_default_config.h : RK 플랫폼의 공개 구성으로 기본적으로 모든 필수 기능이 열립니다. RK30plat.h : RK30 시리즈 플랫폼 구성, 메모리 주소, 일부 기능 모듈의 간단한 구성과 같은 다른 칩 구성에 따라 RK30 시리즈에는 RK3036, RK3126, RK3128, RK322x 및 기타 칩이 포함됩니다. RK32plat.h : RK32 시리즈 플랫폼 구성, 메모리 주소, 일부 기능 모듈의 간단한 구성과 같은 다른 칩 구성에 따라 RK32 시리즈에는 RK3288이 포함됩니다. RK33plat.h : RK33 시리즈 플랫폼 구성, 메모리 주소, 일부 기능 모듈의 간단한 구성과 같은 다른 칩 구성에 따라 RK33 시리즈에는 RK3368, RK3366, RK3399, RK3328, RK322XH 등이 포함됩니다. 참고 :이 파일에서는 //를 주석으로 사용할 수 없으므로 U-BOOT에서 lds 파일을 구문 분석 할 수 있습니다. 관련 모듈을 정의하지 않으려면 /* */ 또는 #undef를 직접 사용할 수 있습니다. 주요 시스템 구성 지침 : 123456789101112131415161718192021222324/* * UBOOT memory map * * CONFIG_SYS_TEXT_BASE is the default address which maskrom loader UBOOT code. * CONFIG_RKNAND_API_ADDR is the address which maskrom loader miniloader code. * * kernel load address: CONFIG_SDRAM_PHY_START + 32M, size 16M, * miniloader code load address: CONFIG_SDRAM_PHY_START + 48M, size 8M, * total reverse memory is CONFIG_LMB_RESERVE_MEMORY_SIZE. * *|---------------------------------------------------------------------------| *|START - KERNEL LOADER - NAND LOADER - LMB - UBOOT - END| *|SDRAM - START 32M - START 48M - START 56M - START 80M - 128M| *| - kernel - nand code - fdt - UBOOT/ramdisk | *|---------------------------------------------------------------------------| */ /* rk kernel load address */ #define CONFIG_KERNEL_LOAD_ADDR (CONFIG_RAM_PHY_START + SZ_32M) /* 32M offset */ /* rk nand api function code address */ #define CONFIG_RKNAND_API_ADDR (CONFIG_RAM_PHY_START + SZ_32M + SZ_16M) /* 48M offset */ /* rk UBOOT reserve size */ #define CONFIG_LMB_RESERVE_SIZE (SZ_32M + SZ_16M + SZ_8M) /* 56M offset */ CONFIG_KERNEL_LOAD_ADDR 커널에서로드 한 주소를 32M의 DDR 오프셋으로 구성합니다.CONFIG_RKNAND_API_ADDR DDR 오프셋 48M으로 Nand Flash 드라이버 API 인터페이스 주소를 구성합니다.CONFIG_LMB_RESERVE_SIZE U-BOOT 예약 공간의 크기를 구성합니다. 12345678/* rk ddr information */ #define CONFIG_RK_MAX_DRAM_BANKS 8 /* rk ddr max banks */ #define CONFIG_RKDDR_PARAM_ADDR (CONFIG_RAM_PHY_START + SZ_32M) /* rk ddr banks address and size */#define CONFIG_RKTRUST_PARAM_ADDR (CONFIG_RAM_PHY_START + SZ_32M + SZ_2M) /* rk trust os banks address and size */ /* rk hdmi device information buffer (start: 128M - size: 8K) */ #define CONFIG_RKHDMI_PARAM_ADDR CONFIG_RAM_PHY_END CONFIG_RK_MAX_DRAM_BANKS DDR 용량 정보를 전달하는 DDR 드라이브의 뱅크 수를 구성합니다.CONFIG_RKDDR_PARAM_ADDR 32M 오프셋 된 용량 정보를 전송하도록 DDR 드라이브의 주소를 구성합니다.CONFIG_RKTRUST_PARAM_ADDR ARM Trusted Firmware 사용시 커널이 예약 한 공간 정보를 구성합니다.CONFIG_RKHDMI_PARAM_ADDR HDMI 구성에 대한 일부 정보에는 커널이 얻은 주소가 필요합니다. 123#define CONFIG_RAM_PHY_START 0x00000000 #define CONFIG_RAM_PHY_SIZE SZ_128M #define CONFIG_RAM_PHY_END (CONFIG_RAM_PHY_START + CONFIG_RAM_PHY_SIZE) 위의 세 매크로는 전체 U-Boot에서 사용하는 SDRAM의 공간 범위를 정의합니다. 123#define CONFIG_BOOTDELAY 0 #define CONFIG_BOARD_DEMO #define CONFIG_RK_IO_TOOL CONFIG_BOOTDELAY U-Boot가 셸에서 시작 지연을 활성화할지 여부를 구성합니다. 기본값 0은 직접 시작하는 지연이 없음을 의미하며 3 초 지연해야하는 경우 3으로 정의됩니다.CONFIG_RK_IO_TOOL U-Boot Shell에서 간단한 IO 도구 도구를 구성하십시오.CONFIG_BOARD_DEMO 간단한 테스트 데모 프로그램 사용 여부를 구성하십시오. 1#define CONFIG_MAX_MEM_ADDR RKIO_IOMEMORYMAP_START CONFIG_MAX_MEM_ADDR은 SOC가 DDR에 액세스 할 수있는 최대 주소 물리적 공간을 정의합니다 .DDR의 실제 용량이이 값보다 크면 매크로가 작동하여 결국 DTB에 의해 커널로 전달됩니다. 1#define CONFIG_SYS_TEXT_BASE 0x00200000 /* Resersed 2M space Runtime Firmware bin. */ CONFIG_SYS_TEXT_BASE는 U-BOOT 작업을위한 시작 공간을 정의합니다. 1#define CONFIG_KERNEL_RUNNING_ADDR (CONFIG_SYS_TEXT_BASE + SZ_512K) CONFIG_KERNEL_RUNNING_ADDR은 지정된 복사 커널의 주소입니다.이 매크로가 정의되면 U-BOOT는 커널을이 위치로 직접 복사하고 시작시 시작합니다. 그렇지 않으면 기본적으로 DDR 오프셋 32M에 복사됩니다. 압축되지 않은 커널을 사용하여 부팅 속도를 높이십시오. CONFIG_RK_SDCARD_BOOT_ENCONFIG_RK_SDMMC_BOOT_ENCONFIG_RK_SDHCI_BOOT_ENCONFIG_RK_FLASH_BOOT_ENCONFIG_RK_UMS_BOOT_EN이 매크로는 SOC에서 지원하는 저장 장치를 정의하고 활성화 및 undef 닫기를 정의합니다. CONFIG_MERGER_TRUSTOSCONFIG_RK_TOS_WITH_TACONFIG_MERGER_TRUSTOS UBOOT가 신뢰 이미지를 병합할지 여부를 구성하십시오.CONFIG_RK_TOS_WITH_TA 구성 신뢰 이미지는 ta가있는 펌웨어이며 armv7 플랫폼은 매크로를 사용합니다. 12#define CONFIG_SECUREBOOT_CRYPTO #define CONFIG_SECUREBOOT_SHA256 CONFIG_SECUREBOOT_CRYPTO 암호화 하드웨어 암호 해독 기능 활성화 여부를 설정하십시오 이제 칩에 암호화 모듈이있는 한 기본적으로이 칩을 열어 부팅 이미지의 SHA 확인 속도를 높입니다.CONFIG_SECUREBOOT_SHA256은 SHA256 기능을 활성화하는 것으로, 이후의 일부 제품 보안 요구 사항이 점점 높아지고 있으며 sha256을 소개하겠습니다. 123#define CONFIG_NORMAL_WORLD #define CONFIG_SECURE_RSA_KEY_IN_RAM #define CONFIG_SECURE_RSA_KEY_ADDR (CONFIG_RKNAND_API_ADDR + SZ_2K) Rockchip SOC가 ARM Trusted Fireware를 출시 한 후 U-BOOT는 일반적인 단어로 작동하므로 안전한 efuse에 직접 액세스 할 수 없으므로, 미니 로더는 DDR의 펌웨어 확인을 위해 공개 키를 U-BOOT에 전달해야합니다. CONFIG_LCDCONFIG_RK_POWERCONFIG_PM_SUBSYSTEMCONFIG_RK_CLOCKCONFIG_RK_IOMUXCONFIG_RK_I2CCONFIG_RK_KEYCONFIG_RK_EFUSECONFIG_CMD_ROCKUSBCONFIG_CMD_FASTBOOTCONFIG_RK_MCU 해당 모듈의 활성화 여부를 구성하십시오. 시스템 컴파일32 비트 플랫폼은 RK3288을 예로 사용합니다. 12make rk3288_defconfig make 64 비트 플랫폼은 RK3368을 예로 사용합니다. 12make rk3368_defconfig make ARCHV=aarch64 Rockchip U-BOOT는 두 가지 빌드 스크립트를 제공합니다. mkv7.sh-32 비트 SOC 컴파일 및 mkv8.sh-64 비트 SOC 컴파일 스키마 파일Rockchip SOC 아키텍처 관련 파일 디렉토리 :arch\\arm\\include\\asm\\arch-rk32xx\\arch\\arm\\cpu\\armv7\\rk32xx\\arch\\arm\\include\\asm\\arch-rk33xx\\arch\\arm\\cpu\\armv8\\rk33xx\\board\\rockchip\\common\\ 드라이버 관련 파일 디렉토리 :drivers\\ 툴 관련 파일 디렉토리 :tools\\tools\\rk_tools\\ 펌웨어 생성Rockchip 플랫폼 로더는 첫 번째 모드와 두 번째 모드로 구분되며 해당 로더 펌웨어는 다른 플랫폼 구성에 따라 생성됩니다. 보조 로더 모드는 매크로 CONFIG_SECOND_LEVEL_BOOTLOADER에 의해 정의됩니다. 레벨 1 로더 모드U-BOOT는 Level 1 로더 모드로 EMMC 저장 장치 만 지원하며 컴파일 완료 후 생성 된 이미지는 다음과 같습니다.RK3288LoaderU-BOOT_V2.17.01.bin V2.17.01은 출시 된 버전 번호이며 Rockchip은 U-Boot 로더 버전을 정의하고 2.17은 스토리지 버전에 따라 정의됩니다. 고객은이 버전을 수정해서는 안됩니다 .01은 U-Boot에 의해 정의 된 작은 버전입니다. Makefile에서 수정되었습니다. 보조 로더 모드U-Boot는 보조 로더 모드이며 펌웨어는 모든 저장 장치를 지원하며이 모드에서는 MiniLoader 지원이 필요하며 매크로는 CONFIG_MERGER_MINILOADER 매크로에 의해 생성됩니다. Arm Trusted Firmware를 도입하면 매크로 CONFIG_MERGER_TRUSTIMAGE에 의해 생성 된 신뢰 이미지가 생성됩니다. 예를 들어, 생성 된 이미지를 컴파일하는 Rk322x :RK322XMiniLoaderAll_V2.31.binUBOOT.imgtrust.img V2.31은 출시 된 버전 번호이고 rockchip은 U-Boot 로더 버전을 정의하고 2.31은 스토리지 버전에 따라 정의되므로 고객은이 버전을 수정해서는 안됩니다. UBOOT.img는 보조 로더로서 U-Boot 패키지입니다. trust.img는 보조 로더로서 U-Boot 패키지입니다. RK3036, RK3126, RK3128, RK322x, RK3368, RK3366, RK3399, RK3328, RK322XH 등은 2 차 로더 모드를 사용합니다. 캐시 메커니즘Rockchip 시리즈 칩 캐시 인터페이스는 U-Boot에서 제공하는 표준 인터페이스를 사용하므로 자세한 내용은 공식 U-Boot 설명서를 참조하십시오. 캐시와 관련된 일부 구성 지침 : CONFIG_SYS_ICACHE_OFFicache 스위치는 정의 된 경우 icache 기능을 비활성화하는 것을 의미합니다. CONFIG_SYS_DCACHE_OFFdcache 스위치는 정의 된 경우 dcache 기능이 꺼져 있음을 의미합니다. 참고 : dcache를 시작하기 전에 mmu를 구성하십시오. CONFIG_SYS_L2CACHE_OFFL2 캐시 스위치. dcache 모드 구성CONFIG_SYS_ARM_CACHE_WRITETHROUGH 구성 dcache writethrouch 모드;CONFIG_SYS_ARM_CACHE_WRITEALLOC dcache writealloc 모드 구성; 기본값은 dcache 쓰기 저장 모드입니다. icache의 일반적인 인터페이스는 다음과 같습니다. 12void icache_enable (void); void icache_disable (void); dcache의 일반적인 인터페이스는 다음과 같습니다. 12345678910void dcache_enable (void); void dcache_disable (void); void flush_cache (unsigned long, unsigned long); void flush_dcache_all(void); void flush_dcache_range(unsigned long start, unsigned long stop);void invalidate_dcache_range(unsigned long start, unsigned long stop); void invalidate_dcache_all(void); void invalidate_icache_all(void); Rockchip은 i2c, spi, pmic, charge, guage, usb, gpio, pwm, dma, gmac, emmc, nand 인터럽트 및 기타 드라이버를 지원합니다. 인터럽트 메커니즘Rockhip 플랫폼은 표준 U-Boot 인터럽트 인터페이스 기능을 지원합니다 : 12345678910void enable_interrupts (void); int disable_interrupts (void); void irq_install_handler(int irq, interrupt_handler_t *handler, void *data); void irq_uninstall_handler(int irq); int irq_set_irq_type(int irq, unsigned int type); int irq_handler_enable(int irq); int irq_handler_disable(int irq); static inline int gpio_to_irq(unsigned gpio); Clock 드라이버Rockchip Clock 관련 코드는 다음 위치에 있습니다.arch\\arm\\include\\asm\\arch-rk32xx\\clock.harch\\arm\\cpu\\armv7\\rk32xx\\clock.carch\\arm\\cpu\\armv7\\rk32xx\\clock-rk3288.carch\\arm\\cpu\\armv7\\rk32xx\\clock-rk3036.carch\\arm\\cpu\\armv7\\rk32xx\\clock-rk312x.carch\\arm\\include\\asm\\arch-rk33xx\\clock.harch\\arm\\cpu\\armv8\\rk33xx\\clock.carch\\arm\\cpu\\armv8\\rk33xx\\clock-rk3368.c 기본 인터페이스 기능 정의는 arch\\arm\\include\\asm\\arch-rk32xx\\clock.h에 있으며 자세한 내용은 주석을 참조하십시오. 1234/* * rkplat clock set pll mode */ void rkclk_pll_mode(int pll_id, int pll_mode); pll 모드를 느리게 또는 보통으로 설정. 1234/* * rkplat clock set for arm and general pll */ void rkclk_set_pll(void); rk 칩의 관련 pll 구성 1234/* * rkplat clock get arm pll, general pll and so on */ void rkclk_get_pll(void); rk 칩 구성의 pll 가져 오기 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768/* * rkplat clock pll dump */ void rkclk_dump_pll(void);/* * rkplat set sd clock src * 0: codec pll; 1: general pll; 2: 24M */ void rkclk_set_sdclk_src(uint32 sdid, uint32 src); /* * rkplat set sd/sdmmc/emmc clock src */ unsigned int rkclk_get_sdclk_src_freq(uint32 sdid); /* * rkplat set sd clock div, from source input */ int rkclk_set_sdclk_div(uint32 sdid, uint32 div); void rkclk_emmc_set_clk(int div); /* * rkplat get PWM clock, PWM01 from pclk_cpu, PWM23 from pclk_periph */ unsigned int rkclk_get_pwm_clk(uint32 id); /* * rkplat get I2C clock, I2c0 and i2c1 from pclk_cpu, I2c2 and i2c3 frompclk_periph */ unsigned int rkclk_get_i2c_clk(uint32 i2c_bus_id); /* * rkplat get spi clock, spi0 and spi1 from pclk_periph */ unsigned int rkclk_get_spi_clk(uint32 spi_bus);/* * rkplat lcdc aclk config * lcdc_id (lcdc id select) : 0 - lcdc0, 1 - lcdc1 * pll_sel (lcdc aclk source pll select) : 0 - codec pll, 1 - general pll * div (lcdc aclk div from pll) : 0x00 - 0x1f */ int rkclk_lcdc_aclk_set(uint32 lcdc_id, uint32 pll_sel, uint32 div); /* * rkplat lcdc dclk config * lcdc_id (lcdc id select) : 0 - lcdc0, 1 - lcdc1 * pll_sel (lcdc dclk source pll select) : 0 - codec pll, 1 - general pll * div (lcdc dclk div from pll) : 0x00 - 0xff */ int rkclk_lcdc_dclk_set(uint32 lcdc_id, uint32 pll_sel, uint32 div); /* * rkplat lcdc dclk and aclk parent pll source * lcdc_id (lcdc id select) : 0 - lcdc0, 1 - lcdc1 * dclk_hz: dclk rate * return dclk rate */ int rkclk_lcdc_clk_set(uint32 lcdc_id, uint32 dclk_hz);/* * rkplat pll select by clock * clock: device request freq HZ * return value: * high 16bit: 0 - codec pll, 1 - general pll * low 16bit : div */uint32 rkclk_select_pll_source(uint32 clock, uint32 even); 정상적인 상황에서는 시계의 내용을 수정할 필요가 없으며 권장 구성을 사용할 수 있습니다. GPIO 드라이버drivers\\gpio\\rk_gpio.c 파일의 Rockip 플랫폼 gpio 인터페이스 기능은 다음과 같습니다. RK GPIO 정의 규칙은 다음과 같습니다. 123456789101112/* * rk gpio api define the gpio format as: * using 32 bit for rk gpio value, * the high 24bit of gpio is bank id, the low 8bit of gpio is pin number * eg: gpio = 0x00010008, it mean gpio1_b0, 0x00010000 is bank id of GPIO_BANK1, 0x00000008 is GPIO_B0 */ /* bank and pin bit mask */ #define RK_GPIO_BANK_MASK 0xFFFFFF00 #define RK_GPIO_BANK_OFFSET 8 #define RK_GPIO_PIN_MASK 0x000000FF #define RK_GPIO_PIN_OFFSET 0 32 비트 정의를 사용하면 상위 24 비트가 뱅크이고 하위 8 비트는 다음과 같은 특정 핀입니다. 1gpio_direction_output(GPIO_BANK7 | GPIO_A4, 1); 특정 뱅크 및 핀은 다음 관련 문서에 정의되어 있습니다.arch\\arm\\include\\asm\\arch-rk32xx\\gpio.harch\\arm\\include\\asm\\arch-rk32xx\\gpio-rk3036.harch\\arm\\include\\asm\\arch-rk32xx\\gpio-rk312X.harch\\arm\\include\\asm\\arch-rk32xx\\gpio-rk3288.harch\\arm\\include\\asm\\arch-rk33xx\\gpio.harch\\arm\\include\\asm\\arch-rk33xx\\gpio-rk3368.h 인터페이스 기능은 다음과 같습니다. 1234/* * Set gpio direction as input */int gpio_direction_input(unsigned gpio); 해당 GPIO를 입력 포트로 구성하십시오. 1234/* * Set gpio direction as output */ int gpio_direction_output(unsigned gpio, int value); 해당 GPIO를 출력 포트로 구성하십시오. 1234/* * Get value of the specified gpio */int gpio_get_value(unsigned gpio) GPIO 관련 IO의 입력 레벨을 가져옵니다. 1234/* * Set value of the specified gpio */int gpio_set_value(unsigned gpio, int value); GPIO 관련 IO의 출력 레벨을 구성하십시오. 1234/* * Set gpio pull up or down mode */int gpio_pull_updown(unsigned gpio, enum GPIOPullType type); GPIO 관련 IO의 상하 풀을 구성하십시오. 1234/* * gpio drive strength slector */int gpio_drive_slector(unsigned gpio, enum GPIODriveSlector slector); GPIO 관련 IO의 드라이브 기능을 구성하십시오. IOMUX 드라이버Rockchip 플랫폼 GPIO 멀티플렉싱 기능 구성, 드라이버 파일 arch\\arm\\include\\asm\\arch-rk32xx\\iomux.harch\\arm\\cpu\\armv7\\rk32xx\\iomux.carch\\arm\\cpu\\armv7\\rk32xx\\iomux-rk3036.carch\\arm\\cpu\\armv7\\rk32xx\\iomux-rk312X.carch\\arm\\cpu\\armv7\\rk32xx\\iomux-rk3288.carch\\arm\\include\\asm\\arch-rk33xx\\iomux.harch\\arm\\cpu\\armv8\\rk33xx\\iomux.carch\\arm\\cpu\\armv8\\rk33xx\\iomux-rk3368.cvoid rk_iomux_config(int iomux_id); ID는 arch\\arm\\include\\asm\\arch-rk32xx\\iomux.h에 정의되어 있습니다. I2C 드라이버Rk I2C는 표준 U-Boot 아키텍처를 지원합니다 자세한 내용은 U-Boot 설명서를 참조하십시오 관련 코드는 다음 위치에 있습니다.drivers\\i2c\\rk_i2c.c 참고 : 현재 i2c 읽기 및 쓰기의 최대 길이는 32 바이트이므로 드라이버가 향상됩니다. int i2c_set_bus_num(unsigned bus_idx)i2c 버스가 작동하도록 설정하십시오. 먼저 구성해야합니다. void i2c_init(int speed, int unused)해당 버스의 i2c를 초기화하십시오. int i2c_set_bus_speed(unsigned int speed)필요한 i2c 버스 주파수 구성 int i2c_probe(uchar chip)지정된 i2c 주소를 감지하는 장치가 존재하는지 여부 int i2c_read(uchar chip, uint addr, int alen, uchar *buf, int len)I2C 읽기 작업 int i2c_write(uchar chip, uint addr, int alen, uchar *buf, int len)I2C 쓰기 작업 SPI 드라이버RK SPI는 표준 U-Boot 아키텍처를 지원합니다 자세한 내용은 U-Boot 설명서를 참조하십시오 관련 코드는 다음 위치에 있습니다.drivers\\spi\\rk_spi.c LCD 드라이버디스플레이 모듈 관련 코드는 다음과 같습니다. drivers/video/rockchip_fb.cdrivers/video/rockchip_fb.hdrivers/video/rk32_lcdc.cdrivers/video/rk3036_lcdc.cdrivers/video/rk3368_lcdc.c 화면의 전원 제어 정보 : rockhip_fb.c에서 rk_fb_pwr_ctr_prase_dt는 전원 제어 인터페이스를 dts로 구문 분석하고 rk_fb_pwr_enable/disable 기능은 각각 디스플레이 모듈의 전원을 전환합니다. 화면의 전원 켜기 순서를 다시 조정해야하는 경우이 기능을 수정할 수 있습니다. U-Boot에서 사용하는 로고는 커널의 루트 디렉토리에 저장되며 컴파일 과정에서 resource.img 파일로 패키지됩니다 로고의 U-Boot 확인에 대해서는 common/lcd.c의 rk_bitmap_from_resource() 함수를 참조하십시오.부팅 로고 로딩 과정 : rk_bitmap_from_resource에서 리소스 파티션의 로고를 구문 분석하십시오. 리소스 파티션을로드하지 못하면 부트 파티션의 리소스에서 로고가로드됩니다. U-Boot의 기본 로고 표시 프로세스이므로 logo.bmp 이미지가 커널 디렉토리에 포함되어 있지 않더라도 U-Boot는 화면 중간에 다음과 같은 그림을 표시합니다. rockchip.bmp라는이 맵은 /u-boot/tools/logos 디렉토리에 저장됩니다 UBOOT.bin의 크기를 최소화하기 위해 이이미지는 매우 작습니다 (200x500, 8 비트 bmp 이미지 만). 부팅 로고를 바꾸려면 U-Boot의 rockchip.bmp를 수정하는 대신 커널에서 logo.bmp를 수정하는 것이 좋습니다. logo_kernel.bmp가 리소스 파티션에 존재하면 U-Boot는 이미지를 ddr에로드하고 명령 줄을 통해 위치를로드하도록 커널에 알리고 새 로고 이미지를 표시합니다. 또한 bmp에 대한 U-Boot의 지원이 약하다는 점을 강조해야하며 현재 다음과 같은 제한 사항을 알고 있습니다. 균일 한 해상도의 이미지 만 지원 모든 bmp 이미지는 다음 명령으로 처리하는 것이 좋으며 처리 된 logo_rle8.bmp가 표시에 사용됩니다. convert -compress rle -colors 256 logo.bmp logo_rle8.bmp 지원 24 비트 bmp 부팅 로고 디스플레이, 지원 커널 업데이트 24 비트 로고 디스플레이.참고 : MID 관련 프로젝트의 경우 U-Boot에서 HDMI 관련 구성을 열지 마십시오. PMIC 드라이버U-Boot에서 부팅 로고, 충전 애니메이션 및 기타 기능을 구현하려면 시스템의 전원을 제어해야합니다. 이러한 기능은 PMU 드라이버에서 구현됩니다.현재 RK U-Boot는 Ricoh 619, ACT8846 및 RK808과 자동으로 호환됩니다. RK312X 프로젝트의 경우 ADC 전력 감지 및 충전 애니메이션 표시가 현재 지원됩니다. 관련 코드는 다음과 같습니다.drivers/power/power_core.cdrivers/power/power_rockchip.cdrivers/power/pmic/pmic_act8846.cdrivers/power/pmic/pmic_ricoh619.cdrivers/power/pmic/pmic_rk808.cdrivers/power/pmic/pmic_rk818.cdrivers/power/fuel_gauge/fg_adc.c power_core.c는 U-Boot 전원 하위 시스템의 핵심 코드이며 pmic, 충전기 및 연료 게이지를 관리하기위한 인터페이스를 제공합니다. power_rockchip.c는 Rockchip 플랫폼 pmic, 충전기 및 연료 게이지와 호환되는 프레임 워크 계층 코드입니다. 시스템 호출을 위해 통합 인터페이스가 위쪽으로 제공되며 다양한 전원 IC가 아래쪽으로 관리됩니다. 다른 PMIC마다 구동됩니다.시스템이 시작되면 pmic_init 시스템 호출을 통해 rk32xx.c 파일의 board_late_init(void)에서 PMIC가 초기화됩니다. 연료 게이지 드라이브U-Boot 충전과 같은 기능을 구현하려면 연료 게이지 (fuel_gauge)에 대한 지원을 추가해야합니다. 현재 RK U-Boot는 2 개의 Ricoh619 및 cw201x 연료 게이지를 지원합니다.drivers/power/fuel_gauge/fg_cw201x.cdrivers/power/fuel_gauge/fg_cw201x.c 시스템이 시작되면 rk32xx.c board_late_init에서 fg_init 인터페이스를 호출하여 연료 게이지가 초기화됩니다.fg_init는 power_rockchip.c에서 구현됩니다. 연료 게이지 드라이버의 경우 다음과 같은 중요한 인터페이스를 구현해야합니다.fg_xxx_init() :이 함수는 기본 연료 게이지 초기화 및 등록을 수행합니다. 이름은 PMIC를 검색하는 데 사용됩니다 (U-Boot의 전원 시스템에서 pmic, charger 및 fuel_gauge는 pmic 장치로 추상화 됨). 여기에있는 이름은 시스템 검색을 위해 fg_names of power_rockchip.c에도 등록되어 있습니다. FG의 ops 인터페이스 : 주로 배터리의 전원 및 충전 상태를 얻는 데 사용 fg_battery_update 인터페이스는 배터리의 전원, 전압 및 기타 정보를 업데이트하는 데 사용되며 fg_battery_check 인터페이스는 배터리 충전 여부를 확인하는 데 사용됩니다.충전 애니메이션을 구현하려면 rk32plat.h/rk30plat.h에서 다음 스위치를 열어야합니다. 기본적으로이 기능은 해제되어 있습니다. 12345#define CONFIG_UBOOT_CHARGE #define CONFIG_CMD_CHARGE_ANIM #define CONFIG_CHARGE_DEEP_SLEEP //ricoch619의 PMU 및 ADC 감지를 사용하십시오.이 옵션을 열지 마십시오#define CONFIG_SCREEN_ON_VOL_THRESD 3550 //3.55v #define CONFIG_SYSTEM_ON_VOL_THRESD 3650 //3.65v 그 중 CONFIG_SCREEN_ON_VOL_THRESD는 시스템 조명 화면의 전압 임계 값이며이 전압 아래에서는 시스템이 밝아지지 않습니다. CONFIG_SYSTEM_ON_VOL_THRESD는 시스템이 정상적으로 시작하기위한 전압 임계 값이며이 전압 이하에서는 U-Boot가 커널을 시작할 수 없습니다. 이 두 전압은 특정 제품 설계에 따라 유연하게 조정할 수 있습니다.이 두 임계 값의 판단은 power_rockchip.c에서 구현됩니다. 또한 충전 애니메이션 및 부팅 로고를 표시하려면 dts에서 UBOOT-logo-on 속성을 설정하십시오. 스토리지 드라이버U-Boot는 emmc, nand flash, sdcard 및 USB 플래시 드라이브와 같은 저장 장치를 지원합니다 nand 플래시 드라이버가 열려 있지 않음 인터페이스가 미니 로더를 통해 U-Boot로 전달되므로 nand 플래시 장치를 지원해야하는 경우 CONFIG_SECOND_LEVEL_BOOTLOADER를 정의하고 그렇지 않으면 U-Boot를 정의해야합니다. emmc 만 지원됩니다.저장소의 Rockchip 저장 장치 추상화, 코드는 board/rockchip/common/storage/storage.c에 있으며 해당 API 인터페이스는 다음과 같습니다. 123456789int32 StorageInit(void);uint16 StorageGetBootMedia(void); int StorageReadLba(uint32 LBA, void *pbuf, uint32 nSec); int StorageWriteLba(uint32 LBA, void *pbuf, uint32 nSec, uint16 mode);int StorageReadPba(uint32 PBA, void *pbuf, uint32 nSec); int StorageWritePba(uint32 PBA, void *pbuf, uint32 nSec); Google FastbootGoogle Fastboot는 로더에서 제공하는 rockusb/adb와 같은 대화식 모드입니다. Fastboot 상호 작용에서 사용되는 PC 도구 소스는 Android 소스 코드 (system/core/fastboot/)에 있으며 Windows 버전과 Linux 버전으로 나뉩니다 (Windows 쪽에서 사용하는 장치 드라이버는 adb와 동일). Fastboot로 들어가는 방법 시작하는 동안 부팅 프로그램 시작 단계에서 버튼을 누릅니다 (3288sdk 보드는 vol-key입니다). 123456 checkKey((uint32 *)&amp;boot_rockusb, (uint32 *)&amp;boot_recovery, (uint32 *)&amp;boot_fastboot);.... &#125; else if(boot_fastboot &amp;&amp; (vbus!=0))&#123; printf(\"fastboot key pressed.\\n\"); frt = FASTBOOT_REBOOT_FASTBOOT; &#125; fastboot 매개 변수가있는 reboot 명령 (reboot fastboot, PMU_SYS_REG0 레지스터를 통해 전달됨) Fastboot에서 지원하는 명령정보 얻기 Fastboot getvar version 버전 얻기 fastboot getvar version-bootloader 버전 얻기 fastboot getvar unlocked 잠금 해제 상태 얻기 fastboot getvar secure 잠금 해제 상태 (unlocked와 반대로) 얻기 fastboot getvar product 제품 정보 얻기 fastboot getvar serialno 일련 번호 얻기 fastboot getvar partition-type: 지정된 파티션 유형을 얻습니다. fastboot getvar partition-size: 지정된 파티션 크기를 가져옵니다. fastboot getvar partition-offset: 지정된 파티션 오프셋을 가져옵니다. 이미지 레코딩fastboot flash &lt;partition_name&gt; &lt;filename&gt; 펌웨어 레코딩(예 : fastboot flash system system.img.parameter/loader를 레코딩 할 때 파티션 이름을 “parameter”/“loader”로 지정)fastboot update &lt;filename&gt; burn 업그레이드 패키지 작성(업그레이드 패키지는 android 소스 코드에서 updatepackage를 작성하여 생성됨) 다시 시작fastboot oem recovery recovery로 재부팅fastboot oem recovery:wipe_data 공장 설정 재시작 및 복원fastboot reboot 다시 시작fastboot reboot-bootloader rockusb 프로그래밍 모드로 다시 시작fastboot continue 다시 시작 장치 잠금 해제 및 잠금fastboot oem unlock 잠금 해제fastboot oem unlock_accept 잠금 해제 확인 (fastboot oem unlock 명령 후 5 초 이내에 입력 필요)fastboot oem lock 잠금 장치 특별 주문fastboot boot &lt;kernel&gt; [ &lt;ramdisk&gt; ] 지정된 펌웨어에서 일시적으로 부팅 (커널은 현재 Image / zImage를 지원하며 커널 끝 또는 리소스 파티션에 dtb를 저장해야 함)fastboot oem log 직렬 포트 로그 정보 얻기fastboot oem ucmd &lt;UBOOT cmds&gt; UBOOT 명령을 실행하십시오. fastboot 잠금 해제fastboot가 잠기면 oem 명령을 프로그래밍하고 실행할 수 없으며 초기 상태는 잠 깁니다.잠금 해제 프로세스는 대략 다음과 같습니다. 패스트 부트 OEM 잠금 해제 실행 5 초 이내에 fastboot oem unlock_accept를 계속 실행하십시오. 기계는 복구로 재부팅하고 공장 설정으로 복원 fastboot를 다시 입력하십시오. fastboot getvar 잠금 해제는 “yes”를 리턴해야합니다 (장치 잠금 해제) fastboot 명령이 fastboot 상태로 들어간 후 장치를 찾을 수 없다는 메시지를 표시하면 명령에 -i 매개 변수를 추가하여 장치 vid를 지정해야합니다 (예 : fastboot -i 0x2207 getvar unlocked). 펌웨어 로딩펌웨어로드에는 boot, recovery, kernel, resource 파티션 및 dtb 파일이 포함됩니다. Boot/Recovery 파티션Boot 및 Recovery 펌웨어는 두 가지 형태로 나뉩니다. 안드로이드 표준 형식표준 펌웨어 형식은 ramdisk와 kernel을 함께 패키징합니다 이미지 파일의 마법 번호는 “ANDROID!”입니다. 1200000000 41 4E 44 52 4F 49 44 21 24 10 74 00 00 80 40 60 ANDROID!$.t...@` 00000010 F9 31 CD 00 00 00 00 62 00 00 00 00 00 00 F0 60 .1.....b.......` 표준 형식에는 서명, 체크섬 및 dtb 파일과 같은 추가 데이터와 같은 정보가있을 수 있습니다. 펌웨어를 패키징 할 때 복구 이미지의 기본값은 표준 형식이며 표준 형식 부팅 이미지는 ./mkimage.sh ota로 생성해야합니다. RK 형식Rk 형식 이미지는 파일 (ramdisk / kernel)과 별도로 패키지되어 있습니다. 이미지 파일의 매직 번호는 “KRNL”입니다. 1200000000 4B 52 4E 4C 42 97 0F 00 1F 8B 08 00 00 00 00 00 KRNLB........... 00000010 00 03 A4 BC 0B 78 53 55 D6 37 BE 4F 4E D2 A4 69 .....xSU.7.ON..i 패키지에서 생성 된 kernel.img 및 기본 패키징 방법으로 생성 된 boot.img는 모두 Rk 형식입니다. 커널 파티션커널 파티션은 커널 정보를 포함합니다. Boot/Recovery 파티션 자체에 시작시 커널 (Android 표준 형식)이있는 경우 커널 파티션이 무시되고 포함 된 커널이 먼저 사용됩니다. Resource 파티션Resource 이미지 형식은 여러 리소스 파일에 쉽게 액세스 할 수 있도록 설계된 간단한 이미지 형식입니다. 매직 번호는 “RSCE”입니다. 1200000000 52 53 43 45 00 00 00 00 01 01 01 00 01 00 00 00 RSCE............ 00000010 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................ U-Boot는 리소스 파티션에서 커널에 필요한 dtb 패키징을 지원합니다. Dtb 파일Dtb 파일은 새로운 버전의 커널 dts 구성 파일의 이진화 된 파일입니다.현재 dtb 파일은 Android 표준 형식의 Boot/Recovery 파티션에 저장하거나 리소스 파티션에 저장할 수 있습니다. U-Boot는 커널이 dtb 파일을로드해야한다고 가정합니다. 펌웨어 로딩 프로세스U-Boot로드 펌웨어 프로세스는 다음과 같습니다. 시작해야하는 boot/recovery 파티션의 램 디스크 내용을로드하십시오. 부팅 파티션의 커널 내용을로드하십시오. 실패하면 (Rk 형식으로) 커널 파티션로드를 계속하십시오 부팅 파티션의 dtb 파일을로드하십시오. 실패하면 계속해서 자원 파티션에서로드를 시도하십시오. Dtb 파일 (fdt) 및 램 디스크는 U-Boot 동적 응용 프로그램의 메모리에로드됩니다. 커널은 메모리 32M 오프셋에로드되어 실행됩니다. Boot_merger 도구Boot_merger는 로더, ddr bin, usb plug bin 및 기타 파일을 패키징하여 프로그래밍 도구에 필요한 로더 형식을 생성하는 Linux 버전 도구입니다. 소스 코드는 U-Boot 소스 코드에 있습니다. UBOOT# ls ./tools/boot_merger.*./tools/boot_merger.c ./tools/boot_merger.h Loader 패키징 및 패키징 풀기 지원패키징 :./tools/boot_merger [--pack] &lt;config.ini&gt;패키징은 패키징 매개 변수를 설명하는 ini 구성 파일의 경로를 전달해야합니다.(현재 사용되는 구성 파일은 다음과 같은 U-Boot 소스 코드 (tools/rk_tools/RKBOOT)에 저장됩니다)./tools/boot_merger ./tools/rk_tools/RKBOOT/RK3288.iniout:RK3288Loader_UBOOT.binfix opt:RK3288Loader_UBOOT_V2.15.binmerge success(RK3288Loader_UBOOT_V2.15.bin) 패키징 풀기 :./tools/boot_merger --unpack &lt;loader.bin&gt; 매개 변수 구성 파일3288 구성 파일을 예로 들어 보겠습니다. 1234567891011121314151617[CHIP_NAME] NAME=RK320A ----칩 이름 : &quot;RK&quot;+ 4B 칩 모델과 maskrom 합의[VERSION] MAJOR=2 ----주요 버전 번호 MINOR=15 ----부 버전 번호 [CODE471_OPTION] ----Code471, 현재 ddr bin으로 설정NUM=1 Path1=tools/rk_tools/32_LPDDR2_300MHz_LPDDR3_300MHz_DDR3_300MHz_20140404.bin [CODE472_OPTION] ---Code472, 현재 usbplug bin으로 설정NUM=1 Path1=tools/rk_tools/rk32xxusbplug.bin [LOADER_OPTION] NUM=2 LOADER1=FlashData ----flash data，현재 ddr bin으로 설정 LOADER2=FlashBoot ----flash boot，현재 UBOOT bin으로 설정 FlashData=tools/rk_tools/32_LPDDR2_300MHz_LPDDR3_300MHz_DDR3_300MHz_20140404.bin FlashBoot=u-boot.bin [OUTPUT] ----출력 경로, 현재 파일 이름은 자동으로 버전 번호를 추가합니다 PATH=RK3288Loader_UBOOT.bin Resource_tool 도구Resource_tool은 임의의 리소스 파일을 패키징하고 리소스 이미지를 생성하는 Linux 도구입니다.소스 코드는 U-Boot 소스 코드 (tools/resource_tool/)에 있습니다. 리소스 이미지 패키징 및 언 패킹 지원패키징./tools/resource_tool [--pack] [--image=&lt;resource.img&gt;] &lt;file list&gt; 같은 : 12UBOOT/tools/resource_tool/resources# ../resource_tool `find . -type f` Pack to resource.img successed! pack_resource.sh 스크립트는 기존 이미지에 자원 파일을 추가 할 수 있습니다. ./pack_resource &lt;resources dir&gt; &lt;old image&gt; &lt;dst image&gt; &lt;resource_tool path&gt; 같은 : 1234567891011121314 UBOOT# sudo ./tools/resource_tool/pack_resource.sh tools/resource_tool/resources/ ../kernel/resource.img resource.img tools/resource_tool/resource_tool Pack tools/resource_tool/resources/ &amp; ../kernel/resource.img to resource.img ... Unpacking old image(../kernel/resource.img): rk-kernel.dtb Pack to resource.img successed! Packed resources: rk-kernel.dtb charge_anim_desc.txt images/battery_4.bmp images/battery_0.bmp images/battery_1.bmp images/battery_2.bmp images/battery_3.bmp images/battery_5.bmp images/battery_fail.bmp resource.img 언패킹./tools/resource_tool --unpack [--image=&lt;resource.img&gt;] [output dir] Trust_merger 툴Trust_merger는 프로그래밍 도구에 필요한 TrustImage 형식을 생성하기 위해 bl30, bl31 bin, bl32 bin 및 기타 파일을 패키징하기위한 Linux 버전 도구입니다. 소스 코드는 U-Boot 소스 코드에 있습니다. UBOOT# ls ./tools/trust_merger.*./tools/trust_merger.c ./tools/trust_merger.h 신뢰 패키징 및 언패킹 지원 패키징 :./tools/trust_merger [--pack] &lt;config.ini&gt; 패키징은 패키징 매개 변수를 설명하는 ini 구성 파일의 경로를 전달해야합니다.(현재 사용되는 구성 파일은 다음과 같은 U-Boot 소스 코드 (tools/rk_tools/RKTRUST)에 저장됩니다) ./tools/trust_merger ./tools/rk_tools/RKTRUST/RK3368.iniout:trust.imgmerge success(trust.img) 언패킹./tools/trust_merger --unpack &lt;trust.img&gt; 매개 변수 구성 파일3368 구성 파일을 예로 들어 보겠습니다. 1234567891011121314151617[VERSION] MAJOR=0 ----주요 버전 번호 MINOR=1 ----부 버전 번호 [BL30_OPTION] ----bl30，현재 mcu bin으로 설정SEC=1 ----BL30 bin이 존재PATH=tools/rk_tools/bin/rk33/rk3368bl30_v2.00.bin ----출력 bin 경로 지정 ADDR=0xff8c0000 ----펌웨어 DDR에서로드 및 실행 주소 [BL31_OPTION] ----Bl31, 현재 멀티 코어 및 전원 관리 관련 bin으로 설정 SEC=1 ----BL31 bin이 존재PATH=tools/rk_tools/bin/rk33/rk3368bl31-20150401-v0.1.bin----출력 bin 경로 지정 ADDR=0x00008000 ----펌웨어 DDR에서로드 및 실행 주소 [BL32_OPTION] SEC=0 ----BL32 bin이 없습니다[BL33_OPTION] SEC=0 ----BL33 bin이 없습니다 [OUTPUT] PATH=trust.img [OUTPUT] ----출력 펌웨어 이름 SDCard 및 U 디스크 부팅 업그레이드Rockchip 장비는 RK 생산 도구로 사용자 정의 된 sdcard, u 디스크 등의 시작 및 업그레이드 기능을 지원합니다. SDCard 부팅 및 업그레이드 구성SDCard 업그레이드 및 부팅 기능은 매크로 CONFIG_RK_SDCARD_BOOT_EN으로 구성되고 rk_default_config.h는 기본적으로 해제되어 있습니다.이 기능을 사용해야하는 경우 rkxxplat.h 관련 플랫폼 구성 파일에서 정의하십시오. UBoot는 업그레이드 된 sdcard를 인식하고 직렬 포트는 다음 메시지를 인쇄합니다.SDCard Update. 시작된 sdcard 인 경우 다음 메시지를 인쇄합니다.SDCard Boot. U 디스크 부팅 및 업그레이드 구성U 디스크 업그레이드 및 부팅 기능은 매크로 CONFIG_RK_UMS_BOOT_EN으로 구성되고 rk_default_config.h는 기본적으로 비활성화되어 있습니다.이 기능을 사용해야하는 경우 rkxxplat.h 관련 플랫폼 구성 파일에서 정의하십시오. UBoot는 업그레이드 된 U 디스크를 인식하고 직렬 포트는 다음 메시지를 인쇄합니다.UMS Update. 시작된 sdcard 인 경우 다음 메시지를 인쇄합니다.UMS Boot. 기능적 구성UMS 관련 매크로는 해당 rkxxplat.h에 정의되어 있습니다.CONFIG_RK_UMS_BOOT_EN U 디스크 부팅 및 업그레이드 기능을 지원하도록 U-Boot를 구성하고 open undef를 닫아 정의하십시오.RKUSB_UMS_BOOT_FROM_DWC2_OTGRKUSB_UMS_BOOT_FROM_DWC2_HOSTRKUSB_UMS_BOOT_FROM_EHCI_HOST1RKUSB_UMS_BOOT_FROM_EHCI_HOST2RKUSB_UMS_BOOT_FROM_EHCI_HOST3 U-Boot USB 프레임 워크의 한계로 인해 5 개의 선택 사항 중 하나의 USB 컨트롤러 만 켜서 USB 플래시 드라이브 기능을 활성화 할 수 있습니다.다음은 rk32plat.h 관련 코드의 예입니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243#ifdef CONFIG_RK_UMS_BOOT_EN /* * USB Host support, default no using * Please first select USB host controller if you want to use UMS Boot * Up to one USB host controller could be selected to enable for booting * from USB Mass Storage device. * * PLS define a host controler from: * RKUSB_UMS_BOOT_FROM_DWC2_OTG * RKUSB_UMS_BOOT_FROM_EHCI_HOST1 * RKUSB_UMS_BOOT_FROM_DWC2_HOST * * First define the host controller here */ /* Check UMS Boot Host define */ #define RKUSB_UMS_BOOT_CNT (defined(RKUSB_UMS_BOOT_FROM_DWC2_OTG) + \\ defined(RKUSB_UMS_BOOT_FROM_EHCI_HOST1) + \\ defined(RKUSB_UMS_BOOT_FROM_DWC2_HOST)) #if (RKUSB_UMS_BOOT_CNT == 0) #error \"PLS Select a USB host controller!\" #elif (RKUSB_UMS_BOOT_CNT &gt; 1) #error \"Only one USB host controller can be selected!\" #else #define CONFIG_CMD_USB #define CONFIG_USB_STORAGE #define CONFIG_PARTITIONS #endif /* * USB Host support, default no using * please first check plat if you want to using usb host */ #if defined(RKUSB_UMS_BOOT_FROM_EHCI_HOST1) #define CONFIG_USB_EHCI #define CONFIG_USB_EHCI_RK #elif defined(RKUSB_UMS_BOOT_FROM_DWC2_HOST) || defined(RKUSB_UMS_BOOT_FROM_DWC2_OTG) #define CONFIG_USB_DWC_HCD #endif#endif /* CONFIG_RK_UMS_BOOT_EN */ CONFIG_RK_UMS_BOOT_EN이 활성화되면 특정 칩 정의에 따라 해당 HOST 포트를 정의해야합니다. 정의가 없거나 정의가 너무 많으면 컴파일시 오류가보고됩니다. 컨트롤러 구성 테이블board\\rockchip\\common\\mediaboot\\UMSBoot.c 특정 칩 플랫폼 및 컨트롤러에 따라 rkusb_hcd 구성 테이블을 채우면 USB Mass_storage가 구성에 따라 초기화됩니다. 12345678struct rkusb_hcd_cfg &#123; bool enable; //확장 기능을 위해 예약되어 있으며 기본값은 True이며 수정이 필요하지 않습니다. void* regbase; //UBOOT 관리자가 작성한 기본 주소 등록 int gpio_vbus; //회로 구성에 따라 사용자가 입력하는 USB 전원 공급 장치 제어 GPIO char *name; //UBOOT 유지 보수 담당자가 입력 한 컨트롤러 이름 void (*hw_init)(void); //UBOOT 관리자로 채워진 콜백 함수 초기화 void (*hw_deinit)(void); //UBOOT 관리자로 채워진 역 초기화 콜백 기능&#125;;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform U-Boot","slug":"Android/Platform-U-Boot","permalink":"http://jung-max.github.io/categories/Android/Platform-U-Boot/"}],"tags":[{"name":"U-Boot","slug":"U-Boot","permalink":"http://jung-max.github.io/tags/U-Boot/"}]},{"title":"Android rk3328 관련 문서 정리","slug":"Android-rk3328-관련문서정리","date":"2019-10-30T06:16:52.000Z","updated":"2022-02-08T02:11:11.777Z","comments":true,"path":"2019/10/30/Android-rk3328-관련문서정리/","link":"","permalink":"http://jung-max.github.io/2019/10/30/Android-rk3328-관련문서정리/","excerpt":"","text":"Camera_for_RockChipSDK 참조 _v4.1 카메라 관련 드라이버위치 : drivers/media/video 현재 카메라는 관심외이므로 일단 스킵하기로 한다. RealTek WiFi 드라이버 포팅 지침 _V1.1 RealTek wifi 드라이버 입력 기능 수정SDIO 또는 USB 방식 RealTek wifi 드라이버 Makefile 수정 RealTek WiFi 드라이버 디버그 로그 스위치 커널에 통합 된 RealTek WiFi 드라이버drivers/net/wireless/의 Makefile, Kconfig 수정drivers/net/wireless rockchip_wlan 디렉토리에 드라이버 추가 Rockchip 오디오 개발 가이드 V1.0-20170215-linux3.10 오디오 관련 개념과 코드 구조 사운드 카드 추가, 사운드 카드 디버그 및 액세스 방법 디버깅 방법 Rockchip CPUFreq-DVFS 개발 가이드 V1.0-20170221Dynamic voltage and frequency scaling CMOS 회로의 전력 소비 소개 DVFS 노드 소개(DTS) CPU DVFS 노드(DTS) GPU DVFS 노드(DTS) DDR DVFS 노드(DTS) 코드 사용 인터페이스 : include/linux/rockchip/dvfs.h 디버그 인터페이스 Rockchip gmac 모듈 개발 안내서 V1.0-20170221개요이더넷 MAC 컨트롤러는 RK 시리즈의 SoC에 내장되어 있으므로 이더넷 카드 기능을 구현하기 위해 하나의 이더넷 PHY 칩만 사용하면됩니다. 사양에 따르면, 다른 제조업체의 PHY가 레지스터 정의의 일부를 가지고 있더라도 이러한 범용 레지스터가 구성되어 있으면 기본적으로 PHY가 정상적으로 작동 할 수 있습니다. 따라서 Linux 드라이버에는 범용 PHY 드라이버가 있으며 현재 칩에 사용되는 SDK는 모두 범용 드라이버이므로 SoC의 MAC 드라이버를 구현해야합니다. 10 / 100M 이더넷 PHY와 MAC 사이의 인터페이스는 주로 MII와 RMII를 포함합니다. 10 / 100 / 1000M 이더넷 PHY와 MAC 간의 인터페이스는 주로 RGMII입니다. GMAC模块 DTS 설정법 MAC주소 취득법 GMAC FQA PHY 레지스터 읽기 및 쓰기 디버깅 Rockchip I2C 개발 가이드 V1.0-20170220-수정 후 I2C 기능 설명 DTS 설정법 코드 drivers/i2c/busses/i2c-rk3x.c FQA Rockchip IO-Domain 개발 가이드 V0.1-20170220 IO 파워 도메인 소개 및 역할io 전원 도메인의 레지스터 구성을 설정하는 것새 dts 파일을 작성할 때 실제 하드웨어 상황에 따라 올바른 구성을 만들어야 전원 도메인을 구성하는 방법 Rockchip PINCTRL 개발 안내서 V0.1-20170220RK3328 / RK3228H Soc에는 핀 컨트롤러가 내장되어 있으며 핀 레지스터를 구성하여 하나 또는 여러 핀 그룹의 기능과 특성을 구성 할 수 있습니다.소프트웨어 측면에서 pinctrl 서브 시스템은 Linux 커널에서 제공되며 pinregister 드라이버는 pinctrl 드라이버로 작동 할 수 있으며 Linux 일반 인터페이스 사용법은 RK3328 / RK3228H pinctrl 드라이버가 다음 작업을 완료합니다.A. 모든 핀 열거 및 이름 지정B. 스위칭 핀 멀티플렉싱 기능C. 핀의 구동 강도 구성D. 핀의 풀다운 기능 구성E. 핀의 슈미터 트리거 기능 구성 드라이브 파일 및 DTS 구성 drivers/pinctrl/pinctrl-rk3368.c 예 - hdmi pinctrl GPIO 등등 Rockchip pwm ir 개발 가이드 V1.00적외선 리모컨 관련 자료/DTS등 Rockchip PWM 백라이트 개발 가이드 -20170220 펄스주기 파형으로 생성되거나 일부 외부 구성 요소와 디지털 시뮬레이션을위한 변환기로 생성되는 제어 방법을 제공합니다. 드라이버 파일 및 DTS 노드 Rockchip Recovery 사용자 안내서 V1.00 복구 모드 소개복구 모드는 Android 시스템 내부의 데이터 또는 시스템을 수정할 수있는 모드를 말합니다 (Windows pe 또는 DOS와 유사). 이 모드에서는 새로운 Android 시스템으로 스 와이프하거나 기존 시스템을 백업 또는 업그레이드 할 수 있으며 여기에서 공장 설정을 복원 할 수도 있습니다. OTA 패키지 컴파일 RK 플랫폼 파티션 업그레이드 지침 Update.img 업그레이드 방법 SecureBoot 서명 도구 Block 업그레이드 방법 Rockchip RK805 개발 안내서 V1.0-20170220이 문서는 Rockchip RK805의 다양한 하위 모듈에 중점을 둡니다. 관련 개념, 기능, dts 구성, 몇 가지 일반적인 문제의 분석 및 위치 지정을 소개합니다. RK805는 4 개의 고전류 DCDC, 3 개의 LDO, RTC 및 조정 가능한 파워 업 타이밍을 통합 한 고성능 PMIC입니다.시스템에는 DCDC와 LDO의 두 가지 유형의 전원이 있습니다. 두 전원 공급 장치의 전체 특성은 다음과 같습니다. 자세한 내용을 검색하십시오. DCDC : 입출력 전압 차가 크면 효율이 높지만, 리플이 크고 비용이 비싸다는 문제가있어 큰 전류에서 큰 전압 차가 사용된다. 일반적으로 두 가지 작동 모드가 있습니다. PWM : 리플 과도 응답이 양호하고 효율이 낮습니다. PFM : 고효율이지만 부하 용량이 낮습니다. LDO : 입력 / 출력 전압 차이가 크면 효율이 낮고 비용이 낮습니다 LDO의 변환 효율을 향상시키기 위해 시스템은 LDO 출력 전압이 1.1V와 같은 관련 최적화를 수행합니다. 효율을 향상시키기 위해 입력 전압은 VCCIO_3에서 나올 수 있습니다. 3V DCDC가 제공됩니다. 따라서 회로가 LDO를 DCDC 출력 루프에 가능한 많이 연결하도록 허용 된 경우 전원 켜기 순서에주의하십시오. 특징RK805의 기능은 네 부분으로 나눌 수 있습니다 : 레귤레이터 기능 : 각 DCDC, LDO 전원 상태 등을 제어합니다. rtc 기능 : 프로세서에 클럭 타이밍, 타이밍 및 기타 기능을 제공합니다. gpio 기능 : out1과 out2 (출력 전용)의 2 개의 푸시 풀 출력 핀이 있으며 일반 GPio로 사용할 수 있으며 AP에 2 개의 GPIO를 저장합니다. pwrkey 기능 : 전원 버튼의 누름 / 해제를 감지하면 AP의 GPIO를 저장할 수 있습니다. 드라이버 및 메뉴 구성 DTS 구성 디버그 모드 Rockchip SDMMC SDIO eMMC 개발 가이드 V1.0-20170215 DMMC DTS 구성 지침 eMMC DTS 구성 Rockchip 보안 부팅 응용 프로그램 Note_v1.6_20170215Rockchip 보안 부팅 응용 프로그램 Note_v1.7_20170519→ secure boot는 논외 Rockchip SPI 개발 안내서 V1.0-20170217SPI (직렬 주변 장치 인터페이스), 다음은 Linux 3.10 spi 드라이버에서 지원되는 기능 중 일부입니다. Motorola SPI 프로토콜이 기본적으로 사용됩니다. 8 비트 및 16 비트 지원 소프트웨어 프로그래밍 가능 클록 주파수 및 최대 50MHz의 전송 속도 SPI 4 전송 모드 구성 지원 SPI 컨트롤러 당 하나의 칩 선택 만 지원 DTS 노드 구성 SPI 인터페이스 코드 Rockchip Thermal 개발 가이드 (3.10 코어) V1.0-20170220Linux 커널에는 열 프레임 워크 세트가 정의되어 있으며 3.10 커널의 arm64 버전에서는 열 프레임 워크의 sysfs 인터페이스를 사용하여 현재 온도를 읽습니다. 온도 제어 전략은 다음과 같은 맞춤형 방법입니다.  성능 전략 : 현재 온도가 목표 온도를 초과하고 CPU가 고정 주파수로 설정되며 특정 값이 칩 레벨 dtsi 파일에 구성됩니다.  일반 전략 : 현재 온도가 목표 온도를 초과하면 CPU가 해당 주파수를 낮추고 특정 값은 칩 레벨 dtsi 파일에 구성됩니다. Menuconfig 구성 DTS 구성 정책 구성 디버그 인터페이스 Rockchip Uart 개발 가이드 V1.0-20170220 DTS 노드 구성 Linux 직렬 포트 인쇄 끄기 인쇄 로그의 직렬 포트 변경 Rockchip U-Boot 개발 안내서 V3.8-20170214Rockchip U-Boot는 다음을 지원하는 오픈 소스 UBoot 2014.10 공식 버전을 기반으로합니다. 지원 칩 : RK3288, RK3036, RK312X, RK3368, RK322X, RK3366, RK3399, RK3328, RK322XH 등 Android 플랫폼의 펌웨어 시작을 지원합니다. 프로그램에 ROCKUSB 및 Google Fastboot 지원; 보안 부팅 펌웨어 서명 암호화 보호 메커니즘을 지원합니다. LVDS, EDP, MIPI, HDMI, CVBS와 같은 디스플레이 장치 지원; SDCard, Emmc, Nand Flash 및 U 디스크와 같은 저장 장치를 지원합니다. 부팅 로고 디스플레이, 충전 애니메이션 디스플레이, 저전력 관리, 전원 관리를 지원합니다. I2C, SPI, PMIC, CHARGE, GUAGE, USB, GPIO, PWM, DMA, GMAC, EMMC, NAND 인터럽트 및 기타 드라이버 지원; 플랫폼 아키텍처 지원 캐시 메커니즘 드라이버 지원 Google Fastboot 펌웨어 로딩 Boot_merger 도구 Resource_tool 도구 Trust_merger 도구 SDCard 및 U 디스크 부팅 업그레이드 Rockchip USB 개발 가이드 V1.0-20170220 하드웨어 회로 및 신호 커널 모듈 구성 DTS 드라이버 Android Gadget 구성 일반적인 문제 분석 Rockchip Vendor Storage Application Note Vendor storage 관련? u-boot, 리눅스등 api 설명 Rockchip 대량 생산 프로그래밍 안내서 V1.1-20170214솔루션 1 (USB 업그레이드 솔루션)1 단계 : update.img 업그레이드 펌웨어 만들기 2 단계 : 배치 레코딩에 FactoryTool 사용 옵션 2 (SD 업그레이드 계획)1 단계 : update.img 업그레이드 펌웨어 만들기 2 단계 : SD_Firmware_Tool 도구를 사용하여 펌웨어 업그레이드 SD 카드 만들기 3 단계 : 업그레이드 SD 카드를 넣고 다시 켠 다음 펌웨어 굽기를 수행합니다. 옵션 3 (작성자 업그레이드 계획)1 단계 : update.img 업그레이드 펌웨어 만들기 2 단계 : SpiImageTool 도구를 사용하여 버너 용 굽기 파일 만들기 3 단계 : 펌웨어 레코딩을 위해 메모리 칩이 프로그래머에 연결됩니다. Rockchip Media Center 사용 지침 _V1.0_20170222개요Media Center는 하나의 Box TV에 설치된 내부 저장소, SD 카드, U 디스크, 모바일 하드 디스크, Samba 저장소, NFS 저장소, DLNA 서비스 및 기타 장치 검색, 파일 탐색, 비디오 재생, 음악 재생, 사진 탐색, APK 모음입니다 신청. 이 애플리케이션은 RK 시리즈 칩 플랫폼과 호환되며 Android 4.4 이상을 지원합니다.-&gt; 어플리 케이션 관련 내용 Rockchip Clock 하위 모듈 개발 안내서 V1.1-20170220 Clock의 서브 모듈관련 dts API 디버깅 Rockchip_Android7.1_WiFi_ 구성 설명 V1.4 wifi, bt관련 자동호환이 가능하도록 설정 방법 제공 VR_ver3.0에 대한 스트레스 테스트 스트레스 테스트 문서 스트레스 테스트 관련","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform 개발 환경","slug":"Android/Platform-개발-환경","permalink":"http://jung-max.github.io/categories/Android/Platform-개발-환경/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"}]},{"title":"Device Tree 문법","slug":"Device_Tree_문법","date":"2019-10-22T02:41:00.000Z","updated":"2022-02-08T02:11:11.788Z","comments":true,"path":"2019/10/22/Device_Tree_문법/","link":"","permalink":"http://jung-max.github.io/2019/10/22/Device_Tree_문법/","excerpt":"","text":"Device Tree란 ?단적으로 표현하면, 일정한 형식(문법)을 갖춘 텍스트를 이용하여, hardware(SoC, Board)를 기술하는 것을 말함.이와 대비되는 기존의 방식으로 platform device 기반의 board 기술 방식(C coding)이 있었음. &lt;등장 배경 및 기존 방식의 문제점&gt; 1) SoC 혹은 board 별로 독자적인 code 구현 2) 같은 SoC에서 파생된 보드 간에 상호 연관성이 있음에도 불구하고, 이를 전혀 고려하지 않고, 별도로 구현함. 3) 따라서, 코드의 복잡도 및 코드량이 늘어는 문제 발생함. : arch/arm/mach-{YOURBOARD}/board-*.c 파일이 매우 복잡하고 난해함. : ARM linux 진영의 골칫거리. Linus Torvalds의 지적 ! 4) 보드 구성이 바뀌더라도 kernel code를 수정하지 않고, 동작할 수 있는 방식의 필요성 인식 5) Device Tree는 기존에 다른 쪽(CPU)에서 사용하던 방식으로 ARM에도 채용하게 됨. : 새로 나오는 보드로 개발을 진행하여, linux kernel에 자신의 코드를 반영하고자 한다면, 반드시 device tree 기반으로 작업이 이루어져야 함. Device Tree 소스 경로DTS의 소스(스크립트)는 커널의 arch/arm/boot/dts 또는 arch/arm64/boot/dts 경로에 있다. 소스 스크립트 파일은 아키텍쳐별로 구성되어있다. .dtsi 파일은 SOC 레벨에서 정의한 인클루드 파일이고, .dts파일은 보드 레벨에서 정의한 스크립트 파일이다. dts파일은 커널을 빌드할 때 Makefile 정보를 참조하여 생성된다. 커널 소스를 빌드할때는 menuconfig에서 아래 내용이 선택되었는지 확인한다. Boot options → Flattened Device Tree support 커널이 부팅한 이후에는 /proc/device-tree 경로에서 장치 설정 정보들을 확인할 수 있다. 기본 데이타 포멧장치 트리는 노드 및 속성의 간단한 트리 구조입니다. 속성은 키-값 쌍이며 노드에는 속성과 자식 노드가 모두 포함될 수 있습니다. 예를 들어 다음은 .dts 형식의 간단한 트리입니다. 1234567891011121314151617181920212223/dts-v1/;/ &#123; node1 &#123; a-string-property = \"A string\"; a-string-list-property = \"first string\", \"second string\"; // hex is implied in byte arrays. no '0x' prefix is required a-byte-data-property = [01 23 34 56]; child-node1 &#123; first-child-property; second-child-property = &lt;1&gt;; a-string-property = \"Hello, world\"; &#125;; child-node2 &#123; &#125;; &#125;; node2 &#123; an-empty-property; a-cell-property = &lt;1 2 3 4&gt;; /* each number (cell) is a uint32 */ child-node1 &#123; &#125;; &#125;;&#125;; 이 트리는 아무것도 설명하지 않기 때문에 사용할 수 없지만 노드와 속성의 구조를 보여줍니다. 단일 루트 노드 : “/“ 두 개의 자식 노드 : “node1“및 “node2“ node1에 대한 두 개의 하위 항목 : “child-node1“및 “child-node2“ 트리를 통해 흩어져있는 많은 속성. 속성은 값이 비어 있거나 임의의 바이트 스트림을 포함 할 수있는 간단한 키-값 쌍입니다. 데이터 유형은 데이터 구조로 인코딩되지 않지만 장치 트리 소스 파일로 표현할 수있는 몇 가지 기본 데이터 표현이 있습니다. 텍스트 문자열 (널로 종료 됨)은 큰 따옴표로 표시됩니다. string-property = &quot;a string&quot;; ‘셀’은 꺾쇠 괄호로 구분 된 32 비트 부호없는 정수입니다. cell-property = &lt;0xbeef 123 0xabcd1234&gt;; 이진 데이터는 대괄호로 구분됩니다. binary-property = [0x01 0x23 0x45 0x67]; 다른 표현의 데이터는 쉼표를 사용하여 함께 연결할 수 있습니다. mixed-property = &quot;a string&quot;, [0x01 0x23 0x45 0x67], &lt;0x12345678&gt;; 쉼표는 문자열 목록을 만드는 데에도 사용됩니다. string-list = &quot;red fish&quot;, &quot;blue fish&quot;; 기본 개념장치 트리가 어떻게 사용되는지 이해하기 위해 간단한 기계부터 시작하여 장치 트리를 단계별로 설명하는 장치 트리를 구축합니다. 샘플 머신“Acme”에서 제조하고 “Coyote ‘s Revenge”라는 이름의 다음과 같은 가상 머신 (ARM Versatile을 기반으로 함)을 고려하십시오. One 32bit ARM CPU processor local bus attached to memory mapped serial port, spi bus controller, i2c controller, interrupt controller, and external bus bridge 256MB of SDRAM based at 0 2 Serial ports based at 0x101F1000 and 0x101F2000 GPIO controller based at 0x101F3000 SPI controller based at 0x10170000 with following devices MMC slot with SS pin attached to GPIO #1 External bus bridge with following devices SMC SMC91111 Ethernet device attached to external bus based at 0x10100000 i2c controller based at 0x10160000 with following devices Maxim DS1338 real time clock. Responds to slave address 1101000 (0x58) 64MB of NOR flash based at 0x30000000 초기 구조첫 번째 단계는 기계의 골격 구조를 세우는 것입니다. 이것은 유효한 장치 트리에 필요한 최소한의 구조입니다. 이 단계에서는 머신을 고유하게 식별하려고합니다. 12345/dts-v1/;/ &#123; compatible = \"acme,coyotes-revenge\";&#125;; compatible은 시스템 이름을 지정합니다. 제조업체,모델 형식의 문자열이 포함되어 있습니다. 정확한 장치를 지정하고 제조업체 이름을 포함하여 네임 스페이스 충돌을 피하는 것이 중요합니다. 운영 체제는 compatible 값을 사용하여 방법에 대한 결정을 내릴 것이므로 머신에서 실행하려면이 compatible에 올바른 데이터를 입력해야합니다. 이론적으로는 OS가 머신을 고유하게 식별하는 데 필요한 모든 데이터가 호환됩니다. 모든 기계 세부 사항이 하드 코딩 된 경우 OS는 최상위 compatible 특성에서 “acme, coyotes-revenge”를 구체적으로 찾을 수 있습니다. CPUs다음 단계는 각 CPU에 대해 설명하는 것입니다. “cpus”라는 컨테이너 노드가 각 CPU의 자식 노드와 함께 추가됩니다. 이 경우 시스템은 ARM의 듀얼 코어 Cortex A9 시스템입니다. 1234567891011121314/dts-v1/;/ &#123; compatible = \"acme,coyotes-revenge\"; cpus &#123; cpu@0 &#123; compatible = \"arm,cortex-a9\"; &#125;; cpu@1 &#123; compatible = \"arm,cortex-a9\"; &#125;; &#125;;&#125;; 각 CPU 노드의 compatible 속성은 최상위 수준의 compatible 속성과 마찬가지로 manufacturer,model 형식으로 정확한 CPU 모델을 지정하는 문자열입니다. 나중에 더 많은 속성이 CPU 노드에 추가되지만 먼저 더 많은 기본 개념에 대해 이야기해야합니다. 노드 이름명명 규칙에 대해 잠시 이야기 할 가치가 있습니다. 모든 노드는 name@unit-address 형식의 이름을 가져야합니다. name은 간단한 ASCII 문자열이며 최대 31 자까지 가능합니다. 일반적으로 노드는 노드의 종류에 따라 이름이 지정됩니다. 즉. 3com 이더넷 어댑터의 노드는 3com509가 아닌 ethernet 이름을 사용합니다. 노드가 주소가있는 장치를 설명하는 경우 장치 주소가 포함됩니다. 일반적으로 장치 주소는 장치에 액세스하는 데 사용되는 기본 주소이며 노드의 reg 속성에 나열됩니다. 이 문서의 뒷부분에서 reg 속성을 다룰 것입니다. 형제 노드의 이름은 고유해야하지만 주소가 다른 경우 (예 : serial@101f1000 및 serial@101f2000) 둘 이상의 노드에서 동일한 일반 이름을 사용하는 것이 일반적입니다. unit-adress는 장치에 접근하기 위해 사용되는 1 차 주소이고, 노드 내의 reg 속성에 나열되어 있는 정보에 해당한다. unit address가 필요한 이유는 동일한 장치(예: uart)가 여럿 존재할 경우, 이를 구분해가 위해서임. 보통은 unit-adress는 노드의 reg 속성값으로 사용된 첫번째 주소값을 노드 이름의 장치 주소에 사용하도록 하고 있다. Devices시스템의 모든 장치는 장치 트리 노드로 표시됩니다. 다음 단계는 트리를 각 장치의 노드로 채우는 것입니다. 지금은 주소 범위와 irq를 처리하는 방법에 대해 이야기 할 때까지 새 노드가 비어 있습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/dts-v1/;/ &#123; compatible = \"acme,coyotes-revenge\"; cpus &#123; cpu@0 &#123; compatible = \"arm,cortex-a9\"; &#125;; cpu@1 &#123; compatible = \"arm,cortex-a9\"; &#125;; &#125;; serial@101F0000 &#123; compatible = \"arm,pl011\"; &#125;; serial@101F2000 &#123; compatible = \"arm,pl011\"; &#125;; gpio@101F3000 &#123; compatible = \"arm,pl061\"; &#125;; interrupt-controller@10140000 &#123; compatible = \"arm,pl190\"; &#125;; spi@10115000 &#123; compatible = \"arm,pl022\"; &#125;; external-bus &#123; ethernet@0,0 &#123; compatible = \"smc,smc91c111\"; &#125;; i2c@1,0 &#123; compatible = \"acme,a1234-i2c-bus\"; rtc@58 &#123; compatible = \"maxim,ds1338\"; &#125;; &#125;; flash@2,0 &#123; compatible = \"samsung,k8f1315ebm\", \"cfi-flash\"; &#125;; &#125;;&#125;; 이 트리에서 시스템의 각 장치에 노드가 추가되었으며 계층은 장치가 시스템에 연결되는 방식을 반영합니다. 즉. extern 버스의 장치는 외부 버스 노드의 하위이고 i2c 장치는 i2c 버스 컨트롤러 노드의 하위입니다. 일반적으로 계층은 CPU 관점에서 시스템의 관점을 나타냅니다. 이 트리는 현재 유효하지 않습니다. 장치 간 연결에 대한 정보가 없습니다. 해당 데이터는 나중에 추가됩니다. 이 트리에서주의해야 할 사항 : 모든 장치 노드에는 compatible 속성이 있습니다. compatible 속성에는 플래시 노드에 2 개의 문자열이 있습니다. 다음 섹션을 읽고 이유를 알아보십시오. 앞에서 언급했듯이 노드 이름은 특정 모델이 아닌 장치 유형을 반영합니다. compatible 속성 이해장치를 나타내는 트리의 모든 노드에는 compatible 속성이 있어야합니다. compatible은 운영 체제가 장치에 바인딩 할 장치 드라이버를 결정하는 데 사용하는 키입니다. compatible은 문자열 목록입니다. 목록의 첫 번째 문자열은 노드가 &lt;manufacturer&gt;, &lt;model&gt;형식으로 나타내는 정확한 장치를 지정합니다. 다음 문자열은 장치와 호환되는 다른 장치를 나타냅니다. 예를 들어, 프리 스케일 MPC8349 SoC (System on Chip)에는 National Semiconductor ns16550 레지스터 인터페이스를 구현하는 직렬 장치가 있습니다. 따라서 MPC8349 직렬 장치의 compatible 속성은 compatible = “fsl, mpc8349-uart”, “ns16550”이어야합니다. 이 경우 fsl, mpc8349-uart는 정확한 장치를 지정하고 ns16550은 내셔널 세미 컨덕터 16550 UART와 레지스터 수준 호환 가능함을 나타냅니다. 참고 : ns16550에는 역사적 이유로 순수한 제조업체 접두사가 없습니다. 호환되는 모든 새 값은 제조업체 접두사를 사용해야합니다. 이를 통해 기존 장치 드라이버를 최신 장치에 바인딩하면서도 정확한 하드웨어를 고유하게 식별 할 수 있습니다. 경고 : “fsl, mpc83xx-uart”와 같은 와일드 카드 compatible 값을 사용하지 마십시오. 실리콘 공급 업체는 변경하기에 너무 늦은 순간 와일드 카드 가정을 위반하는 변경 작업을 항상 수행합니다. 대신 특정 실리콘 구현을 선택하고 후속 실리콘을 모두 호환되도록하십시오. 주소 지정 방법주소를 지정할 수있는 장치는 다음 속성을 사용하여 주소 정보를 장치 트리로 인코딩합니다. reg #address-cells #size-cells 각 주소 지정 가능 장치는 reg = &lt;address1 length1 [address2 length2] [address3 length3] ...&gt; 형식의 튜플 목록 인 reg를 가져옵니다. 각 튜플은 장치에서 사용하는 주소 범위를 나타냅니다. 각 주소 값은 셀이라고하는 하나 이상의 32 비트 정수 목록입니다. 마찬가지로 길이 값은 셀 목록이거나 비어있을 수 있습니다. 주소 및 길이 필드는 가변 크기로 가변적이므로 부모 노드의 #address-cells 및 #size-cells 속성은 각 필드에 몇 개의 셀이 있는지를 나타내는 데 사용됩니다. 즉, reg 속성을 올바르게 해석하려면 부모 노드의 #address-cells 및 #size-cells 값이 필요합니다. #address-cells 속성과 #size-cells 속성은 reg속성의 데이터에 대한 갯수 규칙을 지정한다.#address-cells 속성과 #size-cells 속성은 부모 노드에서 지정하고 reg속성은 자식 노드에서 지정한다. reg는 주소와 길이가 셋트가 된다. 여기에는 몇가지 특징이 있다. 하나의 주소 또는 여러개의 주소를 가지고 있을 수 있다. 각 주소는 연속적일 수도 불연속 적일 수도 있다. 보통 reg의 셀들이 주소를 지정하기 위해서 몇개의 셀을 사용할지를 결정하고 길이를 지정하기 위해서 몇개의 셀들을 사용할지를 결정해 주는 것이 바로 #address-cells 속성과 #size-cells 속성이다. 32비트 시스템에서는 #address-cells 값이 1, #size-cells 값이 1이된다. 64비트 시스템에서는 #address-cells 값이 2, #size-cells 값이 2가된다. #address-cells : reg 속성값에 시작 주소를 지정하기 위해서 몇개의 셀을 사용할 것인가를 지정한다. #size-cells : reg 속성 값에 길이를 지정하기 위해서 몇개의 셀을 사용할 것인가를 지정한다. CPU addressingCPU 노드는 주소 지정에 관해 이야기 할 때 가장 간단한 경우를 나타냅니다. 각 CPU에는 고유 한 단일 ID가 할당되며 CPU ID와 연관된 크기가 없습니다. 123456789101112cpus &#123; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; cpu@0 &#123; compatible = \"arm,cortex-a9\"; reg = &lt;0&gt;; &#125;; cpu@1 &#123; compatible = \"arm,cortex-a9\"; reg = &lt;1&gt;; &#125;;&#125;; cpus 노드에서 #address-cells는 1로 설정되고 #size-cells는 0으로 설정됩니다. 이는 하위 reg 값이 크기 필드가없는 주소를 나타내는 단일 uint32임을 의미합니다. 이 경우 두 CPU에 주소 0과 1이 할당됩니다. 각 CPU에는 단일 주소 만 할당되므로 CPU 노드의 #size-cells는 0입니다. 또한 reg 값이 노드 이름의 값과 일치 함을 알 수 있습니다. 일반적으로 노드에 reg 속성이 있으면 노드 이름에 reg 속성의 첫 번째 주소 값인 단위 주소가 포함되어야합니다. 메모리 매핑 된 장치CPU 노드에서 발견되는 단일 주소 값 대신 메모리 매핑 된 장치에는 응답 할 주소 범위가 할당됩니다. #size-cells는 각 자식 정규 표현식에서 길이 필드의 크기를 나타내는 데 사용됩니다. 다음 예에서 각 주소 값은 1 셀 (32 비트)이고 각 길이 값은 1 셀이기도하며 이는 32 비트 시스템에서 일반적입니다. 64 비트 시스템은 장치 트리에서 64 비트 주소 지정을 얻기 위해 #address-cells 및 #size-cells에 2 값을 사용할 수 있습니다. 12345678910111213141516171819202122232425262728293031323334353637/dts-v1/;/ &#123; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; ... serial@101f0000 &#123; compatible = \"arm,pl011\"; reg = &lt;0x101f0000 0x1000 &gt;; &#125;; serial@101f2000 &#123; compatible = \"arm,pl011\"; reg = &lt;0x101f2000 0x1000 &gt;; &#125;; gpio@101f3000 &#123; compatible = \"arm,pl061\"; reg = &lt;0x101f3000 0x1000 0x101f4000 0x0010&gt;; &#125;; interrupt-controller@10140000 &#123; compatible = \"arm,pl190\"; reg = &lt;0x10140000 0x1000 &gt;; &#125;; spi@10115000 &#123; compatible = \"arm,pl022\"; reg = &lt;0x10115000 0x1000 &gt;; &#125;; ...&#125;; 각 장치에는 기본 주소가 할당되고 해당 영역의 크기가 할당됩니다. 이 예에서 GPIO 장치 주소에는 두 가지 주소 범위가 할당됩니다. 0x101f3000 … 0x101f3fff 및 0x101f4000..0x101f400f. 일부 장치는 다른 주소 지정 체계를 가진 버스에 있습니다. 예를 들어, 개별 칩 선택 라인이있는 외부 버스에 장치를 연결할 수 있습니다. 각 부모 노드는 자식 노드의 주소 지정 도메인을 정의하므로 시스템을 가장 잘 설명하기 위해 주소 매핑을 선택할 수 있습니다. 아래 코드는 칩 선택 번호가 주소로 인코딩 된 외부 버스에 연결된 장치의 주소 할당을 보여줍니다. 12345678910111213141516171819202122external-bus &#123; #address-cells = &lt;2&gt;; #size-cells = &lt;1&gt;; ethernet@0,0 &#123; compatible = \"smc,smc91c111\"; reg = &lt;0 0 0x1000&gt;; &#125;; i2c@1,0 &#123; compatible = \"acme,a1234-i2c-bus\"; reg = &lt;1 0 0x1000&gt;; rtc@58 &#123; compatible = \"maxim,ds1338\"; &#125;; &#125;; flash@2,0 &#123; compatible = \"samsung,k8f1315ebm\", \"cfi-flash\"; reg = &lt;2 0 0x4000000&gt;; &#125;;&#125;; external-bus는 주소 값으로 2 개의 셀을 사용합니다. 하나는 칩 선택 번호를위한 것이고 다른 하나는 칩 선택의베이스로부터 오프셋을위한 것입니다. 주소의 오프셋 부분 만 범위를 가져야하므로 길이 필드는 단일 셀로 유지됩니다. 따라서이 예에서 각 reg 항목은 chipselect 번호, 오프셋 및 길이의 3개의 셀을 포함합니다. 주소 도메인은 노드와 그 자식에 포함되므로 부모 노드는 버스에 적합한 주소 지정 체계를 자유롭게 정의 할 수 있습니다. 직계 상위 및 하위 노드 외부의 노드는 일반적으로 로컬 주소 지정 도메인을 신경 쓸 필요가 없으며 한 도메인에서 다른 도메인으로 이동하기 위해 주소를 매핑해야합니다. 비 메모리 매핑 된 장치다른 장치는 프로세서 버스에서 메모리 매핑되지 않습니다. 주소 범위를 가질 수 있지만 CPU에서 직접 액세스 할 수는 없습니다. 대신 상위 장치의 드라이버가 CPU 대신 간접 액세스를 수행합니다. i2c 장치의 예를 들기 위해 각 장치에는 주소가 할당되지만 그와 관련된 길이나 범위는 없습니다. 이것은 CPU 주소 할당과 거의 같습니다. 12345678910i2c@1,0 &#123; compatible = \"acme,a1234-i2c-bus\"; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; reg = &lt;1 0 0x1000&gt;; rtc@58 &#123; compatible = \"maxim,ds1338\"; reg = &lt;58&gt;; &#125;;&#125;; Ranges (주소 번환)장치에 주소를 할당하는 방법에 대해 이야기했지만이 시점에서 해당 주소는 장치 노드에만 로컬입니다. 이 주소에서 CPU가 사용할 수있는 주소로 매핑하는 방법은 아직 설명하지 않았습니다. 루트 노드는 항상 주소 공간에 대한 CPU의 관점을 설명합니다. 루트의 자식 노드는 이미 CPU의 주소 도메인을 사용하고 있으므로 명시적인 매핑이 필요하지 않습니다. 예를 들어, serial@101f0000 장치에는 주소 0x101f0000이 직접 할당됩니다. 루트의 직계 자식이 아닌 노드는 CPU의 주소 도메인을 사용하지 않습니다. 메모리 매핑 된 주소를 얻으려면 장치 트리에서 한 도메인에서 다른 도메인으로 주소를 변환하는 방법을 지정해야합니다. ranges 속성은이 목적으로 사용됩니다. 다음은 ranges 속성이 추가 된 샘플 장치 트리입니다. 123456789101112131415161718192021222324252627282930313233343536/dts-v1/;/ &#123; compatible = \"acme,coyotes-revenge\"; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; ... external-bus &#123; #address-cells = &lt;2&gt; #size-cells = &lt;1&gt;; ranges = &lt;0 0 0x10100000 0x10000 // Chipselect 1, Ethernet 1 0 0x10160000 0x10000 // Chipselect 2, i2c controller 2 0 0x30000000 0x1000000&gt;; // Chipselect 3, NOR Flash ethernet@0,0 &#123; compatible = \"smc,smc91c111\"; reg = &lt;0 0 0x1000&gt;; &#125;; i2c@1,0 &#123; compatible = \"acme,a1234-i2c-bus\"; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; reg = &lt;1 0 0x1000&gt;; rtc@58 &#123; compatible = \"maxim,ds1338\"; reg = &lt;58&gt;; &#125;; &#125;; flash@2,0 &#123; compatible = \"samsung,k8f1315ebm\", \"cfi-flash\"; reg = &lt;2 0 0x4000000&gt;; &#125;; &#125;;&#125;; ranges는 주소 변환 목록입니다. ranges 테이블의 각 항목은 자식 주소, 부모 주소 및 자식 주소 공간의 영역 크기를 포함하는 튜플입니다. 각 필드의 크기는 자녀의 #address-cells 값, 부모의 #address-cells 값 및 자녀의 #size-cells 값을 사용하여 결정됩니다. ranges 속성의 값은 다음과 같은 형식으로 표현됩니다. 1234ranges = &lt;자식주소1 부모주소1 자식주소크기1 자식주소2 부모주소2 자식주소크기2 자식주소3 부모주소3 자식주소크기3 자식주소4 부모주소4 자식주소크기4&gt;; 이 예에서 external-bus의 경우 자식 주소는 2 셀이고 부모 주소는 1 셀이며 크기도 1 셀입니다. ranges = &lt;0 0 0x10100000 0x10000 // Chipselect 1, Ethernet 여기서 0 0은 자식 주소 정보이고, 0x10100000은 부모 즉 CPU 입장에서 로컬 버스 주소가 됩니다. 0x10000은 자식 주소의 크기가 됩니다. 칩 선택 0의 오프셋 0은 주소 범위 0x10100000..0x1010ffff에 매핑됩니다. 칩 선택 1의 오프셋 0은 주소 범위 0x10160000..0x1016ffff에 매핑됩니다. 칩 선택 2의 오프셋 0은 주소 범위 0x30000000..0x30ffffff에 매핑됩니다. 또는 부모와 자식 주소 공간이 동일한 경우 노드가 대신 빈 범위 속성을 추가 할 수 있습니다. 빈 범위 속성이 있으면 자식 주소 공간의 주소가 부모 주소 공간에 1 : 1로 매핑됩니다. 주소 변환이 모두 1 : 1 매핑으로 작성 될 수있을 때 왜 주소 변환이 사용되는지 묻습니다. PCI와 같은 일부 버스는 운영 체제에 세부 정보를 노출해야하는 주소 공간이 완전히 다릅니다. 다른 것들은 버스의 실제 주소를 알아야하는 DMA 엔진을 가지고 있습니다. 장치가 모두 동일한 소프트웨어 프로그래밍 가능 물리적 주소 매핑을 공유하기 때문에 장치를 그룹화해야하는 경우가 있습니다. 1 : 1 매핑 사용 여부는 운영 체제에 필요한 정보와 하드웨어 설계에 따라 다릅니다. 또한 i2c@1,0 노드에는 범위 특성이 없습니다. 이는 외부 버스와 달리 i2c 버스의 장치가 CPU의 주소 도메인에 메모리 매핑되지 않기 때문입니다. 대신, CPU는 i2c@1,0 장치를 통해 rtc@58 장치에 간접적으로 액세스합니다. ranges 속성이 없다는 것은 부모가 아닌 다른 장치에서 장치에 직접 액세스 할 수 없음을 의미합니다. 인터럽트 작동 방식트리의 자연스러운 구조를 따르는 주소 범위 변환과 달리 인터럽트 신호는 시스템의 모든 장치에서 시작되고 종료 될 수 있습니다. 장치 트리에서 자연스럽게 표현되는 장치 주소 지정과 달리 인터럽트 신호는 트리와 무관 한 노드 간 링크로 표시됩니다. 보통 인터럽트는 디바이스의 하드웨어가 인터럽트를 발생하고 인터럽트 컨트롤러가 해당 신호를 수신하는 구조로 되어있습니다. 그래서 인터럽트는 디바이스 트리의 구조와 별도로 디바이스 노드간에 링크 구조로 표현됩니다. 인터럽트는 디바이스 노드의 속성 형태로 표현됩니다. 인터럽트 연결을 설명하기 위해 네 가지 속성이 사용됩니다. interrupt-controller - 인터럽트 신호를 수신하는 장치로 노드를 선언하는 빈 속성 #interrupt-cells - 인터럽트 컨트롤러 노드의 속성입니다. 이 인터럽트 컨트롤러의 인터럽트 지정자에 몇 개의 셀이 있는지를 나타냅니다 (#address-cell 및 #size-cell과 유사). interrupt-parent - 연결된 인터럽트 컨트롤러에 대한 팬들을 포함하는 장치 노드의 속성. interrupt-parent 속성이없는 노드는 부모 노드에서 속성을 상속 할 수도 있습니다. interrupts - 디바이스의 각 인터럽트 출력 신호마다 하나씩 인터럽트 지정자 목록을 포함하는 디바이스 노드의 특성입니다. 인터럽트 지정자는 디바이스가 연결된 인터럽트 입력을 지정하는 하나 이상의 데이터 셀 (#interrupt-cells로 지정)입니다. 아래 예와 같이 대부분의 장치에는 단일 인터럽트 출력 만 있지만 장치에 여러 개의 인터럽트 출력이있을 수 있습니다. 인터럽트 지정자의 의미는 전적으로 인터럽트 컨트롤러 장치의 바인딩에 달려 있습니다. 각 인터럽트 컨트롤러는 인터럽트 입력을 고유하게 정의하는 데 필요한 셀 수를 결정할 수 있습니다. 다음 코드는 Coyote’s revenge 샘플 장치에 인터럽트 연결을 추가합니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/dts-v1/;/ &#123; compatible = \"acme,coyotes-revenge\"; #address-cells = &lt;1&gt;; #size-cells = &lt;1&gt;; interrupt-parent = &lt;&amp;intc&gt;; cpus &#123; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; cpu@0 &#123; compatible = \"arm,cortex-a9\"; reg = &lt;0&gt;; &#125;; cpu@1 &#123; compatible = \"arm,cortex-a9\"; reg = &lt;1&gt;; &#125;; &#125;; serial@101f0000 &#123; compatible = \"arm,pl011\"; reg = &lt;0x101f0000 0x1000 &gt;; interrupts = &lt; 1 0 &gt;; &#125;; serial@101f2000 &#123; compatible = \"arm,pl011\"; reg = &lt;0x101f2000 0x1000 &gt;; interrupts = &lt; 2 0 &gt;; &#125;; gpio@101f3000 &#123; compatible = \"arm,pl061\"; reg = &lt;0x101f3000 0x1000 0x101f4000 0x0010&gt;; interrupts = &lt; 3 0 &gt;; &#125;; intc: interrupt-controller@10140000 &#123; compatible = \"arm,pl190\"; reg = &lt;0x10140000 0x1000 &gt;; interrupt-controller; #interrupt-cells = &lt;2&gt;; &#125;; spi@10115000 &#123; compatible = \"arm,pl022\"; reg = &lt;0x10115000 0x1000 &gt;; interrupts = &lt; 4 0 &gt;; &#125;; external-bus &#123; #address-cells = &lt;2&gt; #size-cells = &lt;1&gt;; ranges = &lt;0 0 0x10100000 0x10000 // Chipselect 1, Ethernet 1 0 0x10160000 0x10000 // Chipselect 2, i2c controller 2 0 0x30000000 0x1000000&gt;; // Chipselect 3, NOR Flash ethernet@0,0 &#123; compatible = \"smc,smc91c111\"; reg = &lt;0 0 0x1000&gt;; interrupts = &lt; 5 2 &gt;; &#125;; i2c@1,0 &#123; compatible = \"acme,a1234-i2c-bus\"; #address-cells = &lt;1&gt;; #size-cells = &lt;0&gt;; reg = &lt;1 0 0x1000&gt;; interrupts = &lt; 6 2 &gt;; rtc@58 &#123; compatible = \"maxim,ds1338\"; reg = &lt;58&gt;; interrupts = &lt; 7 3 &gt;; &#125;; &#125;; flash@2,0 &#123; compatible = \"samsung,k8f1315ebm\", \"cfi-flash\"; reg = &lt;2 0 0x4000000&gt;; &#125;; &#125;;&#125;; 이 기계에는 단일 인터럽트 컨트롤러 인 interrupt-controller@10140000이 있습니다. intc레이블이 인터럽트 컨트롤러 노드에 추가되었으며이 레이블을 사용하여 루트 노드의 인터럽트 상위 속성에 phandle을 할당했습니다. 이 인터럽트 상위 값은 명시 적으로 재정의되지 않는 한 모든 하위 노드가이를 상속하므로 시스템의 기본값이됩니다. 각 장치는 인터럽트 속성을 사용하여 다른 인터럽트 입력 라인을 지정합니다. #interrupt-cells는 2이므로 각 인터럽트 지정자는 2 개의 셀을 갖습니다. 이 예제는 인터럽트 라인 번호를 인코딩하기 위해 첫 번째 셀을 사용하고 액티브 하이 대 액티브 로우 또는 에지 대 레벨 민감도와 같은 플래그를 인코딩하기 위해 두 번째 셀을 사용하는 일반적인 패턴을 사용합니다. 지정된 인터럽트 컨트롤러에 대해서는 컨트롤러 바인딩 문서를 참조하여 지정자가 인코딩되는 방법을 배우십시오. 사용자 추가 데이터공통 속성 외에도 임의의 속성과 자식 노드를 노드에 추가 할 수 있습니다. 일부 규칙을 따르는 한 운영 체제에 필요한 모든 데이터를 추가 할 수 있습니다. 먼저, 새로운 장치 별 속성 이름은 기존 표준 속성 이름과 충돌하지 않도록 제조 접두사를 사용해야합니다. 둘째, 디바이스 드라이버 작성자가 데이터를 해석하는 방법을 알 수 있도록 특성 및 하위 노드의 의미를 바인딩으로 문서화해야합니다. 바인딩은 특정 호환 가능한 값의 의미, 보유해야 할 속성, 보유 할 자식 노드 및 해당 장치를 나타내는 문서를 문서화합니다. 각각의 고유 한 compatible 속성에는 고유 한 바인딩이 있어야합니다 (또는 다른 compatible 속성과의 호환성을 주장해야 함). 셋째, devicetree-discuss@lists.ozlabs.org 메일 링리스트에 검토 할 새 바인딩을 게시하십시오. 새로운 바인딩을 검토하면 나중에 문제를 일으킬 수있는 일반적인 실수가 많이 발생합니다. 특수 노드aliases Node특정 노드는 일반적으로 /external-bus/ethernet@0,0과 같은 전체 경로로 참조되지만 사용자가 실제로 알고 싶은 것이 “어떤 장치가 eth0입니까?” 별칭 노드를 사용하여 전체 장치 경로에 짧은 별칭을 할당 할 수 있습니다. 예를 들면 다음과 같습니다. 1234aliases &#123; ethernet0 = &amp;eth0; serial0 = &amp;serial0;&#125;; 운영 체제는 식별자를 장치에 할당 할 때 별칭을 사용할 수 있습니다. 여기에 새로운 구문이 사용됩니다. property = &amp;label; 구문은 레이블이 참조하는 전체 노드 경로를 문자열 특성으로 지정합니다. 이것은 phandle = &lt;&amp;label&gt;;과 다릅니다. phandle 값을 셀에 삽입하는 이전에 사용 된 양식입니다. chosen Nodechosen 노드는 실제 장치를 나타내지 않지만 부팅 인수와 같이 펌웨어와 운영 체제간에 데이터를 전달하는 장소 역할을합니다. 선택한 노드의 데이터가 하드웨어를 나타내지 않습니다. 일반적으로 선택한 노드는 .dts 소스 파일에서 비어 있으며 부팅시 채워집니다. 예제 시스템에서 펌웨어는 선택한 노드에 다음을 추가 할 수 있습니다. 123chosen &#123; bootargs = \"root=/dev/nfs rw nfsroot=192.168.1.1 console=ttyS0,115200\";&#125;; 고급 주제고급 샘플 머신기본 사항이 정의되었으므로 샘플 머신에 몇 가지 하드웨어를 추가하여 좀 더 복잡한 사용 사례를 논의 해 보겠습니다. 고급 샘플 머신은 제어 레지스터 메모리가 0x10180000에 매핑되고 BAR이 주소 0x80000000 이상에서 시작하도록 프로그래밍 된 PCI 호스트 브리지를 추가합니다. 장치 트리에 대해 이미 알고있는 것을 감안할 때 다음 호스트를 추가하여 PCI 호스트 브리지를 설명 할 수 있습니다. 12345pci@10180000 &#123; compatible = \"arm,versatile-pci-hostbridge\", \"pci\"; reg = &lt;0x10180000 0x1000&gt;; interrupts = &lt;8 0&gt;;&#125;; 위의 예제를 보면 PCI 호스트 브릿지는 제어를 위한 주소가 reg 속성으로 0x10180000 번지로 부터 크기는 0x1000 범위입니다. 이 번지영역을 이용 호스트 브릿지를 제어하게 됩니다. 이 호스트 브릿지는 시스템 인터럽트에 8번 인터럽트를 통해 처리하게 됩니다. PCI Host Bridge이 섹션에서는 호스트 / PCI 브리지 노드에 대해 설명합니다. 이 섹션에서는 PCI에 대한 기본 지식이 있다고 가정합니다. peripheral component interconnect의 약어.개인용 컴퓨터(PC)의 중앙 처리 장치(CPU)와 주변 장치를 연결하는 ISA나 EISA, VESA의 후속으로 개발된 로컬 버스 규격. PCI 버스 또는 PCI 로컬 버스로 널리 알려져 있으며, 이 규격의 PCI 슬롯이 대부분의 펜티엄 PC에 장착되어 있다. PCI 버스는 주소를 전달하는 신호와 데이터를 전달하는 신호를 시분할 다중화(TDM)하여 전송하기 때문에 신호선의 수가 적고, 32비트 또는 64비트 버스로서 접속 가능한 장치의 수는 10개가 권장되고 있다. PCI 버스는 CPU와 버스 사이에 브리지 회로를 두는 구조이기 때문에 VESA 로컬 버스와는 달리 CPU의 종류가 달라도 그에 대응하는 브리지 회로를 갖추기만 하면 어떤 CPU와도 연결할 수 있다. 또한 CPU와는 독자적으로 PCI 확장 카드가 작업을 동시 처리하는 버스 마스터링을 지원하므로 데이터 전송 속도가 서로 다른 여러 주변 장치가 접속되었을 때 동화(動畵) 등의 멀티미디어 데이터를 우선적으로 처리할 수 있게 한다.[네이버 지식백과] PCI [peripheral component interconnect] (IT용어사전, 한국정보통신기술협회) PCI Bus numbering각 PCI 버스 세그먼트는 고유하게 번호가 지정되며 버스 번호는 두 개의 셀이 포함 된 버스 범위 특성을 사용하여 pci 노드에 노출됩니다. 첫 번째 셀은이 노드에 할당 된 버스 번호를 제공하고 두 번째 셀은 모든 하위 PCI 버스의 최대 버스 번호를 제공합니다. 샘플 시스템에는 단일 PCI 버스가 있으므로 두 셀이 모두 0입니다. 123456pci@0x10180000 &#123; compatible = \"arm,versatile-pci-hostbridge\", \"pci\"; reg = &lt;0x10180000 0x1000&gt;; interrupts = &lt;8 0&gt;; bus-range = &lt;0 0&gt;;&#125;; PCI Address Translation앞에서 설명한 로컬 버스와 유사하게 PCI 주소 공간은 CPU 주소 공간과 완전히 분리되어 있으므로 PCI 주소에서 CPU 주소로 가져 오려면 주소 변환이 필요합니다. 항상 그렇듯이 range, #address-cells 및 #size-cells 속성을 사용하여 수행됩니다. 123456789101112pci@0x10180000 &#123; compatible = \"arm,versatile-pci-hostbridge\", \"pci\"; reg = &lt;0x10180000 0x1000&gt;; interrupts = &lt;8 0&gt;; bus-range = &lt;0 0&gt; #address-cells = &lt;3&gt; #size-cells = &lt;2&gt;; ranges = &lt;0x42000000 0 0x80000000 0x80000000 0 0x20000000 0x02000000 0 0xa0000000 0xa0000000 0 0x10000000 0x01000000 0 0x00000000 0xb0000000 0 0x01000000&gt;;&#125;; 보다시피, 자식 주소 (PCI 주소)는 3 개의 셀을 사용하며 PCI 범위는 2 개의 셀로 인코딩됩니다. 첫 번째 질문은 PCI 주소를 지정하기 위해 3 개의 32 비트 셀이 필요한 이유 일 수 있습니다. 세 개의 셀에는 phys.hi, phys.mid 및 phys.low라는 레이블이 붙어 있습니다. phys.hi cell: npt000ss bbbbbbbb dddddfff rrrrrrrr phys.mid cell: hhhhhhhh hhhhhhhh hhhhhhhh hhhhhhhh phys.low cell: llllllll llllllll llllllll llllllll PCI 주소는 64 비트이며 phys.mid 및 phys.low로 인코딩됩니다. 그러나 실제로 흥미로운 것은 phys.high에 있으며 약간의 필드입니다. n : 재배치 가능 지역 플래그 (여기서 역할을 수행하지 않음, 0이면 재배치 가능, 1이면 불가능) p : 프리 페치 가능 (캐시 가능, 1이면 가능, 0이면 불가능) 리젼 플래그 t : aliased 주소 플래그 (여기에서 역할을 수행하지 않음) ss : 공간 코드 00 : 구성 공간 01 : I / O 공간 10:32 비트 메모리 공간 11:64 비트 메모리 공간 bbbbbbbb : PCI 버스 번호. PCI는 계층 적으로 구성 될 수 있습니다. 따라서 서브 버스를 정의 할 PCI / PCI 브리지가있을 수 있습니다. ddddd : 일반적으로 IDSEL 신호 연결과 관련된 장치 번호입니다. fff : 기능 번호. 다기능 PCI 장치에 사용됩니다. rrrrrrrr : 등록 번호; 구성주기에 사용됩니다. PCI 주소 변환을 위해 중요한 필드는 p와 ss입니다. phys.hi의 p와 ss 값은 액세스 할 PCI 주소 공간을 결정합니다. 따라서 ranges 속성을 살펴보면 다음과 같은 세 가지 영역이 있습니다. 호스트 CPU의 주소 0x80000000에 매핑 될 512MB 크기의 PCI 주소 0x80000000에서 시작하는 32 비트 프리 페치 가능 메모리 영역 호스트 CPU의 주소 0xa0000000에 매핑 될 256MB 크기의 PCI 주소 0xa0000000에서 시작하는 32 비트 프리 페치 불가능 메모리 영역 호스트 CPU의 주소 0xb0000000에 매핑 될 16MB 크기의 PCI 주소 0x00000000에서 시작하는 I / O 영역 렌치를 작업 물에 던지려면 phys.hi 비트 필드가 있음은 운영 체제가 노드가 PCI 브리지를 나타내므로 변환을 위해 관련없는 필드를 무시할 수 있음을 알아야합니다. OS는 추가 필드를 마스킹해야하는지 여부를 결정하기 위해 PCI 버스 노드에서 “pci”문자열을 찾습니다. PCI DMA Address Translation위의 범위는 CPU가 PCI 메모리를 보는 방법을 정의하고 CPU가 올바른 메모리 창을 설정하고 다양한 PCI 장치 레지스터에 올바른 매개 변수를 쓰도록 도와줍니다. 이것을 때때로 아웃 바운드 메모리라고합니다. 특별한 주소 변환 사례는 PCI 호스트 하드웨어가 시스템의 핵심 메모리를 보는 방법과 관련이 있습니다. 이는 PCI 호스트 컨트롤러가 마스터 역할을하고 시스템의 코어 메모리에 독립적으로 액세스 할 때 발생합니다. 이것은 종종 메모리 라인이 연결된 방식으로 인해 CPU와 다른 관점이므로 초기화시 PCI 호스트 컨트롤러에 프로그래밍해야 할 수도 있습니다. 이는 PCI 버스가 독립적으로 직접 메모리 액세스를 수행하기 때문에 일종의 DMA로 간주되며, 이러한 이유로 매핑 이름은 dma-ranges입니다. 이 유형의 메모리 매핑은 때때로 인바운드 메모리라고도하며 PCI 장치 트리 사양의 일부가 아닙니다. 경우에 따라 ROM (BIOS) 또는 이와 유사한 장치가 부팅시 이러한 레지스터를 설정하지만 다른 경우에는 PCI 컨트롤러가 완전히 초기화되지 않았으며 이러한 변환은 장치 트리에서 설정해야합니다. 그런 다음 PCI 호스트 드라이버는 일반적으로 dma-ranges 속성을 구문 분석하고 이에 따라 호스트 컨트롤러에 일부 레지스터를 설정합니다. 위 예제에서 확장 : 12345678910111213pci@0x10180000 &#123; compatible = \"arm,versatile-pci-hostbridge\", \"pci\"; reg = &lt;0x10180000 0x1000&gt;; interrupts = &lt;8 0&gt;; bus-range = &lt;0 0&gt; #address-cells = &lt;3&gt; #size-cells = &lt;2&gt;; ranges = &lt;0x42000000 0 0x80000000 0x80000000 0 0x20000000 0x02000000 0 0xa0000000 0xa0000000 0 0x10000000 0x01000000 0 0x00000000 0xb0000000 0 0x01000000 dma-ranges = &lt;0x02000000 0 0x00000000 0x80000000 0 0x20000000&gt;;&#125;; 이 dma 범위 항목은 PCI 호스트 컨트롤러의 관점에서 PCI 주소 0x00000000의 512MB가 주소 0x80000000의 기본 코어 메모리에 나타납니다. 보시다시피 ss 주소 유형을 0x02로 설정하여 32 비트 메모리임을 나타냅니다. Advanced Interrupt Mapping이제 가장 흥미로운 부분 인 PCI 인터럽트 매핑에 대해 살펴 보겠습니다. PCI 장치는 와이어 #INTA, #INTB, #INTC 및 #INTD를 사용하여 인터럽트를 트리거 할 수 있습니다. 인터럽트 이름 앞에있는 # 해시 기호는 활성이 낮음을 의미하며 이는 일반적인 규칙이며 PCI 인터럽트 라인은 항상 활성이 낮습니다. 단일 기능 장치는 인터럽트에 #INTA를 사용해야합니다. 다기능 장치는 단일 인터럽트 핀을 사용하는 경우 #INTA를 사용해야하고, 두 개의 인터럽트 핀을 사용하는 경우 #INTA 및 #INTB를 사용해야합니다. 이러한 규칙으로 인해 #INTA는 일반적으로 #INTB, #INTC보다 많은 기능에서 사용됩니다. #INTD. #INTA를 통해 #INTD를 지원하는 4 개의 IRQ 라인에 부하를 분산시키기 위해 각 PCI 슬롯 또는 장치는 일반적으로 모든 #INTA 클라이언트가 동일한 수신 인터럽트 라인에 연결되지 않도록하기 위해 인터럽트 컨트롤러의 다른 입력에 회전 방식으로 연결됩니다. 이 절차를 인터럽트 스위 즐링이라고합니다. 따라서 장치 트리에는 각 PCI 인터럽트 신호를 인터럽트 컨트롤러의 입력에 매핑하는 방법이 필요합니다. #interrupt-cells, interrupt-map 및 interrupt-map-mask 속성은 인터럽트 매핑을 설명하는 데 사용됩니다. 실제로 여기에 설명 된 인터럽트 매핑은 PCI 버스로 제한되지 않으며 모든 노드가 복잡한 인터럽트 맵을 지정할 수 있지만 PCI 사례가 가장 일반적입니다. 1234567891011121314151617181920212223pci@0x10180000 &#123; compatible = \"arm,versatile-pci-hostbridge\", \"pci\"; reg = &lt;0x10180000 0x1000&gt;; interrupts = &lt;8 0&gt;; bus-range = &lt;0 0&gt; #address-cells = &lt;3&gt; #size-cells = &lt;2&gt;; ranges = &lt;0x42000000 0 0x80000000 0x80000000 0 0x20000000 0x02000000 0 0xa0000000 0xa0000000 0 0x10000000 0x01000000 0 0x00000000 0xb0000000 0 0x01000000&gt; #interrupt-cells = &lt;1&gt;; interrupt-map-mask = &lt;0xf800 0 0 7&gt;; interrupt-map = &lt;0xc000 0 0 1 &amp;intc 9 3 // 1st slot 0xc000 0 0 2 &amp;intc 10 3 0xc000 0 0 3 &amp;intc 11 3 0xc000 0 0 4 &amp;intc 12 3 0xc800 0 0 1 &amp;intc 10 3 // 2nd slot 0xc800 0 0 2 &amp;intc 11 3 0xc800 0 0 3 &amp;intc 12 3 0xc800 0 0 4 &amp;intc 9 3&gt;;&#125;; 먼저 2 개의 셀을 사용하는 시스템 인터럽트 컨트롤러와 달리 PCI 인터럽트 번호는 하나의 셀만 사용한다는 것을 알 수 있습니다. 하나는 irq 번호이고 다른 하나는 플래그입니다. PCI 인터럽트는 항상 레벨이 낮도록 지정되므로 PCI는 인터럽트에 하나의 셀만 필요합니다. 예제 보드에는 각각 4 개의 인터럽트 라인이있는 2 개의 PCI 슬롯이 있으므로 8 개의 인터럽트 라인을 인터럽트 컨트롤러에 매핑해야합니다. 이것은 인터럽트 맵 속성을 사용하여 수행됩니다. interrupt-map의 표현 방식은 아래와 같습니다. interrupt-map = &lt; 자식_인터럽트_정보1 부모_인터럽트_컨트롤러_정보1 부모_인터럽트_정보1 자식_인터럽트_정보2 부모_인터럽트_컨트롤러_정보2 부모_인터럽트_정보2 자식_인터럽트_정보3 부모_인터럽트_컨트롤러_정보3 부모_인터럽트_정보3 … &gt;; 위에서 정의한 interrupt-map = &lt;0xc000 0 0 1 &amp;intc 9 3을 살펴보면 0xc000 0 0 1 : 자식_인터럽트_정보1 &amp;intc : 부모_인터럽트_컨트롤러_정보1 9 3 : 부모_인터럽트_정보1 여기서 자식_인터럽트_정보1을 살펴보면 여기서 설정이 #address-cells = &lt;3&gt;, #interrupt-cells = &lt;1&gt;;로 설정되어 있는 걸 볼 수 있습니다. #interrupt-cells로 표현되는 것은 자식 인터럽트의 번호를 의미합니다. 보통 PCI 디바이스 하드웨어의 인터럽트 번호는 0이 아닌 1로 시작됩니다. #interrupt-cells가 2가 아닌 1인 이유는 PCI 인터럽트의 검출은 항상 로우 레벨일 경우만 검출되는 것으로 규정되어 있기 때문입니다. 부모_인터럽트_컨트롤러_정보1은 initc를 참조하게 되어있습니다.전의 예제를 살펴보면 123456intc: interrupt-controller@10140000 &#123; compatible = \"arm,pl190\"; reg = &lt;0x10140000 0x1000 &gt;; interrupt-controller; #interrupt-cells = &lt;2&gt;;&#125;; #interrupt-cells = &lt;2&gt;; 부모의 #interrupt-cells는 2로 설정되어있는 것을 확인할 수 있습니다.부모_인터럽트_정보1를 보면 9 3 두개의 셀로 되어있습니다. 이것의 의미는 인터럽트 번호가 9번이고 PCI의 인터럽트 검출 레벨은 항상 로우 액티브이므로 이것에 대한 표현 값으로 3을 지정하고 있습니다. 위 예제는 interrupt-map의 주석을 보면 알 수 있듯이 4개의 인터럽트를 가지는 2개의 PCI 슬롯을 가지고 있음을 알 수 있다. 그래서 8개의 인터럽트 라인을 인터럽트 콘트롤러에 매핑해야한다. 인터럽트 번호 (#INTA 등)는 단일 PCI 버스의 여러 PCI 장치를 구별하기에 충분하지 않기 때문에 어떤 PCI 장치가 인터럽트 라인을 트리거 했는지도 표시해야합니다. 다행히도 모든 PCI 장치에는 사용할 수있는 고유 한 장치 번호가 있습니다. 여러 PCI 장치의 인터럽트를 구별하려면 PCI 장치 번호와 PCI 인터럽트 번호로 구성된 튜플이 필요합니다. 보다 일반적으로 말하면, 우리는 4 개의 셀을 가진 단위 인터럽트 지정자를 구성합니다. phys.hi, phys.mid, phys.low로 구성하기 위해서 #address-cells을 3으로 설정 하나의 #interrupt-cell (#INTA, #INTB, #INTC, #INTD 중 하나를 지정하기 위해서). PCI 주소의 장치 번호 부분 만 필요하기 때문에 인터럽트 맵 마스크 속성이 작동합니다. 인터럽트 맵 마스크는 또한 유닛 인터럽트 지정자와 같은 4 튜플입니다. 마스크의 1은 단위 인터럽트 지정자의 어느 부분을 고려해야하는지 나타냅니다. 이 예에서는 phys.hi의 장치 번호 부분 만 필요하며 4 개의 인터럽트 라인을 구분하기 위해 3 비트가 필요하다는 것을 알 수 있습니다 (카운팅 PCI 인터럽트 라인은 0이 아닌 1에서 시작합니다!). 앞에 보았던 phys.hi cell: npt000ss bbbbbbbb dddddfff rrrrrrrr의 ddddd : 일반적으로 IDSEL 신호 연결과 관련된 장치 번호입니다. 부분을 mask하기 위해서 interrupt-map-mask를 0xf800 0 0로 설정합니다.7은 인터럽트 번호를 추출하기 위한 비트 마스크 값이 된다. 이 마스크 값을 가지고 AND 논리연산을 합니다. 이제 인터럽트 맵 속성을 구성 할 수 있습니다. 이 특성은 테이블이며이 테이블의 각 항목은 하위 (PCI 버스) 단위 인터럽트 지정자, 상위 핸들 (인터럽트를 담당하는 인터럽트 제어기) 및 상위 단위 인터럽트 지정자로 구성됩니다. 따라서 첫 번째 줄에서 PCI 인터럽트 #INTA가 IRQ 9, 인터럽트 컨트롤러의 레벨에 민감한 IRQ 9에 매핑되어 있음을 알 수 있습니다. 현재 유일하게 누락 된 부분은 PCI 버스 장치 인터럽트 지정자에서 이상한 숫자입니다. 장치 인터럽트 지정자의 중요한 부분은 phys.hi 비트 필드의 장치 번호입니다. 장치 번호는 보드마다 다르며 각 PCI 호스트 컨트롤러가 각 장치에서 IDSEL 핀을 활성화하는 방법에 따라 다릅니다. 이 예에서 PCI 슬롯 1에는 장치 ID 24 (0x18)가 할당되고 PCI 슬롯 2에는 장치 ID 25 (0x19)가 할당됩니다. 각 슬롯에 대한 phys.hi 값은 다음과 같이 장치 번호를 11 비트 씩 비트 필드의 ddddd 섹션으로 이동하여 결정됩니다. 슬롯 1의 phys.hi는 0xC000이며 슬롯 2의 phys.hi는 0xC800입니다. 인터럽트 맵 속성 쇼를 모두 합하면 다음과 같습니다. 슬롯 1의 #INTA는 IRQ9이며 1 차 인터럽트 컨트롤러에서 로우 레벨일때 인식됩니다. 슬롯 1의 #INTB는 IRQ10이며 1 차 인터럽트 컨트롤러에서 로우 레벨일때 인식됩니다. 슬롯 1의 #INTC는 IRQ11이며 1 차 인터럽트 컨트롤러에서 로우 레벨일때 인식됩니다. 슬롯 1의 #INTD는 IRQ12이며 1 차 인터럽트 컨트롤러에서 로우 레벨일때 인식됩니다. 슬롯 2의 #INTA는 IRQ10이며 기본 인터럽트 컨트롤러에서 로우 레벨일때 인식됩니다. 슬롯 2의 #INTB는 IRQ11이며 1 차 인터럽트 컨트롤러에서 로우 레벨일때 인식됩니다. 슬롯 2의 #INTC는 IRQ12이며 1 차 인터럽트 컨트롤러에서 로우 레벨일때 인식됩니다. 슬롯 2의 #INTD는 IRQ9이며 1 차 인터럽트 컨트롤러에서 로우 레벨일때 인식됩니다. interrupts = &lt;8 0&gt;; 속성은 호스트 / PCI 브리지 컨트롤러 자체가 트리거 할 수있는 인터럽트를 설명합니다. 이러한 인터럽트를 PCI 장치가 트리거 할 수있는 인터럽트 (INTA, INTB 등을 사용하여)와 혼용하지 마십시오. 마지막으로 유의해야 할 사항입니다. 인터럽트 상위 속성과 마찬가지로 노드에 인터럽트 맵 속성이 있으면 모든 자식 및 손자 노드에 대한 기본 인터럽트 컨트롤러가 변경됩니다. 이 PCI 예에서 이는 PCI 호스트 브리지가 기본 인터럽트 컨트롤러가됨을 의미합니다. PCI 버스를 통해 연결된 장치가 다른 인터럽트 컨트롤러에 직접 연결되어있는 경우 자체 인터럽트 상위 속성도 지정해야합니다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Kernel","slug":"Android/Platform-Kernel","permalink":"http://jung-max.github.io/categories/Android/Platform-Kernel/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"DTS","slug":"DTS","permalink":"http://jung-max.github.io/tags/DTS/"},{"name":"Device Tree","slug":"Device-Tree","permalink":"http://jung-max.github.io/tags/Device-Tree/"}]},{"title":"오픈소스 라이센스 소개","slug":"오픈소스라이센스","date":"2019-10-21T07:39:28.000Z","updated":"2022-02-08T02:11:11.833Z","comments":true,"path":"2019/10/21/오픈소스라이센스/","link":"","permalink":"http://jung-max.github.io/2019/10/21/오픈소스라이센스/","excerpt":"","text":"해당 게시물은 한국저작권위원회가 발행한 오픈소스 소프트웨어 라이선스 가이드 3.0을 참고해서 작성되었습니다. 소프트웨어 지적 재산권저작권(copyright)창작물에 대하여 창작자(저작자)가 취득하는 권리로서 창작의 결과물을 보호하며, 창작과 동시에 권리가 발생한다. 따라서 어떤 프로그래머가 소프트웨어를 개발하면 저작권이 자동으로 발생하며, 그 권리는 프로그래머 또는 그가 속한 회사에 부여된다. 저작권이 있는 저작물은 저작권자의 허락이 없이는 누구도 해당 저작물을 복제, 배포, 수정할 수 없다. 특허권(patent)특허권(patent)은 발명에 관하여 발명자(특허권자)가 갖는 독점배타권이다. 저작권과는달리 일정한 방식으로 출원해야 하며, 심사를 통과한 후 등록되어야만 권리가 발생한다. 특허기술을 사용하기 위해서는 반드시 특허권자의 허락을 얻어야만 한다. 특허받은방식을 구현하는 소프트웨어라면 프로그래밍 언어에 상관없이 특허권의 범위에 속한다. 공개되지 않은 소스코드는 영업비밀로서 보호를 받을 수 있다. 하지만 영업비밀은 일단공개되면 더 이상 보호받기 어렵고, 또한 영업비밀을 알지 못하고 사용한 제3자에게법적으로 문제를 삼을 수 없다는 한계가 있다. 오픈소스 라이선스일반 상용 소프트웨어와 마찬가지로 오픈소스에도 저작권 등 지적재산권이 있다. 그래서 권리자의 허락 없이 함부로 사용하면 소송을 당할 수 있다. 그런데 오픈소스의 권리자들은 되도록 많은 사람이 자유롭게 사용할 수 있도록 광범위한 라이선스를 부여하고 있다. 예를 들어 사용자들에게 사용에 대한 권리뿐만 아니라 마음대로 복제 및 배포를 할 수 있도록 하고, 소스코드까지 제공하여 마음대로 수정할 수 있도록 허락한다.하지만 상용 소프트웨어처럼 그에 따르는 로열티를 요구하지는 않으며, 대신 몇 가지 지켜야 할 의무사항을 요구한다. 구체적인 예를 통해 몇 가지 의무사항을 살펴보기로 하자. 저작권, 개발자 및 기여자 정보의 표시대부분의 오픈소스 라이선스는 개발자 또는 기여자에 관한 사항과 저작권에 관한 사항을 제품에 표시하거나 포함하도록 요구하고 있다. 마치 저작인격권의 하나인 성명표시권과 유사하다. 코드를 수정한 경우 수정한 정보의 표시이용자가 소스코드를 수정하였을 때에는 수정한 사람, 수정 일자 등 수정에 관한 내용을 포함하도록 함으로써, 원본과 구별할 수 있도록 한다. 저작인격권의 하나인 동일성유지권에 비유할 수 있다. 라이선스 정보의 제공많은 오픈소스 라이선스들은 이용자들이 오픈소스에 관한 권리를 잘 이해할 수 있도록 배포자가 해당 라이선스의 사본을 함께 첨부할 것을 요구하고 있다. 동일한 라이선스로 재배포할 것 (카피레프트)라이선스에 따라 큰 차이를 보이는 부분은 ‘카피레프트(Copyleft)’에 관한 사항이다. GPL을 대표로 하는 카피레프트 라이선스들은 이용자들이 소프트웨어를 수정한 후 배포하고자 할 때 수정된 소프트웨어도 동일한 라이선스로 배포할 것을 요구한다. 카피레프트(Copyleft)라는 용어는 원래 저작권(Copyright)에 반대한다는 의미로 “Copy-right”에서 “right” 대신 “left”로 바꾸어 사용하기 시작한 것이다. 그런데, FSF가 말하는 “소프트웨어의 자유”를 지키기 위한 구체적인 수단이 GPL이며, 그 중에서도 핵심적인 내용은 파생저작물을 GPL로 재배포할 것을 요구하는 조항이기 때문에, 보통 이 조항을 가리켜 카피레프트 조항이라고 부르고 있다. 소스코드의 제공카피레프트 조항을 포함하는 라이선스의 경우, 소프트웨어를 배포할 때 소스코드까지 함께 배포하도록 요구한다. 라이선스의 특징 및 의무사항 BSD Apache2.0 GPL 2.0 GPL 3.0 LGPL 2.1 MPL CDDL CPL/ EPL 복제·배포·수정의 권한 부여 O O O O O O O O 배포시 라이선스 사본 첨부 O O O O O O O 저작권고지사항 또는 Attribution 고지사항 유지 O O O O O O O O 배포시 소스코드 제공 의무(Reciprocity)와 범위 derivative work work based on the program derivative work file file module 조합저작물(Larger Work)작성 및 타 라이선스 배포 허용 O O O O O O 수정시 수정내용 고지 O O O O O O O 명시적 특허라이선스의 부여 O O O O O 라이선시가 특허소송 제기시 라이선스 종료 O O O O O 복이름, 상표, 상호에 대한 사용제한 O O O O O 보증의 부인 O O O O O O O O 책임의 제한 O O O O O O O O 주요 오픈소스 라이선스BSD형 라이선스 및 주요 프로젝트BSD형 라이선스에는 BSD, MIT, Apache 라이선스 등이 포함되며, 비교적 오랜 역사를 가진 라이선스들이다. 이들 라이선스는 카피레프트(Copyleft) 조항을 포함하지 않으며, 의무사항도 비교적 간단하다. BSD 라이선스BSD 라이선스는 버클리 대학에서 만든 라이선스로, 소프트웨어를 재배포할 때 저작권 표시를 할 것과 준수 조건 및 보증부인에 대한 고지사항을 소스코드 또는 문서 및 기타자료에 포함할 것을 요구하고 있다. 4개의 조항으로 구성된 BSD 4-Clause 라이선스 (Original BSD 혹은 Old BSD 라고도 불림)에는 “광고 조항”이 포함되어 있다.이는 파생저작물의 모든 홍보물에 “This product includes software developed by the ” 문구를 포함해야 하는데, 이는 문제 소지가 있는 조항으로 판단되어 1999년 7월 이를 삭제한 BSD 3-Clause 라이선스(Modified BSD 혹은 New BSD 라고도 불림)가 만들어졌다. Apache 라이선스Apache 라이선스는 아파치소프트웨어재단(Apache Software Foundation)에서 만들어 배포한 라이선스이다. 1.0과 1.1 버전은 BSD와 비슷하게 간단한 내용만을 담고 있었지만, 현재 사용되고 있는 2.0 버전은 2004년에 배포된 것으로 비교적 상세한 내용을 담고 있다. 배포 시의 의무사항으로는 저작권, 특허, 상표, 권리귀속(attribution)에 대한 고지사항을 소스코드 또는 “NOTICE” 파일 등에 포함할 것과, 수취인에게 라이선스 사본을 제공하도록 요구하고 있으며, 파일을 수정하여 배포할 경우 수정된 파일에 대해 수정사항을 표시한 안내 문구를 첨부할 것을 요구하고 있다. 하지만 카피레프트 조항을 포함하고 있지 않기 때문에 반드시 동일한 라이선스로 배포할 필요는 없으며, 소스코드 제공 의무도 없다는 점에서 기본적으로 BSD 라이선스와 비슷한 것으로 평가할 수 있다. MIT LicenseMIT 라이선스(MIT License)는 미국 매사추세츠 공과대학교(MIT)에서 해당 대학의 소프트웨어 공학도들을 돕기 위해 개발한 라이선스다. MIT 라이선스를 따르는 소프트웨어를 개조한 제품을 반드시 오픈 소스로 배포해야 한다는 규정이 없으며 GNU 일반 공중 라이선스의 엄격함을 피하려는 사용자들에게 인기가 있다. The MIT License MIT 라이선스 Copyright (c) Copyright (c) &lt;연도&gt; &lt;저작권자&gt; Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: 이 소프트웨어의 복제본과 관련된 문서화 파일(“소프트웨어”)을 획득하는 사람은 누구라도 소프트웨어를 별다른 제한 없이 무상으로 사용할 수 있는 권한을 부여 받는다. 여기에는 소프트웨어의 복제본을 무제한으로 사용, 복제, 수정, 병합, 공표, 배포, 서브라이선스 설정 및 판매할 수 있는 권리와 이상의 행위를 소프트웨어를 제공받은 다른 수취인들에게 허용할 수 있는 권리가 포함되며, 다음과 같은 조건을 충족시키는 것을 전제로 한다. The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. 위와 같은 저작권 안내 문구와 본 허용 문구가 소프트웨어의 모든 복제본 및 중요 부분에 포함되어야 한다. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF ERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 이 소프트웨어는 상품성, 특정 목적 적합성, 그리고 비침해에 대한 보증을 포함한 어떠한 형태의 보증도 명시적이나 묵시적으로 설정되지 않은 “있는 그대로의” 상태로 제공된다. 소프트웨어를 개발한 프로그래머나 저작권자는 어떠한 경우에도 소프트웨어나 소프트웨어의 사용 등의 행위와 관련하여 일어나는 어떤 요구사항이나 손해 및 기타 책임에 대해 계약상, 불법행위 또는 기타 이유로 인한 책임을 지지 않는다. 안드로이드 플랫폼아파치 서버 등 아파치재단의 프로젝트들뿐만 아니라, (2008년 조사결과) Source Forge.net의 5,000개 이상의 프로젝트가 Apache 라이선스로 배포되고 있다.또한, 2008년 5월 구글은 블로그를 통해 Google Code의 100,000여개 프로젝트 중 25%가 Apache 라이선스를 사용하고 있다고 발표했었다. 최근 Apache 라이선스로 배포되는 가장 큰 프로젝트는 안드로이드 플랫폼이다.커널과 애플리케이션을 제외한 안드로이드 플랫폼의 많은 부분은 Apache 라이선스로 배포되고있다. 하지만 일부 구성요소들은 CPL, EPL, GPL, LGPL 등으로 배포되고 있으며, 이들은 Apache 라이선스가 아닌 각각의 라이선스 규칙을 따라야 한다는 점을 주의할 필요가 있다. 12345678910111213141516171819202122232425262728293031APACHE2 bionic/linkerAPACHE2 dalvikAPACHE2 dalvik/libcore-disabled/instrumentAPACHE2 dalvik/libcore-disabled/soundAPACHE2 dalvik/libcore/annotationAPACHE2 dalvik/libcore/archiveAPACHE2 dalvik/libcore/authAPACHE2 dalvik/libcore/awt-kernelAPACHE2 dalvik/libcore/cryptoAPACHE2 dalvik/libcore/dalvikAPACHE2 dalvik/libcore/loggingAPACHE2 dalvik/libcore/luniAPACHE2 dalvik/libcore/luni-kernelAPACHE2 dalvik/libcore/math…CPL dalvik/libcore/junitEPL prebuilt/common/eclipseEPL prebuilt/common/osgiEPL prebuilt/darwin-x86/swt...GPL external/blktraceGPL external/e2fsprogsGPL external/e2fsprogs/e2fsck...LGPL external/e2fsprogs/lib/blkidLGPL external/e2fsprogs/lib/e2p...MIT external/e2fsprogs/lib/ssOSL1 external/elfutilsW3C dalvik/libcore/xml 안드로이드 애플리케이션의 라이선스 이슈미들웨어가 Apache 라이선스로 배포되는 경우 애플리케이션의 라이선스에는 영향을 미치지 않는다. 그 결과 애플리케이션의 개발자들은 자유롭게 라이선스를 결정할 수 있다. 유료의 상용 라이선스를 선택하는 것도 물론 가능하다. 구글이 안드로이드 플랫폼에 대한 라이선스를 GPL이 아닌 Apache 라이선스로 결정한 것은 더욱 많은 개발자들의 참여를 끌어내기 위해서이다. 스마트폰의 경쟁력은 얼마나 많은 애플리케이션을 확보하고 있는가에 달려 있다. 구글의 입장에서는 GPL로 대변되는 오픈소스의 정신을 존중하는 것도 중요했지만, 개발자들에게 라이선스를 선택할 수 있는 자유를 주어 보다 많은 애플리케이션이 개발될 수 있도록 하는 것이 더 중요했다고 볼 수 있다. 그런데 애플리케이션에 따라서는 기존의 오픈소스를 기반으로 개발되는 것도 있다. 이러한 경우 해당하는 오픈소스 라이선스를 지켜야 하는 것은 물론이다. 예를 들어 GPL로 배포되는 오픈소스를 기반으로 안드로이드 애플리케이션을 개발하는 경우 GPL에 따라 소스코드를 제공해 주어야 한다. 앱스토어(안드로이드 마켓)를 통해 직접 소스코드를 제공하는 것은 어려우므로 애플리케이션의 일정 부분에 소스코드를 제공한다는 안내를하고 다른 웹서버를 통해 소스코드를 제공하는 방법을 고려할 수 있다. 이러한 사항을 지키지 않는 경우 라이선스 위반에 해당하여 소송을 당할 수 있다. 이러한 경우 애플리케이션 개발자가 책임을 지는 것과는 별도로, 앱스토어 운영사도 라이선스 위반에 대한 책임이 있는가? 이 문제는 이용자의 저작권 침해에 대해 네이버 등 서비스제공자도 책임을 져야 하는가의 문제와 유사하다. 서비스유형에 따라 다른 판결이 나오고 있지만, 권리자가 권리침해가 있다는 통지를 해오는 경우 서비스제공자는 즉시 관련 저작물을 삭제하는 것으로 대응하고 있다. GPL형 라이선스GPL형 라이선스에는 GPL 2.0, GPL 3.0, LGPL 2.1, LGPL 3.0, AGPL 3.0 등이 포함되며, 대부분 FSF(Free Software Foundation)에서 주도하여 만든 것이다. 비교적 오랜 역사를 가진다는 점에서 BSD와 비슷하지만, 카피레프트 조항과 소스코드 제공 의무를 가지고 있다는 점에서 큰 차이가 있다. 카피레프트의 적용 범위 및 소스코드 제공 의무의 범위는 GPL, LGPL, AGPL 각각에 차이가 있다. GPL 2.0GPL 2.0으로 배포되는 오픈소스는 i) 각 복제본에 적절한 저작권 표시와 보증책임이 없음을 명시하고, ii) GPL 라이선스를 언급하는 고지사항과 보증책임 관련 고지사항을 원본 그대로 유지하고, iii) 소프트웨어를 양도받는 모든 이들에게 소프트웨어와 함께 GPL 라이선스 사본을 제공하고, iv) 파일을 수정한 경우 수정했다는 사실과 날짜를 파일에 명기해야 한다. 그리고 v) 원본저작물과 파생저작물(derivative work)을 GPL 2.0에 의해 배포해야 하며, vi) 원본저작물 및 파생저작물에 대한 소스코드를 제공하거나, 요청 시 제공하겠다는 약정서를 제공해야 한다. 여기서 i) ~ iv)의 의무사항은 Apache 라이선스와 동일하거나 유사한 내용이지만, v) 및 vi)의 의무사항은 BSD형의 라이선스에서는 찾아볼 수 없는 내용이다. &lt;참고&gt; 파생저작물의 범위에 관한 해석오픈소스 현장에서는 GPL 2.0에서 언급하고 있는 파생저작물(derivative work)의 범위가 어디까지인지에 관해 논란이 많다. 일반적으로 계약이나 법 조항이 명확하지 않은 경우 당사자의 의도나 거래 관행 등을 종합적으로 고려하여 법원에서 결정하게 된다. GPL도 명확하지 않은 부분이 많으며, 최종적으로는 법원에서 가려지겠지만, GPL을 만든 FSF에서는 GPL의 해석에 도움을 주고자 많은 FAQ를 제공하고 있다. 예를 들면, GPL로 배포된 소프트웨어를 수정하였거나 새로운 소프트웨어에 정적 링크시키는 경우, 즉 두 개의 모듈이 동일한 실행 파일에 포함되어 있을 경우는 해당 실행 파일에 포함된 모든 소스는 GPL이 적용된다 또한, 동일한 바이너리에 포함되지 않더라도 동적 링크 등의 방식으로 공유주소영역에서 링크되어 실행되도록 설계된 경우, 플러그인이 동적으로 링크되어 함수를 호출하고 데이터구조를 공유하는 경우에도 GPL 소프트웨어와 함께 링크되어 실행되는 소프트웨어에도 GPL이 적용되어 소스코드를 제공해야 한다. 반면, 두 개의 프로그램이 파이프(pipes), 소켓(sockets), command-line arguments형태로 통신하는 경우, 플러그인이 fork나 exec을 이용하는 경우 등은 별도의 저작물로서 GPL이 적용되지 않는다고 답변하고 있다. GPL 3.0GPL 3.0은 GPL 2.0이 배포되고 난 이후 오픈소스 환경을 둘러싼 다양한 변화들을 수용하여 만든 라이선스이다. GPL 3.0의 의무사항으로는 i) 각 복제본에 저작권 고지와 보증책임이 없음을 명시할 것, ii) GPL 3.0의 조건 및 제7조의 조건에 관한 내용을 있는 그대로 유지할 것, iii) 소프트웨어를 양도받는 모든 이들에게 소프트웨어와 함께 GPL 라이선스 사본을 제공할 것, iv) 소프트웨어를 수정했을 경우 수정사실 및 일시를 명시할 것, v) 원본저작물과 그에 기반한 저작물(Work based on the program)을 GPL 3.0에 의해 배포할 것, vi) 원본저작물 및 그에 기반한 저작물(Work based on the program)에 대한 소스코드를 제공하거나, 요청 시 제공하겠다는 약정서를 제공할 것, vii) 사용자 제품(user product)에 대한 인증키 등 설치정보(installation information)를 제공할 것, viii) 차별적인 특허라이선스 계약을 체결하지 말 것 등의 내용이 포함되어 있다. i) ~ vi) 의 내용은 GPL 2.0의 내용과 같거나 내용을 더욱 명확히 하는 것이었지만, vii) 및 viii)의 내용은 GPL 3.0에 처음으로 포함된 내용으로 많은 논란을 불러일으켰다. LGPLLGPL은 주로 라이브러리에 사용하기 위해 FSF가 GPL과는 별도로 만든 라이선스이다. 라이브러리에 GPL 라이선스를 적용하게 되면 응용프로그램까지 GPL로 배포해야 하므로 사용자는 해당 라이브러리의 사용을 꺼리게 된다. FSF는 GPL의 내용을 약간 수정하여 라이브러리 자체를 수정한 경우에는 카피레프트 조항을 적용하지만, 해당 라이브러리를 이용한 응용프로그램은 카피레프트 조항을 적용하지 않고 소스코드 제공 의무도 없는 형태로 LGPL 라이선스를 만들었다. LGPL의 의무사항은 i) 각 복제본에 적절한 저작권 안내와 보증책임이 없음을 명시할 것, ii) LGPL 라이선스를 언급하는 안내 사항과 보증책임 관련 고지사항을 원본 그대로 유지할 것, iii) 소프트웨어를 양도받는 모든 이들에게 소프트웨어와 함께 LGPL 라이선스 사본을 제공할 것, iv) 라이브러리 형태로의 수정을 허용하며, 만약 수정한 경우 수정사실과 날짜를 파일에 명기할 것, iv) 원본저작물과 파생저작물을 LGPL 또는 GPL에 의해 배포할 것, v) 원본저작물 및 파생저작물에 대한 소스코드를 제공하거나, 요청 시 제공하겠다는 약정서를 제공할 것, vi) 응용프로그램을 배포할 경우, LGPL 라이브러리를 사용하고 있다는 사실을 명시할 것, vii) 사용자가 라이브러리를 수정해도 응용프로그램을 사용할 수 있도록 (예를 들어 응용프로그램의 오브젝트 코드를 제공하거나, 해당 라이브러리의 형태를 공유 라이브러리 방식 등을 이용하여) 허용할 것 등이다. i) ~ v)의 내용은 GPL 2.0과 동일하거나 유사하지만, vi) ~ vii)은 LGPL에 특유한 내용이다. Affero GPLBSD, Apache, GPL, LGPL, MPL, EPL 등 대다수의 오픈소스 라이선스들은 해당 소프트웨어를 복제하여 ‘배포(distribute)’할 때 지켜야 하는 다양한 요구사항들을 규정하고 있다. 이를 반대로 해석하면 해당 소프트웨어를 배포하지 않고 기업이 해당 오픈소스를 내부적으로만 사용하거나 네트워크 서버 형태로 이용하고 있는 경우에는 라이선스에 따른 의무사항들이 거의 없다는 점이다. 오픈소스 라이선스의 이러한 한계에 대해 비판적인 견해를 가지고 있던 Affero 프로젝트는 기존의 GPL 라이선스를 변경하여 네트워크 서버에 의해 서비스를 제공하는 경우에도 카피레프트 조항과 소스코드 제공 의무가 적용되도록 하였다. Affero GPL의 의무사항은 GPL과 기본적으로 동일하다. 다만, 그 적용의 범위가 단순한 ‘배포’를 넘어서 네트워크 서버 형태로 소프트웨어를 이용하는 경우에도 적용된다는 점에 차이가 있다. GPL Exceptions여러 오픈소스 프로젝트들은 해당 프로젝트는 GPL로 배포되길 바라면서 이를 활용하여 동작하는 프로그램들은 GPL의 copyleft 조항에서 자유로울 수 있도록, GPL 2.0의 2조를 다소 완화한 조건으로 배포할 수 있도록 허락해주는 exception을 추가하기도 한다. 이는 추가적인 제한 사항을 주는 것이 아니므로 GPL과도 호환된다. Bison ExceptionBison은 GNU 파서 생성기로, 정의된 문법을 처리하고 해석하여 C 코드로 만들어주는 도구다. Bison의 주요 결과물(Bison parser implementation file)은 상당 부분 Bison의 소스코드를 그대로 복사하여 skeleton 코드를 포함하게 된다. 일반적인 GPL이라면 이 skeleton 코드에도 GPL이 적용되어야 하고, 이에 따라 bison 결과물인 C 파일과 이를사용하는 프로그램 모두 GPL이 적용되어, 사용자들이 bison 사용을 부담스러워할 수 있다. 이에 Bison에 예외 조항을 추가하여 Bison이 생성하는 소스코드에 대해서는 GPL 적용이 되지 않도록 예외를 추가하였다. Classpath exceptionGNU Classpath 프로젝트는 자바 언어의 가상머신 및 컴파일러에서 사용되는 핵심 클래스 라이브러리를 자유 소프트웨어로 대체하기 위한 프로젝트이다. 이를 널리 사용할 수 있도록, GNU Classpath 등 Classpath exception이 적용된 수정하지 않은 core class library를 link하여 생성한 program은 GPL의 영향을 받지 않는다. 예를 들면, OpenJDK 프로젝트에서 가상머신 자체는 GPL 2.0으로 배포하고, Class library와 가상머신 내의 Public API로 노출되는 부분은 Classpath exception으로 배포하고 있다. Autoconf exceptionGNU Autoconf는 M4 매크로의 확장 패키지로, 소스코드 패키지들의 환경을 설정하는 쉘 스크립트를 자동으로 생성한다. Autoconf는 GPL로 배포되며, configure.ac의 시스템 정보를 입력받아, Autoconf의 일부분과 결합, configure 스크립트를 생성한다. 이에 해당 configure 내에 autoconf의 일부가 포함될 수밖에 없음에도 해당 configure는GPL의 파생저작물이 되지 않도록 예외를 적용해주는 것이 autoconf exception이다. GCC Runtime Library Exception (GCC RLE)GCC는 GNU 대표적인 컴파일러로, 이 Exception의 목적은 non-GPL 소스코드를 GCC로 컴파일할 때, GCC Runtime Library (header file 포함)가 Program에 포함되는 것을 허용하기 위한 것이다. 이 Exception에 의하면, “정당한 Compile 과정 (Eligible Compilation Process)” 중 Independent Module과 GCC Runtime Library가 결합하여 형성된 Target Code라면, 이는 GPL에 상관없이 다른 라이선스로 배포될 수 있다. GCC Runtime Library는 libgcc, libstdc++, libfortran, libgomp, libdecnumber 등이 있다. 만약 GCC Runtime Library가 정당한 컴파일 과정에 의해서가 아닌, 다른 방법으로 Program에 포함된 경우에는 GPL 의무사항을 모두 준수해야 한다. MPL형 라이선스MPL 형 라이선스는 주로 기업들이 주도하는 오픈소스 프로젝트에서 사용하는 라이선스로 MPL, CDDL, EPL 등이 포함된다. BSD형과 GPL형의 라이선스와는 달리, 처음부터 법률가들이 참여하여 만들었기 때문에 소프트웨어 라이선스의 관점에서는 더욱 정교하다고 볼 수 있지만, 프로그래머들에게는 그만큼 복잡하고 이해하기 어려운 라이선스들이다. 카피레프트 조항을 포함하고 있다는 점에서 GPL형과 비슷하지만, 적용 범위와 소스코드 제공범위는 GPL보다는 LGPL에 가까운 것으로 볼 수 있다. MPLMPL은 1998년 넷스케이프사가 자사의 브라우저를 오픈소스로 배포하면서 만든 라이선스이다. MPL로 배포되는 오픈소스를 이용하기 위해서는 i) 원 코드에 포함된 저작권표시, 개발자 및 권리자에 관한 사항들을 그대로 표시할 것과, ii) 배포 시 MPL 라이선스 사본을 첨부할 것, iii) 수정했을 경우에는 최초개발자의 코드로부터 파생되었다는 사실, 수정사항 및 날짜 등을 포함한 파일(Exhibit A)을 소스코드의 각 파일에 포함할 것, iv) 원본 및 수정코드를 MPL에 의해 배포할 것과, v) 수정코드에 대한 소스코드를 전자배포방식 등을 통해 제공할 것, vi) MPL 코드를 사용할 때 제3자의 지식재산권에 의한 라이선스가 필요하다는 사실을 알고 있는 경우 “LEGAL” 파일에 관련 내용을 포함할 것 등이다. MPL 2.0은 MPL 1.1에 비해 더욱 짧고 이해하기 쉽게 만든 라이선스이다. 특히 Apache License 2.0과 양립할 수 있게 되었으며 특허 관련 조항들이 정비되었다. 또한 MPL 2.0에서 Secondary License로 정의한 라이선스인 GPL 2.0, LGPL 2.1, AGPL 3.0과 각각 이후 버전들과 양립할 수 있게 된 것이 큰 변화이다. CDDLCDDL은 썬(sun)이 자사의 유닉스 운영체제인 솔라리스를 오픈소스로 배포하면서 만든 라이선스이다. MPL을 참조하여 만들었기 때문에 MPL의 내용과 비슷하다. i) 저작권 등 권리관련 사항, 라이선스 관련 사항 등의 고지사항을 제거하거나 변경할 수 없으며, ii) 배포 시 CDDL 라이선스 사본을 첨부해야 하며, iii) 수정한 경우 수정코드의 기여자임을 밝혀야 한다. iv) 원본 및 수정코드를 CDDL에 의해 배포해야 하며, v) 수정코드에 대한 소스코드를 합리적인 방식으로 제공해야 한다. CPL, EPLCPL과 EPL은 IBM이 이클립스(Eclipse) 등 오픈소스 프로젝트를 진행하면서 만든 라이선스이다. CPL과 EPL은 특허보복조항에 관한 사항에서만 차이가 있고 다른 내용은 모두 동일하다. IBM은 현재 EPL만 사용하고 있다. EPL로 배포되는 소프트웨어를 배포할 때 지켜야 할 의무사항으로는 i) 각 코드의 저작권 고지사항을 제거하거나 변경하지 말 것과, ii) EPL 라이선스 사본을 포함할 것과, iii) 각 기여물의 창작자를 식별할 수 있도록 신분을 밝힐 것과, iv) 오브젝트코드로 배포하는 경우 EPL 조건을 준수하고, 보증부인 및 책임배제에 관한 내용과 소스코드의 확보방법을 알려 줄 것, v) 소스코드로 배포하는 경우 EPL 라이선스를 적용할 것과, vi) 상업적 배포의 경우 기여자에게 책임이 발생하지 않도록 조치할 것 등의 내용을 포함하고 있다. 상담 사례R을 이용한 상용 소프트웨어의 개발Q: 저희가 개발하는 S/W의 기능 추가를 위해 GPL 2.0을 따르는 오픈소스를 사용하는 데있어서 문제가 없는지 문의합니다. R : 통계용 Open Source S/W (GPL 2.0) qpcR : 저희가 추가하려는 기능의 핵심 모듈이 들어있는 패키지로 R이 기본적으로 설치되어 있어야 함. R(D)-COM Interface : 저희가 개발하려는 S/W와 R 간의 Interface를 위한 S/W 위의 세 가지 모두 소스코드는 수정하지 않을 것이며, 아래와 같은 구조로 사용하려고 합니다. 위와 같이 사용하려고 할 때, 라이선스 관련 위배 사항이 없는 지 궁금하며, 위배 사항이 있을 경우 어느 정도까지 소스 공개가 되어야 하는 지 궁금합니다. A: R(D)-COM은 별도의 라이선스 정책을 적용하고 있지는 않지만, 이미 GPL이 적용된 R과의 결합 정도에 따라 GPL 적용 여부가 결정될 것으로 판단됩니다. GPL FAQ에 의하면 결합 정도에 따른 GPL 적용 범위의 구분 기준을 제시하고 있습니다. 예를 들어, 프로그램의 플러그인이 동적 링크로 실행되는 경우 메인 프로그램이 확장된 경우에 해당하여 GPL 적용 범위에 포함되지만, fork나 exec을 사용하는 경우에는 별도의 프로그램에 해당하여 포함되지 않습니다. 또는 두 개의 프로그램이 공유된 메모리를 사용하여 복합데이터 구조와 통신하는 경우 GPL 적용 범위에 포함되지만, 파이프(pipe), 소켓(socket), command-line argument 형태로 통신하는 경우에는 포함되지 않습니다. 당사가 개발한 소프트웨어와 R(D)-COM이 통신하는 경우에도, 소프트웨어 사용 환경 및 적용 범위를 고려하고 위의 구분 기준에 비추어 결합 정도를 판단하여야 할 것입니다. 만약 GPL의 적용 범위에 포함되는 것으로 판단되면 GPL 사본 첨부, 저작권 고지사항 유지, 프로그램 소스코드 제공 등의 GPL 요구사항을 준수하여야 합니다. R 코어 팀에서 제공하는 FAQ에서도, R 패키지의 상업적 이용을 제한하지 않는다고 말하고 있지만, 관련 사항에 대해서는 담당 변호사에게 자문을 구하도록 하고 있으며, 직접적인 답변을 줄 수 없다고 명시하고 있습니다. 따라서, GNU·GPL이 사유 소프트웨어와 결합할 수 없다고 명시하고 있음에도 불구하고, R(D)-COM이 사유 소프트웨어인 마이크로소프트社의 엑셀 등과 GPL이 적용된 R을 연결하기 위해 사용되는 소프트웨어로 소개되어 있지만, 실질적으로 다른 소프트웨어와 함께 사용하는 경우에는 GPL이 적용된 R 패키지와의 동작 관계를 명확하게 확인하여야 할 것으로 판단됩니다.","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"기타","slug":"기타/기타","permalink":"http://jung-max.github.io/categories/기타/기타/"}],"tags":[{"name":"opensource","slug":"opensource","permalink":"http://jung-max.github.io/tags/opensource/"},{"name":"licence","slug":"licence","permalink":"http://jung-max.github.io/tags/licence/"}]},{"title":"Android Platform 배터리 개발 방법(rk816을 기준으로)","slug":"Android-Platform-배터리","date":"2019-10-13T23:44:34.000Z","updated":"2022-02-08T02:11:11.773Z","comments":true,"path":"2019/10/14/Android-Platform-배터리/","link":"","permalink":"http://jung-max.github.io/2019/10/14/Android-Platform-배터리/","excerpt":"","text":"RK805에 관련된 배터리의 포팅이 필요한 일이 생겼다. 인터넷에서 RK805에 대한 배터리 부분을 찾아봤지만 찾을 수 없었다.검색 결과 RK805는 RK816드라이버를 사용한다는 것을 찾아냈다. 그에 따라 RK816의 배터리 관련된 메뉴얼을 번역했다. 원문 링크 1 개요 RK818 / RK816 연료 게이지RK818 / RK816은 여러 개의 고전류 DCDC, 여러 개의 LDO, 1 개의 선형 스위치, 1 개의 USB 5V 및 부스트 출력, 스위치 충전, 지능형 전력 경로 관리, 쿨롱 카운터, RTC 및 조정 가능한 전원 켜기 타이밍 및 기타 기능. 그중에서 “스위치 충전, 지능형 전력 경로 관리, 연료 게이지 (쿨롱 미터)”가이 문서에서 다루는 기능입니다. 충전 관리 : 입력 전류 제한, 세류 충전, 정전류 / 정전압 충전, 충전 종료, 충전 시간 초과 보안 보호 및 기타 기능 포함. 지능형 전력 경로 관리 : 배터리를 충전하는 동안 시스템 부하에 필요한 전력을 공급하도록 출력 전압을 조정할 수 있습니다. 입력 전류 제한 상태에 들어가면 입력 전원이 우선적으로 시스템 부하에 공급되고 나머지 전원은 충전을 위해 배터리에 공급됩니다. 또한 시스템 부하에 필요한 전원이 지정된 입력 전원을 초과하거나 전원 입력이 연결 해제되면 지능형 전원 경로 관리 기능이 배터리와 시스템 부하 사이의 스위치를 자동으로 켜서 배터리가 시스템 부하에 동시에 추가 전원을 공급할 수 있습니다. 연료 게이지 (쿨롱 카운터) : 자체 기술 알고리즘을 사용하여 연료 게이지는 다양한 배터리의 충전 및 방전 특성에 따라 배터리 전력을 정확하게 측정하고 I2C 인터페이스를 통해 시스템 메인 칩에 배터리 전력 정보를 제공 할 수 있습니다. . 동시에 과방 전 된 배터리를위한 소 전류 충전, 배터리 온도 감지, 충전 안전 타이머 및 칩 열 보호와 같은 기능이 있습니다. 2 연료 게이지 원리 세 가지 기본 원칙 : 배터리의 개방 회로 전압과 배터리 전력의 백분율 (OCV-SOC) 곡선은 주로 배터리의 재료와 프로세스에 따라 달라지며 온도, 노화 등에 의해, 즉 배터리가 생산 된 후 영향을받습니다. SOC-OCV의 곡선은 기본적으로 변경되지 않습니다. 배터리는 작동 중 배터리 분극의 영향을 받기 때문에 배터리 포트 전압에서 배터리의 OCV 전압을 추정하기 어렵 기 때문에 배터리가 분극되지 않은 경우 (예 : 장시간 종료 또는 저 전류 작동 시간이 긴 경우) 얻을 수 있습니다. OCV 전압을 사용할 수 있으며 SOC는 OCV에서 파생됩니다. 쿨롱 미터는 실제로 배터리로 들어 오거나 나가는 전기의 양을 측정 할 수 있습니다. 배터리의 총 용량을 알면 SOC 값을 쉽게 얻을 수 있지만 쿨롱 미터의 누적 오류는 크며 배터리의 총 용량은 온도와 노화에 영향을받습니다. 동일한 영향으로 쿨롱 방식은 단시간에 더 나은 정확도를 보장 할 수 있으며 전체 배터리 용량을 정기적으로 업데이트해야합니다. 현재의 성능이 좋은 연료 게이지는 실시간 연료 게이지 잔여 용량 상태를 얻기 위해 위의 OCV 추정치 및 쿨롱 계산을 기반으로합니다. 쿨롱 방법배터리의 양극과 음극 단자 사이에 전류 체크 저항이 직렬로 연결되어 저항을 통해 전류가 흐르면 V_delta가 발생하고 V_delta를 감지하여 배터리에 흐르는 전류를 계산할 수 있습니다. 따라서 배터리의 전력 변화를 정확하게 추적하고 정확도를 1 %에 도달 할 수 있으며, 배터리 전압과 온도를 일치시킴으로써 배터리 노화와 같은 요인이 측정 결과에 미치는 영향을 크게 줄일 수 있습니다. 현재 신호 컨디셔닝전류는 20 또는 10 밀리 옴 저항으로 샘플링되고 정전류 소스에 의해 바이어스가 제공되어 네거티브 전류 신호를 양의 값으로 증가시킨 다음 op 앰프에 의해 기준 전압 Vref로 증폭되고 ADC 모듈에 의해 디지털 값으로 변환됩니다. 전압 획득배터리 전압은 전압 분배 회로 (부분 전압 비율 0.5)를 Vref 범위로 나누고 ADC 모듈에 의해 디지털 출력으로 변환합니다. 평균 전류 수집디지털 부분은 정정 된 전류 값 및 다중 자리 누산기를 초당 256 회 중첩한다. 1 초가 지난 후 어큐뮬레이터의 값을 256으로 나누어 평균 전류 값을 얻습니다. 쿨롱 카운터 업데이트쿨롱 카운터는 평균 전류가 업데이트 될 때 자동으로 한 번 추가됩니다. 3 중요한 개념 ocv 전압 개방 회로 전압. 이 시점의 부하는 개방 상태와 매우 유사하여이 시점의 전압이 정확하기 때문에 전원 켜기 시퀀스 중에 PMIC가 획득됩니다. 사용 : 최소 30 분 동안 셧다운이 충족되면 배터리의 분극이 기본적으로 제거된다고 생각합니다.이 시점에서 얻은 OCV 전압은 실제로 유효하므로 전압은 ocv_table을 쿼리하여 쿨롱 카운터의 값을 업데이트하는 새로운 전원을 얻는 데 사용됩니다. 쿨롱 카운터의 수정. ocv 테이블의 각 배터리는 자체 배터리 특성 곡선을 가지고 있습니다. ocv 특정 전압이 특정 전력에 해당한다는 원리에 따라 0 % ~ 100 %의 전력을 21 포인트로 5 % 씩 나누어 조각을 얻습니다. / Group “Voltage &lt;-&gt; Battery”양식. 이 표의 목적은 배터리 전원을 켠 후, 긴 종료 후 및 긴 절전 모드에서 처음으로 쿨롱 카운터를 수정하는 것입니다. 예를 들면 다음과 같습니다. 1ocv_table = &lt;3400 3599 3671 3701 3728 3746 3762 ...... 4088 4132 4183&gt;; 해당 : 3400mv : 0 %, 3599mv : 5 %, 3671mv : 10 %, …. 4183mv : 100 %; 최대 입력 전류 및 최대 충전 전류는 소프트웨어에서 “최대 입력 전류”라고하는 어댑터에서 가져올 수있는 최대 전류를 얻도록 구성됩니다. 예를 들어, 일반적인 소프트웨어 구성 최대 입력 전류 인 5V / 2A 어댑터는 2A입니다 (1.8A로 설정 가능). RK818 / 816에는 지능적인 전원 경로 관리 기능, 즉 어댑터의 전원이 우선적으로 시스템에 공급되고 배터리 잔량이 충전됩니다. 배터리 충전을 허용하기 위해 소프트웨어에서 구성되는 최대 잔류 전류 값을 “최대 충전 전류”라고합니다. 입력 전류 한계의 발생은 배터리 및 시스템에 대한 공급 전류 요구가 최대 입력 전류를 초과 할 때, 이러한 “불충분 한 사용”조건을 “입력 전류 한계 발생”이라고하는 것으로 이해 될 수있다. 또는, 입력 전류 제한은 배터리의 요구 조건 하에서 배터리가 최대 충전 전류 상태로 충전 될 수 없을 때 발생한다는 것을 이해할 수있다. 이 기능은 주로 전하 차단을위한 세 가지 조건 중 하나로 사용됩니다 (다른 두 가지는 전하 차단 전압 및 오프 전류). 슬랙 모드는 매우 낮은 부하 조건 (현재 2 차 대기의 경우에만)에 있고 시스템의 부하 전류가 특정 임계 값 미만으로 특정 임계 값 (소프트웨어 구성 가능)을 계속 초과하면 연료 게이지 모듈이 슬랙 모드로 들어갑니다. 이완 전압 이완 모드에서 연료 게이지는 8 분마다 일련의 전압을 수집하여 이완 전압이라고합니다. 사용 : 2 차 대기의 부하가 매우 작습니다 슬랙 전압이 개방 회로 전압에 근접한 것으로 추정되므로 드라이브 처리는 ocv_table 테이블을 사용하여 시스템이 2 차 대기에서 깨어나 특정 조건을 충족 할 때 쿨롱 카운터를 확인합니다. 완료 충전 차단 신호 배터리 충전 차단이 발생하면 레지스터는 완료 신호라는 상태 신호를 생성합니다. 사용 : 소프트웨어는이 신호 만 실제 하드웨어 충전 차단으로 간주 한 다음 해당 알고리즘 흐름을 입력하여 표시된 전력을 조정합니다. 칩 열 보호 PMIC의 자체 보호 메커니즘은 실제로 피드백 메커니즘입니다. 칩 온도가 설정된 임계 값보다 높으면 입력 전류가 점차 감소하여 PMIC 워크로드가 감소하고 칩 열이 줄어 듭니다. 이 피드백 프로세스는 하드웨어에 의해 자동으로 수행되며 소프트웨어가 참여할 수 없으며 극한 조건에서도 충전 및 중지가 엄격한 온도와 전류 크기 비율이 없습니다. 충전 차단 조건 충전 전류가 차단 전류에 도달하면 전압이 차단 전압에 도달하고 입력 전류 제한없이 충전 차단 신호가 생성되어 더 이상 충전이 계속되지 않으므로 배터리가 가득 찬 것으로 판단됩니다. (해석하기 위해 전류 제한 조건에 들어갈 필요가 있습니다. 그렇지 않으면 충전 전류가 작아 지는지 또는 현재 시스템 부하가 크고 배터리의 충전 전류가 작은 지 여부를 알 수 없습니다) 4 드라이버 및 menuconfig4.1 연료 게이지 구동 기능 배터리 전원 통계 및 디스플레이; 충전 전류 및 전압 설정 (배터리 및 충전기 유형에 따라), 단일 / 이중 포트 충전 지원; OTG 장치 5V 전원 공급 장치; 배터리 온도 감지 4.2 커널 4.4Rk818 드라이버 및 매크로 구성 (기능이 너무 커서 두 개의 드라이버로 분할 됨) : 12drivers/power/rk818_battery.c //전원 디스플레이 처리를 담당 함 drivers/power/rk818_charger.c //충전기 감지, 충전 전압, 전류 설정 처리를 담당 12CONFIG_BATTERY_RK818CONFIG_CHARGER_RK818 Rk816 드라이버 및 매크로 구성 : 1drivers/power/rk816_battery.c //전원 디스플레이 + 충전기 감지, 충전 전압, 전류 설정 처리 책임 1CONFIG_BATTERY_RK816 4.3 커널 3.10Rk818 드라이버 및 매크로 구성 : 1drivers/power/rk818_battery.c //전원 표시 + 충전기 감지, 충전 전압, 전류 설정 처리 1CONFIG_BATTERY_RK818 Rk816 드라이버 및 매크로 구성 : 1drivers/power/rk816_battery.c //전원 표시 + 충전기 감지, 충전 전압, 전류 설정 처리 1CONFIG_BATTERY_RK816 DTS 구성커널 4.4DTS 구성은 두 부분으로 구성됩니다. 배터리 부분 : 필수.전체 배터리 노드 정보는 다음과 같습니다. 노드는 RK818 노드 안에 위치합니다 .RKRK의 배터리 및 충전기 하위 장치 드라이버는 배터리 노드의 정보를 사용합니다. 여기서 ntc_table, ntc_degree_from, dc_det_gpio는 선택 사항이며 나머지는 필수입니다. 12345678910111213141516171819202122232425262728293031battery &#123; compatible = “rk818‐battery” ocv_table = &lt;3400 3599 3671 3701 3728 3746 3762 3772 3781 3792 38163836 3866 3910 3942 39714002 4050 4088 4132 4183&gt;; ntc_table = &lt;43662 41676 39793 38005 36308 34696 33164 31709 30326 29011 27760 26570 25438 24361 23335 22358 21427 20540 19695 18890 18121 17389 16690 16022 14778 14197 13642 13113 12606 12122 11659 11216 10793 10388 10000 9629 9273 8933 8607 8295&gt;; ntc_degree_from = &lt;1 10&gt;; design_capacity = &lt;4000&gt;; design_qmax = &lt;4100&gt;; bat_res = &lt;120&gt;; max_input_current = &lt;2000&gt;; max_chrg_current = &lt;1800&gt;; max_chrg_voltage = &lt;4200&gt;; sleep_enter_current = &lt;300&gt;; sleep_exit_current = &lt;300&gt;; power_off_thresd = &lt;3400&gt;; zero_algorithm_vol = &lt;3850&gt;; energy_mode = &lt;0&gt;; fb_temperature = &lt;105&gt;; sample_res = &lt;10&gt;; max_soc_offset = &lt;60&gt;; monitor_sec = &lt;5&gt;; virtual_power = &lt;0&gt;; power_dc2otg = &lt;1&gt;; dc_det_gpio = &lt;&amp;gpio0 GPIO_C1 GPIO_ACTIVE_LOW&gt;;&#125;; 충전기 부분 : 옵션 typec 포트가 지원되지 않으면이 구성 부분이 필요하지 않습니다. typec 충전 포트를 지원하는 시스템의 경우 아래에 표시된대로 rk818의 루트 노드 아래에 “extcon = &lt;&amp; fusbn&gt;”노드를 추가하십시오 (여기서 n = 0,1 .., 특정 참조는 실제 하드웨어를 참조하십시오). rk818_charger.c는 typec의 충전기 유형 감지 정보를 얻기 위해 참조에 따라 typec 알림 체인을 등록해야하기 때문에. 1234567891011121314151617181920rk818: pmic@1c &#123; compatible= \"rockchip,rk818\"; status= \"okay\"; reg= &lt;0x1c&gt;; clock‐output‐names= \"xin32k\", \"wifibt_32kin\"; interrupt‐parent= &lt;&amp;gpio1&gt;; interrupts = &lt;21IRQ_TYPE_LEVEL_LOW&gt;; pinctrl‐names= \"default\"; pinctrl‐0= &lt;&amp;pmic_int_l&gt;; rockchip,system‐power‐controller; rk818,support_dc_chg= &lt;1&gt;;/*1: dc chg; 0:usb chg*/ wakeup‐source; extcon = &lt;&amp;fusb0&gt;; // 중요!!! #clock‐cells= &lt;1&gt;; battery &#123; ........... ........... &#125;;&#125;; 5.2 커널 3.10RK816과 RK818의 노드 정보는 기본적으로 동일하며 개별 속성 만 다릅니다. 다음은 RK818의 예입니다. 완전한 배터리 노드 정보가 아래에 표시되며 노드는 RK818 노드 안에 있습니다. 그 중 ntc_table, ntc_degree_from, dc_det_gpio, dc_det_adc는 선택적 부분이며 나머지는 필수 부분입니다. 1234567891011121314151617181920212223242526272829303132battery &#123; compatible = \"rk818‐battery\" //rk816 인 경우 \"rk816- 배터리\"로 변경하십시오. ocv_table = &lt;3400 3599 3671 3701 3728 3746 3762 3772 3781 3792 38163836 3866 3910 3942 39714002 4050 4088 4132 4183&gt;; ntc_table = &lt;43662 41676 39793 38005 36308 34696 33164 31709 30326 29011 27760 26570 25438 24361 23335 22358 21427 20540 19695 18890 18121 17389 16690 16022 14778 14197 13642 13113 12606 12122 11659 11216 10793 10388 10000 9629 9273 8933 8607 8295&gt;; ntc_degree_from = &lt;1 10&gt;; design_capacity = &lt;4000&gt;; design_qmax = &lt;4100&gt;; bat_res = &lt;120&gt;; max_input_current = &lt;2000&gt;; max_chrg_current = &lt;1800&gt;; max_chrg_voltage = &lt;4200&gt;; sleep_enter_current = &lt;300&gt;; sleep_exit_current = &lt;300&gt;; sleep_filter_current = &lt;100&gt;; //Rk818에는 이 속성이 필요하지 않습니다 power_off_thresd = &lt;3400&gt;; zero_algorithm_vol = &lt;3850&gt;; energy_mode = &lt;0&gt;; fb_temperature = &lt;105&gt;; max_soc_offset = &lt;60&gt;; monitor_sec = &lt;5&gt;; virtual_power = &lt;0&gt;; power_dc2otg = &lt;1&gt;; dc_det_gpio = &lt;&amp;gpio0 GPIO_C1 GPIO_ACTIVE_LOW&gt;; dc_det_adc = &lt;1&gt;; // Rk818은이 속성이 필요하지 않습니다. Rk816은 필요한 것만&#125;; ocv_table 개방 회로 전압-전기 계량기. 즉, “전력량에 상응하는 전압”, 총 21 개의 전압 값, 각각 0 %-&gt; 100 %에 해당하는 전압 값 스테핑 사이의 전압은 5 %이다. 데이터 시트는 원래 배터리 제조업체에서 제공하거나 RK Shenzhen Branch 또는 RK에서 제공 한 측정 도구로 측정 할 수 있습니다. 자세한 내용은 Shenzhen Branch 관련 엔지니어에게 문의하십시오. ntc_table 배터리 NTC 테이블, 단위 : 옴. 배터리 온도를 확인해야하는 경우 해당 ntc 값을 입력하십시오. 값은 온도를 나타내며 인접한 값 사이의 온도는 왼쪽에서 오른쪽으로 1 도씩 증가합니다. 배터리 온도를 감지 할 필요가 없으면이 속성 필드를 제거하십시오. 위의 예는 섭씨 -10 ~ 30도에 해당하는 ntc 값을 나타냅니다. ntc_degree_from 시작 온도 값인 ntc_table [0]에 해당하는 온도입니다. 따라서 ntc_table을 구성한 경우이 특성을 추가하십시오. DTS는 음수를 전달할 수 없으므로 ntc_degree_from은 두 개의 필드로 구성되며, 첫 번째는 양수 및 음수 부호를 나타냅니다. 예를 들어, ntc_degree_from = &lt;1, 10&gt;은 -10도를 의미합니다. design_capacity 실제 배터리 용량. 실제 측정 후 사용 가능한 실제 용량. 예를 들어, 공칭 4000mah이지만 실제 측정 값은 3850mah에 불과합니다.이 값으로 3850을 입력하십시오. design_qmax 최대 용량 값은 주로 소프트웨어 처리를위한 오류 수정 조건 중 하나로 사용됩니다. 공칭 용량의 1.1 배인 공칭 용량 * 1.1을 입력하십시오. bat_res 배터리 내부 저항. 방전 알고리즘에서 주로 사용되며 매우 중요합니다! 이 값은 ocv_table을 측정 할 때 함께 얻어 지므로이 매개 변수의 측정에주의하십시오. max_input_current 최대 입력 전류. 현재 다음 기어가 있습니다 (단위 : mA) : 12RK818: &lt;450, 80, 850, 1000, 1250, 1500, 1750, 2000, 2250, 2500, 2750, 3000&gt;RK816: &lt;450, 80, 850, 1000, 1250, 1500, 1750, 2000&gt; 두 번째 기어는 800이 아니라 80입니다. 일반적으로 80ma 기어 위치는 사용 중에 설정되지 않습니다. max_chrg_current 최대 충전 전류. 현재 다음 기어가 있습니다 (단위 : mA) : 12RK818: &lt;1000, 1200, 1400, 1600, 1800, 2000, 2250, 2400, 2600, 2800, 3000&gt;RK816: &lt;1000, 1200, 1400, 1600, 1800, 2000, 2250, 2400&gt; max_chrg_voltage 최대 충전 전압, 즉 배터리 완전 충전의 차단 전압. 현재 다음 장비가 있습니다 (단위 : mV) : 12RK818: &lt;4050, 4100, 4150, 4200, 4250, 4300, 4350&gt;RK816: &lt;4050, 4100, 4150, 4200, 4250, 4300, 4350&gt; sleep_enter_current슬립 모드로 들어가기위한 조건 중 하나입니다. 현재 300, 변경 사항 없음 sleep_exit_current슬립 모드를 종료하기위한 조건 중 하나입니다. 현재 300, 변경 사항 없음 sleep_filter_current유효하지 않은 슬립 전류를 필터링합니다. 현재 100, 변경하지 마십시오. power_off_thresd 주의 깊게 읽고 이해하십시오예상되는 시스템 종료 전압, 단위 : mV. 특별 참고 사항 :이 값은 vbat 터미널의 전압이 아니라 VSYS의 순간 전압을 나타냅니다 (그러나 연료 게이지는 vbat 터미널의 전압을 수집합니다)! 원리 : Vbat 터미널의 전압은 VSYS 공급 시스템으로 변환되는 약 50 밀리 옴 (PCB 트레이스의 임피던스 제외)의 저항을 가진 모스 튜브를 통과해야하므로 VSYS가 셧다운 지점으로 사용됩니다. 맞습니다. 이것으로부터 우리는 알 수 있습니다 : 동일한 vbat 터미널 전압, 전류 부하 전류가 더 크고 vsys 터미널의 전압이 낮습니다. 반대로 동일한 vsys에서 전류 부하 전류가 클수록 해당 vbat 전압이 높습니다. RK의 플랫폼은 vsys 터미널의 전압이 3.4v보다 낮을 것을 권장하지 않으므로 VCC_IO (3.3v)와 같은 DCDC / LDO의 전원 공급이 불안정하게됩니다. zero_algorithm_vol전압 + 쿨롱 방전 모드 전압 값을 입력하십시오 (단위 : mV). 이 값 아래에 전압 + 쿨롱 미터 결합 소프트웨어 방전 알고리즘을 입력하십시오. 권장 사항 : 4.2v 배터리는 3850mv로 설정되고 4.3v 이상 배터리는 3950mv로 설정됩니다. energy_mode일부 고객은 곡선의 매끄러움에 대해 걱정하는 반면, 다른 고객은 배터리가 완전히 방전 될 수 있는지와 두 사람이 균형을 맞추기가 어려운지에 대해 더 우려하고 있습니다. 따라서이 속성은 선택하도록 예약되어 있습니다. 값이 1이면 배터리 전원을 최대한 많이 꺼냅니다 .0이면 커브 스무딩의 합리성을 고려하는 것입니다 (예 : 3.4v 종료 설정, 때로는 3.5v 종료)에서 드라이버가 곡선 평활도와 종료 전압 포인트의 균형을 맞추려고했기 때문에 0으로 설정하는 것이 좋습니다. 테스트에서 종료 전압 포인트가 요구를 충족 할 수없는 것으로 확인되면 드라이버와 관리자에게 직접 연락하여 최적화를 시도하거나 시도하도록 1로 설정할 수 있습니다. fb_temperature칩 열 보호 온도 임계 값에는 현재 4 개의 온도 기어가 있습니다 (단위 : 섭씨). 1&lt; 85, 95, 105, 115&gt; 현재 VR에서 115가 선택되고 나머지는 105로 선택됩니다. 0으로 설정하면 온도 피드백 기능이 꺼지고이 값은 일반적으로 문제 설정의 문제 해결에만 사용됩니다 ( “1.5 일반적인 문제 분석 및 위치 지정”참조). 정상적인 사용 중에는 온도 피드백 기능을 끄지 마십시오. sample_res배터리 끝 근처의 샘플링 저항 크기 (밀리 옴)입니다. 쿨롱 카운터는이 저항을 사용하여 현재 시스템의 전류 레벨을 알고 있으므로 실제 하드웨어의 저항을 입력하십시오. 현재 저항의 크기는 10mR 또는 20mR 만 지원합니다. 참고 : 4.4 커널의 rk818 연료 게이지 드라이버 만 지원됩니다. 3.10 커널은 지원되지 않으며 기본값은 20mR입니다. max_soc_offset전원 켜기 교정 중에 허용되는 최대 전원 오류. 최소 30 분 동안 전원을 끄면 전원을 켤 때 ocv 테이블의 전원 쿼리가 수행되고 종료 전의 전원이 비교되고 편차가 max_soc_offset을 초과하면 강제 수정이 수행되고 전원이 ocv 테이블에 해당하는 실제 값으로 설정됩니다. 예를 들어, 현재 디스플레이 전력은 20 %이지만 ocv 전압을 기반으로 계산 된 실제 전력은 80 %이며 표시된 전력은 직접 80 %로 표시됩니다. 일반적으로 이러한 종류의 전력 편차는 충돌이 발생한 후 매우 큽니다.이 값의 값은 고객의 승인 여부에 따라 고객이 설정하므로이 값은 60보다 작지 않는 것이 좋습니다. monitor_sec폴링 시간 (초) 연료 게이지 드라이버는 정상 작동을 위해 지속적으로 폴링해야하며이 기간 동안 많은 I2C 읽기 및 쓰기 작업이 필요하지만 플랫폼에 따라 I2C 견고성이 다른 정도를 고려하면 구성 옵션이 예약됩니다. 현재 5 ~ 10 초가 적합하며 5 초로 설정하는 것이 가장 좋습니다. virtual_power테스트 모드. 때로는 복사 과정에서 전원, 충전 전류 등으로 인해 시스템의 전원이 꺼질 것으로 예상되지 않습니다. 이 값을 1로 설정하면 충전 전류 제한이 해제되고 시스템 입력 전류는 항상 max_input_current로되어 전원 공급 장치를 충족시킵니다. 이때, 드라이버는 항상 android, 현재 충전 상태, 전력은 66 %로보고됩니다. power_dc2otgDC에서 5V 전력을 공급하기 위해 otg 장치를 지원할지 여부 듀얼 포트 충전을 지원하는 기계의 경우, 하드웨어 회로에서 dc가 지원 될 때 otg 장치의 5v 전원 공급 장치는 dc에 의해 직접 공급되며 RK818은 추가 5v 출력을 제공하지 않습니다. 지원이 1로 설정되었습니다. 지원되지 않거나 dc 포트가없는 경우 0을 설정하십시오. dc_det_gpiodc 핀에 해당하는 gpio를 지정하십시오. 이 기능이 없으면이 속성을 제거하십시오. dc_det_adcsaradc를 사용하여 dc 피트를 감지할지 여부, 1 : 지원, 0 : 지원되지 않습니다. 일반적으로이 속성과 “dc_det_gpio”는 두 가지 옵션입니다. 6 연료 계 관련 개발 시작준비 배터리의 ocv 곡선 및 배터리 내부 저항 측정 : 각 배터리에는 전압 전기 특성 곡선 (ocv_table)과 내부 저항이 있으며 RK Shenzhen에서이 측정을 수행 할 수 있습니다. DTS 파라미터를 채우고 1.5 절을 참조하여 올바르게 구성하십시오. 배터리 보정에 대해서는 1.7 단원을 참조하십시오. 정상적인 사용을 시작하십시오. 문제 처리 사용 중 이상이 발생한 경우 사이트의 로그를 캡처하고 분석하기 위해 디버그 정보를여십시오. 점프와 같은 충전 / 방전 곡선에 문제가 있다고 생각되면 너무 빠르거나 너무 느립니다. 그런 다음 완전한 (0100 % 또는 100 % 0 %, 원칙 : 큰 전력 범위를 커버하려고하십시오) 충전 / 방전 로그를 잡으십시오. 이유를 직접 분석 할 수없는 경우, 현장 또는 반복되는 로그를 잡고 레드 마인을 언급하십시오.참고 : 캡처 된 로그는 연료 게이지의 디버그 정보를 열어야합니다! ! 몇 가지 일반적인 질문은 섹션 8에서 찾을 수 있습니다. 7 배터리 보정7.1 배터리 보정 원리 기계를 끈 후에는 PMIC 만 DCDC / LDO를 끄지 만 완전히 꺼진 것은 아니지만 매우 낮은 부하로 전원이 켜진 상태로 유지됩니다. PMIC 자체는 연료 게이지의 데이터를 저장하는 데 사용할 수있는 일부 빈 데이터 레지스터를 제공합니다. 현재 저장된 정보는 연료 게이지 드라이버 초기화를 위해 전원을 켤 때마다 전력, 쿨롱 용량, 배터리 완전 충전 용량 (예 : design_capacity)과 같이 장비 전면과 관련됩니다. 이 값이 DTS의 영향을받지 않으면 종료 전의 데이터를 읽고 계속 사용합니다. 위의 세 가지 정보를 수정해야 할 경우 데이터를 지우려면 PMIC의 전원을 완전히 꺼야합니다. 전원을 완전히 껐다가 켜면 배터리 GGSTS_REG [4]의 상태 비트 ( “첫 번째 전원 켜기”)가 설정됩니다. 따라서 배터리를 제거하여이를 달성해야합니다. 배터리가 다시 연결되면, 운전자는 현재 “처음으로 전원을 켰다”고 판단한 후 DTS에서 모든 관련 데이터를 검색하여 관련 배터리 용량, 전원 등을 계산합니다. 이러한 방식으로 수정 후 정확한 상태를 얻습니다. 세 번째로, 배터리를 제거한 후 다시 연결하기 전에 기본적으로 분극이 제거되었는지 확인해야합니다 (분극이 제거 될 때까지 배터리를 그대로 둘 수 있음). 그렇지 않으면 부팅의 ocv 전압이 정확하지 않습니다. 예를 들어, 큰 부하가 방전되면 배터리가 제거되고, 이때 배터리는 실제로 분극 상태가되어 배터리 전압이 서서히 상승하게되며, 이때 다시 연결되면 이때 수집 된 ocv 전압은 그렇지 않습니다. 정확한! 교정이 수행 될 때 배터리가 분극이 기본적으로 제거 된 상태에 있어야 정확한 전력을 얻기 위해 첫 번째 부팅의 ocv 전압이 정확해야합니다. 7.2 배터리 수정 방법현재 배터리를 수정하는 두 가지 방법이 있습니다. 2는 1을 선택합니다. 하드웨어 방법 : 약 10 초 동안 배터리를 분리했다가 다시 연결하십시오. 소프트웨어 방법 : 직렬 포트를 사용하여 다음 작업을 수행하십시오. bat 노드 경로를 찾으십시오. busybox find /sys/ -name bat, 예를 들어 경로는 “/sys/rk818/bat”; (rk816 인 경우 경로는 “/sys/rk816/bat”, 아래 동일) 실행 : echo m &gt; /sys/rk818/bat; echo r &gt; /sys/rk818/bat를 다시 읽으십시오. BIT(4)의 리턴 값은 1이어야합니다. 그런 다음 정상적으로 종료하고 최소 30 분 동안 전원을 끈 다음 다시 켜십시오 (정확한 ocv 전압을 얻음). 보충 : 2 단계에서 조작을 지우려면 다음을 실행하십시오. echo c &gt; /sys/rk818/bat; 7.3 언제 수정해야합니까? DTS 구성의 배터리 용량이 변경된 경우 전원이 허용되지 않는 것이 분명합니다 (기계 충돌, 특수 비 연료 게이지 압력 테스트 등일 수 있음). 연료 게이지는 배터리가 정확한 상황에서 테스트되도록하기 위해 특수 기계 전에 보정됩니다. 이는 의미가 있습니다 (모든 테스트 항목의 첫 번째 보정 만 필요하며 테스트 전에 각 사례를 수정할 필요는 없습니다). 8 일반적인 문제 분석 및 위치 디버깅 정보를 열고 로그를 얻는 방법? 방법 1 : 컴파일하기 전에 드라이버 첫 줄의 static int dbg_enable = 0을 1로 변경하십시오. 방법 2 : 펌웨어가 dbg_enable을 열지 않으면 직렬 포트에서 다음 명령을 입력하여 작업을 수행 할 수도 있습니다. Open : echo 1&gt; /sys/module/rk818_battery/parameters/dbg_level 닫기 : echo 0 &gt;/sys/module/rk818_battery/parameters/dbg_level 왜 어댑터 또는 USB를 연결하고 종료 직후에 다시 시작하면 종료 할 수 없습니까? PMIC 칩은 원래 충전기가 연결되어있는 한 종료되도록 설계되었습니다. 전원을 켠 후에 배터리가 핫 플러깅되고 레지스터 GGSTS[4] (배터리가 있음)로 표시된 상태가 실제 상황과 다른 이유는 무엇입니까? PMIC는 배터리의 핫 스왑 감지를 지원하지 않으며 전원이 켜져있을 때만 테스트를 수행합니다. 셧다운 후 전압이 DTS 구성의 셧다운 지점과 다른 이유는 무엇이며 고전압이 꺼 집니까? 셧다운 전압은 마지막 로그에 인쇄 된 실시간 전압을 기준으로하며 셧다운 전압은 vsys 전압입니다 (자세한 내용은 섹션 1.5.2 참조) 실시간 전압이 사전 설정된 셧다운 지점보다 낮아서는 안됩니다. 그리고 시스템의 전원이 꺼지면 리튬 배터리의 분극이 천천히 사라지고 전압 상승 과정이 생겨 리튬 배터리의 특성이됩니다. 기기를 켜거나 재부팅하거나 보조 대기 상태 일 때 전원이 바뀌지 않는 이유는 무엇입니까? 이 시점에서 드라이버는 정상적으로 폴링 할 수없고 작동 상태로 들어갈 수 없으므로 이러한 유형의 복사 테스트는 지원되지 않습니다. 연료 게이지 테스트를 수행 할 때 품질 부서와 고객이이 세 가지 항목을 테스트 할 필요는 없습니다. 왜 배터리 충전기를 사용하지만 충전 전류가 매우 작습니까? 충전 라인의 품질이 낮고 임피던스가 높아 버스의 전압이 5V보다 훨씬 낮은 지 확인하십시오. 외부 조정 전원 공급 장치로 전원을 공급하고 전압을 적절히 높이며 전류가 증가 할 수 있는지 관찰 할 수 있습니다. 오프 스크린 상태 (레벨 1 대기)로 들어가서 충전 전류가 증가하는지 관찰하여 작동 전력 소비와 관련이 있는지 확인하십시오. 빨리 채워진 배터리는 충전 전류가 작으므로 배터리 전압에주의하십시오. 고온 및 고부하 조건에서 PMIC 온도 상승이 입력 전류 제한을 트리거 할 수 있습니다. 따라서 피드백 온도 (fb_temperature)를 높이고 그것이 유효한지 확인하십시오. 그렇지 않은 경우 온도 제어 테스트를 직접 끄십시오 (fb_temperature가 0으로 설정 됨). 배터리를 분리하고 전원을 켜면 배터리는 어떻게됩니까? 우리는 배터리를 분해 한 후에도 배터리가 튀지 않도록 요구합니다. 배터리의 플러그를 뽑은 후 PMIC의 전원이 완전히 꺼졌습니다.이 시점에서 ocv 전압은 ovv_table 만 가능하므로 전원을 반대로 할 수 있습니다. 정상적인 경우 배터리 재 교정입니다 . 분해 후 배터리 전원이 뛰지 않기를 바랍니다. 소프트웨어를 우회하지 않는 한 거의 불가능합니다. 시스템을 종료하기 전에 전원을 파일에 쓴 다음 전원을 켠 후 읽습니다. 고객이 요청한 경우 처리를 피하기 위해 고객에게 코드의이 부분을 추가하도록 요청하십시오. PMIC에는 입력 전류를 조절하는 온도 피드백 기능이 있습니다.이 시점에서 PMIC의 내부 온도를 어떻게 알 수 있습니까? 이 기능이 디자인에 남아 있지 않다는 것을 알 방법이 없습니다. 왜 통나무에 인쇄 된 전류가 너무 터무니없고 부호가 반전되거나 전류와 실제 차이가 너무 큰가? 20/10 밀리 옴의 샘플링 저항이 선택되고 저항 정확도가 충분히 높은지 확인한 다음, 솔더 조인트가 깨끗하고 샘플링 저항이 BAT와 GND 사이에 있는지 확인하십시오. 전력이 충분하지 않은 이유는 무엇입니까, 예를 들어 3.9v 만 완료됩니까? 일반적으로 배터리 품질이 좋지 않고 최대 충전 전류가 너무 크게 설정되어 패널이 자체 보호되어 PMIC가 마무리 상태를 잘못보고하게됩니다. 완료 상태의 현재 값이 양수 및 음수 (소수)로 변동하는 이유는 무엇입니까? 이것은 최대 전원 공급 후의 현재 제로 오류이므로 중요하지 않습니다. 왜 마감을보고합니까, 전기의 표시가 100 %가 아닌 90 % 이상입니까? 쿨롱 카운터에 오류가 누적되고 하드웨어에 의해 충전 종료가 완료되므로이 둘 사이에 약간의 오류가 발생하며 완료 보고서의 타이밍을 정확하게 파악할 수 없으므로이 상황은 정상입니다. 이 경우 소프트웨어는 프로세스를 수행합니다. 즉, 최종 사용자가이를 알지 못하기 때문에 전력을 100 %에 가깝게 천천히 놓아두면 사용에 문제가 없습니다. 작동중인 공정 연료 계량기의 전기량이 왜 부정확하고 ocv_table의 값이 그렇게 다른가? 개념 혼란. Ocv_table은 부하 조건이없는 개방 회로의 전압 대 충전 비율이며,이 표는 전원 공급 보정 및 절전 보정에만 사용합니다. 따라서 이러한 종류의 비교는 의미가 없으며 원칙적으로 의미가 없습니다. 다른 사양의 배터리 교체를 지원합니까? 지원되지 않습니다. 배터리를 교체 한 다음 ocv 곡선, 내부 저항, 용량 및 기타 매개 변수를 다시 테스트해야합니다. PMIC가 배터리가 꽉 찼다 고 판단하는 조건은 무엇입니까? 전압이 차단 전압에 도달하고 전류가 마무리 전류에 도달하며 입력 전류 제한이 발생하지 않는 세 가지 조건을 동시에 충족해야합니다. 배터리 아이콘에 항상 50 %가 충전 중임을 표시하는 이유는 무엇입니까? test_power 드라이버를 비활성화하십시오. 배터리 아이콘에 항상 66 % 충전이 표시되는 이유는 무엇입니까? 현재 배터리가 연결되어 있지 않거나 DTS의 virtual_power가 1로 구성되어 있습니다. 0으로 구성하십시오. 충전기가 왜 연결되어 있습니까? 커널 4.4 : rk818_charger.c는 충전기 감지를 담당합니다 USB 포트 충전기 및 otg 장치 플러그 앤 플레이는 USB 알림 체인에 따라 다르므로 직렬 포트 로그에 “rk818-charger : recieve xxx notifier event : xxx”등이 표시되는지 확인하십시오. 직렬 포트 정보가 아닌 경우, USB 알림 체인이 성공적으로 등록되지 않았거나 (아마도 작음) USB 드라이버에 문제가 있습니다. Rk818_charger.c는 충전기 감지를 담당하며 USB 포트 충전기 및 otg 장치 플러그 앤 플레이는 USB 알림 체인에 따라 다르므로 직렬 포트 로그에 “rk818-charger : recieve xxxnotifier event : xxx”와 같은 직렬 포트 정보가 인쇄되는지 확인하십시오. 그렇지 않은 경우, USB 알림 체인이 성공적으로 등록되지 않았거나 (아마도 작음) USB 드라이버에 문제가 있습니다. 커널 3.10 : rk818_battery.c는 충전기 (배터리 전원 포함), USB 포트 충전기 및 otg 장치 플러그 앤 플레이의 감지는 USB 알림 체인에 따라 다릅니다. 직렬 포트 로그에 “rk818-bat : recieve xxx notifier”가 표시되는지 확인하십시오. 이벤트 : xxx “및 기타 직렬 정보 (그렇지 않은 경우) USB 알림 체인이 성공적으로 등록되지 않았거나 (아마도 작음) USB 드라이버에 문제가 있습니다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform DTS","slug":"Android/Platform-DTS","permalink":"http://jung-max.github.io/categories/Android/Platform-DTS/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"Battery","slug":"Battery","permalink":"http://jung-max.github.io/tags/Battery/"},{"name":"DTS","slug":"DTS","permalink":"http://jung-max.github.io/tags/DTS/"}]},{"title":"Javascript로 Markdown 파서 구현하기","slug":"Web-Javascript-MarkDown구현","date":"2019-09-27T03:52:00.000Z","updated":"2022-02-08T02:11:11.825Z","comments":true,"path":"2019/09/27/Web-Javascript-MarkDown구현/","link":"","permalink":"http://jung-max.github.io/2019/09/27/Web-Javascript-MarkDown구현/","excerpt":"","text":"이번에는 javascript로 markdown 파서를 구현하는 것을 살펴보겠습니다. html일단 html 부분을 살펴보겠습니다.간단히 입력부분은 aside로 contenteditable 옵션을 줘서 수정 가능하게 했습니다.그러고 출력부분을 section로 만들었습니다.마지막에 markdown.js을 넣어서 입력한 부분에 대한 처리(이벤트)를 하도록 하였습니다. 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;meta charset='utf-8'&gt; &lt;link rel=\"stylesheet\" href=\"md_css.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"#\" id=\"raw-switch\" class=\"raw-switch\"&gt;Raw: &lt;span&gt;&lt;/span&gt;&lt;/a&gt; &lt;aside id=\"markdown\" contenteditable&gt;&lt;/aside&gt; &lt;section id=\"output-html\"&gt;&lt;/section&gt; &lt;script src=\"markdown.js\"&gt; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; csscss는 aside와 section의 넓이를 50%로 주어 각각 위치하도록 하였습니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566* &#123; -moz-box-sizing: border-box; -webkit-box-sizing: border-box; box-sizing: border-box;&#125;html,body &#123; height: 100%; margin: 0;&#125;body &#123; font: 300 16px 'Cousine'; color: #444; line-height: 1.5em;&#125;.raw-switch &#123; font-size: .9em; color: #444; position: fixed; top: 20px; left: 40px; z-index: 1;&#125;aside,section &#123; width: 50%; padding: 40px 80px;&#125;aside &#123; background: #f1f1f1; white-space: pre-wrap; position: fixed; top: 0; left: 0; bottom: 0; overflow-y: scroll; float: left;&#125;aside:focus &#123; outline: none;&#125;section &#123; height: 100%; margin-left: 50%; overflow-y: scroll; overflow-x: hidden;&#125;section h1 &#123; font-size: 1.8em;&#125;section b &#123; font-weight: 700;&#125;section pre &#123; overflow-y: scroll;&#125; 변환 javascript식javascript는 일단 parseMd라는 함수에서 markdown 문법에 따라 html 형식으로 변형시켜줍니다.해당 변형에는 javascript의 정규식 표현을 따릅니다. raw-switch버튼은 off일때 innerText, on일때 innerHTML형식을 써서 마크다운/html 형식으로 결과물을 보여줍니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485function parseMd(md)&#123; //ul md = md.replace(/^\\s*\\n\\*/gm, '&lt;ul&gt;\\n*'); md = md.replace(/^(\\*.+)\\s*\\n([^\\*])/gm, '$1\\n&lt;/ul&gt;\\n\\n$2'); md = md.replace(/^\\*(.+)/gm, '&lt;li&gt;$1&lt;/li&gt;'); //ol md = md.replace(/^\\s*\\n\\d\\./gm, '&lt;ol&gt;\\n1.'); md = md.replace(/^(\\d\\..+)\\s*\\n([^\\d\\.])/gm, '$1\\n&lt;/ol&gt;\\n\\n$2'); md = md.replace(/^\\d\\.(.+)/gm, '&lt;li&gt;$1&lt;/li&gt;'); //blockquote md = md.replace(/^\\&gt;(.+)/gm, '&lt;blockquote&gt;$1&lt;/blockquote&gt;'); //h md = md.replace(/[\\#]&#123;6&#125;(.+)/g, '&lt;h6&gt;$1&lt;/h6&gt;'); md = md.replace(/[\\#]&#123;5&#125;(.+)/g, '&lt;h5&gt;$1&lt;/h5&gt;'); md = md.replace(/[\\#]&#123;4&#125;(.+)/g, '&lt;h4&gt;$1&lt;/h4&gt;'); md = md.replace(/[\\#]&#123;3&#125;(.+)/g, '&lt;h3&gt;$1&lt;/h3&gt;'); md = md.replace(/[\\#]&#123;2&#125;(.+)/g, '&lt;h2&gt;$1&lt;/h2&gt;'); md = md.replace(/[\\#]&#123;1&#125;(.+)/g, '&lt;h1&gt;$1&lt;/h1&gt;'); //alt h md = md.replace(/^(.+)\\n\\=+/gm, '&lt;h1&gt;$1&lt;/h1&gt;'); md = md.replace(/^(.+)\\n\\-+/gm, '&lt;h2&gt;$1&lt;/h2&gt;'); //images md = md.replace(/\\!\\[([^\\]]+)\\]\\(([^\\)]+)\\)/g, '&lt;img src=\"$2\" alt=\"$1\" /&gt;'); //links md = md.replace(/[\\[]&#123;1&#125;([^\\]]+)[\\]]&#123;1&#125;[\\(]&#123;1&#125;([^\\)\\\"]+)(\\\"(.+)\\\")?[\\)]&#123;1&#125;/g, '&lt;a href=\"$2\" title=\"$4\"&gt;$1&lt;/a&gt;'); //font styles md = md.replace(/[\\*\\_]&#123;2&#125;([^\\*\\_]+)[\\*\\_]&#123;2&#125;/g, '&lt;b&gt;$1&lt;/b&gt;'); md = md.replace(/[\\*\\_]&#123;1&#125;([^\\*\\_]+)[\\*\\_]&#123;1&#125;/g, '&lt;i&gt;$1&lt;/i&gt;'); md = md.replace(/[\\~]&#123;2&#125;([^\\~]+)[\\~]&#123;2&#125;/g, '&lt;del&gt;$1&lt;/del&gt;'); //pre md = md.replace(/^\\s*\\n\\`\\`\\`(([^\\s]+))?/gm, '&lt;pre class=\"$2\"&gt;'); md = md.replace(/^\\`\\`\\`\\s*\\n/gm, '&lt;/pre&gt;\\n\\n'); //code md = md.replace(/[\\`]&#123;1&#125;([^\\`]+)[\\`]&#123;1&#125;/g, '&lt;code&gt;$1&lt;/code&gt;'); //p md = md.replace(/^\\s*(\\n)?(.+)/gm, function(m)&#123; return /\\&lt;(\\/)?(h\\d|ul|ol|li|blockquote|pre|img)/.test(m) ? m : '&lt;p&gt;'+m+'&lt;/p&gt;'; &#125;); //strip p from pre md = md.replace(/(\\&lt;pre.+\\&gt;)\\s*\\n\\&lt;p\\&gt;(.+)\\&lt;\\/p\\&gt;/gm, '$1$2'); return md; &#125;var rawMode = true; mdEl = document.getElementById('markdown'), outputEl = document.getElementById('output-html'), parse = function()&#123; outputEl[rawMode ? \"innerText\" : \"innerHTML\"] = parseMd(mdEl.innerText); &#125;;parse();mdEl.addEventListener('keyup', parse, false);//Raw mode trigger btn(function()&#123; var trigger = document.getElementById('raw-switch'), status = trigger.getElementsByTagName('span')[0], updateStatus = function()&#123; status.innerText = rawMode ? 'On' : 'Off'; &#125;; updateStatus(); trigger.addEventListener('click', function(e)&#123; e.preventDefault(); rawMode = rawMode ? false : true; updateStatus(); parse(); &#125;, false); &#125;());","categories":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"http://jung-max.github.io/categories/Web/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/tags/Web/"},{"name":"Java Script","slug":"Java-Script","permalink":"http://jung-max.github.io/tags/Java-Script/"}]},{"title":"Javascript replace함수 정규식 표현","slug":"Web-JavaScript-replace정규식","date":"2019-09-26T23:34:00.000Z","updated":"2022-02-08T02:11:11.824Z","comments":true,"path":"2019/09/27/Web-JavaScript-replace정규식/","link":"","permalink":"http://jung-max.github.io/2019/09/27/Web-JavaScript-replace정규식/","excerpt":"","text":"개요Javascript에서는 특정 문자열에 포함된 문자열을 다른 문자열로 대체하기 위해 replace함수라는 것을 제공합니다. 12String test = \"Who are you? I'm your father.\";String revTest = test.replace(\"you\", \"wow\"); 결과는 revTest = “Who are wow? I’m your father.” 분명 뒤에 your 에 you가 또 존재하기 때문에 뒤에 있는 you도 wow로 대체될 것으로 생각했지만, 앞의 you만 wow로 대체되었다. javascript는 위와 같은 방식으로 사용하면 처음 만나는 대체 문자만 대체한다. 그러면 어떻게 뒤에 나오는 you도 wow로 대체할 수 있을까? 즉 replace all 과 같은 기능을 구현하려면 어떻게 해야 할까? 간단하게는 javascript의 정규식(Regular expressions)을 사용하면 된다. String revTest = test.replace(/you/g, “wow”); 또는 String revTest = test.replace(/you/gi, “wow”); 결과는 revTest = “Who are wow? I’m wowr father.” Javascript의 정규식은 다음과 같은 형태로 사용한다. replace(바꿀 문자, 바뀌어질 문자) 바꿀 문자는 다음과 같은 형태로 정규식으로 사용할 수 있다. (정규식을 사용하지 않으면 위의 예에서 보았듯이 대체 대상 문자 중에서 첫 번째 만다는 문자만 대체된다.) /패턴/정규식옵션 패턴 : 대체할 문자를 입력 정규식옵션 g (global) : 첫번째 문자만이 아닌 패턴에 해당하는 모든 문자들을 검색하여 대체한다. i (ignoreCase) : 대소문자 구분하지 않음. m (multillineM) : 여러 줄 검색 s : “dotAll”; 줄 바꿈과 일치 하는 .을 허용합니다. u : 유니 코드; 패턴을 일련의 유니 코드 코드 포인트로 취급 y : sticky; 대상 문자열에서이 정규식의 lastIndex 속성으로 표시된 인덱스에서만 일치하며 이후 인덱스에서는 일치하지 않습니다. 정규식의 특수 문자.\\다음의 규칙에 따라 일치합니다: 특수 문자가 아닌 문자(non-special character) 앞에서 사용된 백슬래시는 ‘해당 문자는 특별하고, 문자 그대로 해석되면 안된다’는 사실을 가리킵니다. 예를 들어, 앞에 \\가 없는 &#39;b&#39;는 보통 소문자 b가 나오는 패턴과 대응됩니다. 그러나 &#39;\\b&#39; 자체는 어떤 문자와도 대응되지 않습니다; 이 문자는 특별한 단어 경계 문자를 형성합니다. 특수 문자 앞에 위치한 백슬래시는 ‘다음에 나오는 문자는 특별하지않고, 문자 그대로 해석되어야 한다’는 사실을 가리킵니다. 예를 들어, 패턴 /a*/ 에서의 특수문자 &#39;*&#39;는 0개 이상의 &#39;a&#39; 문자가 등장함을 나타냅니다. 이와는 다르게, 패턴 /a\\*/ 는 &#39;*&#39;이 특별하지 않다는 것을 나타내며, &#39;a*&#39;와 같은 문자열과 대응될 수 있습니다. RegExp(“pattern”) 표기를 쓰면서 \\ 자체를 이스케이프 하는 것을 잊지 마세요. 왜냐하면 \\ 는 문자열에서도 이스케이프 문자이기 때문입니다. (역주: /a\\*/ 와 같은 패턴을 생성자로 만들려면 new RegExp(&#39;a\\\\*&#39;)와 같이 백슬래시 자체를 이스케이프 시켜주어야 합니다.) ^ 입력의 시작 부분에 대응됩니다. 만약 다중행 플래그가 참으로 설정되어 있다면, 줄 바꿈 문자 바로 다음 부분과도 대응됩니다. 예를 들어, /^A/ 는 &quot;an A&quot; 의 &#39;A&#39;와는 대응되지 않습니다, 그러나 “An E” 의 ‘A’와는 대응됩니다. ‘^’ 가 문자셋([abc]) 패턴의 첫 글자로 쓰인다면, 그 때는 전혀 다른 의미를 가집니다. $입력의 끝 부분과 대응됩니다. 만약 다중행 플래그가 참으로 설정되어 있다면, 줄 바꿈 문자의 바로 앞 부분과도 대응됩니다. 예를 들어, /t$/ 는 &quot;eater&quot; 의 &#39;t&#39;에는 대응되지 않습니다, 그러나 &quot;eat&quot; 과는 대응됩니다. *앞의 표현식이 0회 이상 연속으로 반복되는 부분과 대응됩니다. {0,} 와 같은 의미입니다. 예를 들어, /bo*/ 는 &quot;A ghost booooed&quot; 의 &#39;boooo&#39; 와 대응되고, &quot;A bird warbled&quot; 의 &#39;b&#39;에 대응되지만 &quot;A goat grunted&quot; 내의 어느 부분과도 대응되지 않습니다. +앞의 표현식이 1회 이상 연속으로 반복되는 부분과 대응됩니다. {1,} 와 같은 의미입니다. 예를 들어, /a+/ 는 &quot;candy&quot;의 &#39;a&#39;에 대응되고 &quot;caaaaaaandy&quot; 의 모든 &#39;a&#39;들에 대응되지만, &quot;cndy&quot; 내의 어느 부분과도 대응되지 않습니다. ?앞의 표현식이 0 또는 1회 등장하는 부분과 대응됩니다. {0,1} 와 같은 의미입니다. 예를 들어, /e?le?/ 는 &quot;angel&quot;의 &#39;el&#39; 에 대응되고, &quot;angle&quot;의 &#39;le&#39; 에 대응되고 또한 &quot;oslo&quot; 의 &#39;l&#39;에도 대응됩니다. 만약 수량자 *, +, ?, {} 바로 뒤에 사용하면, 기본적으로 탐욕스럽던(가능한 한 많이 대응시킴) 수량자를 탐욕스럽지 않게(가능한 가장 적은 문자들에 대응시킴) 만듭니다. 예를 들어, /\\d+/를 &quot;123abc&quot;에 적용시키면 &quot;123&quot;과 대응됩니다. 그러나 /\\d+?/를 같은 문자열에 적용시키면 오직 &quot;1&quot;과만 대응됩니다. 또한 이 문자는 x(?=y) 와 x(?!y) 항목에서 설명하는 바와 같이 사전 검증(lookahead assertion)을 위해서도 쓰입니다. .개행 문자를 제외한 모든 단일 문자와 대응됩니다. 예를 들어, /.n/는 &quot;nay, an apple is on the tree&quot;에서 &#39;an&#39;과 &#39;on&#39;에 대응되지만, &#39;nay&#39; 에는 대응되지 않습니다. (x)다음의 예제가 보여주는것 처럼 &#39;x&#39;에 대응되고, 그것을 기억합니다. 괄호는 포획 괄호(capturing parentheses)라 불립니다. 패턴 /(foo) (bar) \\1 \\2/ 안의 &#39;(foo)&#39; 와 &#39;(bar)&#39;는 문자열&quot;foo bar foo bar&quot;에서 처음의 두 단어에 대응되고 이를 기억합니다. 패턴 내부의 \\1와 \\2는 문자열의 마지막 두 단어에 대응됩니다. (역주: \\n 패턴은 앞의 n번째 포획괄호에 대응된 문자열과 똑같은 문자열에 대응됩니다.) \\1, \\2, \\n과 같은 문법은 정규식의 패턴 부분에서 사용됩니다. 정규식의 치환 부분에서는 $1, $2, $n과 같은 문법이 사용되어야 합니다. 예를 들어, &#39;bar foo&#39;.replace( /(...) (...)/, &#39;$2 $1&#39;)와 같이 사용되어야 합니다. $&amp; 패턴은 앞에서 대응된 전체 문자열을 가리킵니다. (?:x)&#39;x&#39;에 대응되지만 대응된 것을 기억하지 않습니다. 괄호는 비포획 괄호(non-capturing parentheses)라고 불리우고, 정규식 연산자가 같이 동작할 수 있게 하위 표현을 정의할 수 있습니다. 정규식 예제 /(?:foo){1,2}/을 생각해보세요. 만약 정규식이 /foo{1,2}/라면, {1,2}는 &#39;foo&#39;의 마지막 &#39;o&#39; 에만 적용됩니다. 비포획 괄호과 같이 쓰인다면, {1,2}는 단어 &#39;foo&#39; 전체에 적용됩니다. x(?=y)오직 &#39;y&#39;가 뒤따라오는 &#39;x&#39;에만 대응됩니다. 이것은 lookahead 라고 불립니다. 예를 들어, /Jack(?=Sprat)/ 는 &#39;Sprat&#39;가 뒤따라오는 &#39;Jack&#39; 에만 대응됩니다. /Jack(?=Sprat|Frost)/는 &#39;Sprat&#39; 또는 &#39;Frost&#39;가 뒤따라오는 &#39;Jack&#39;에만 대응됩니다. 그러나, &#39;Sprat&#39; 및 &#39;Frost&#39; 는 대응 결과의 일부가 아닙니다. x(?!y)&#39;x&#39;뒤에 &#39;y&#39;가 없는경우에만 &#39;x&#39;에 일치합니다. 이것은 negated lookahead 라고 불립니다. 예를 들어, /\\d+(?!\\.)/는 소숫점이 뒤따라오지 않는 숫자에 일치합니다. 정규식 /\\d+(?!\\.)/.exec(&quot;3.141&quot;)는 &#39;3.141&#39; 이 아닌 &#39;141&#39;에 일치합니다. x|y&#39;x&#39; 또는 &#39;y&#39;에 대응됩니다. 예를 들어, /green|red/는 &quot;green apple&quot;의 &#39;green&#39;에 대응되고, &quot;red apple.&quot;의 &#39;red&#39;에 대응됩니다. {n}앞 표현식이 n번 나타나는 부분에 대응됩니다. n은 반드시 양의 정수여야 합니다. 예를 들어, /a{2}/는 &quot;candy,&quot;의 &#39;a&#39;에는 대응되지 않지만, &quot;caandy,&quot;의 모든 a 와, &quot;caaandy.&quot;의 첫 두 a 에는 대응됩니다. {n,m}n과 m은 양의 정수이고, n &lt;= m를 만족해야 합니다. 앞 문자가 최소 n개, 최대 m개가 나타나는 부분에 대응됩니다. m이 생략된다면, m은 ∞로 취급됩니다. 예를 들어, /a{1,3}/는 &quot;cndy&quot;에서 아무것에도 대응되지 않지만, &quot;caandy,&quot;의 첫 두 a 와 &quot;caaaaaaandy&quot;의 첫 세 a 에 대응됩니다. &quot;caaaaaaandy&quot;에서 더 많은 a 들이 있지만, &quot;aaa&quot;에만 대응된다는 점에 주목하세요. [xyz]문자셋(Character set) 입니다. 이 패턴 타입은 괄호 안의 어떤 문자(이스케이프 시퀀스까지 포함)와도 대응됩니다. 점(.) 이나 별표 (*) 같은 특수 문자는 문자셋 내부에서는 특수 문자가 아닙니다. 따라서 이스케이프시킬 필요가 없습니다. 하이픈을 이용하여 문자의 범위를 지정해줄 수 있습니다. 예를 들어, 패턴 [a-d] 는 패턴 [abcd] 와 똑같이 동작하며, &quot;brisket&quot;의 &#39;b&#39; 에 일치하고, &quot;city&quot;의 &#39;c&#39; 에 일치합니다. 패턴 /[a-z.]+/ 와 /[\\w.]+/ 는 &quot;test.i.ng&quot; 전체 문자열이 일치합니다. [^xyz]부정 문자셋(negated character set) 또는 보충 문자셋(complemented character set)입니다. 괄호 내부에 등장하지 않는 어떤 문자와도 대응됩니다. 하이픈을 이용하여 문자의 범위를 지정할 수 있습니다. 일반적인 문자셋에서 작동하는 모든 것은 여기에서도 작동합니다. 예를 들어, 패턴[^abc]는 패턴[^a-c]와 동일합니다. 두 패턴은 &quot;brisket&quot;의 &#39;r&#39;, &quot;chop.&quot;의 &#39;h&#39; 에 대응됩니다. [\\b]백스페이스(U+0008)에 대응됩니다. 이와 같이, 백스페이스 문자 리터럴에 대응시키려면, 대괄호(“[]”)를 이용해야만 합니다. (\\b와 혼동하지 마세요.) \\b단어 경계에 대응됩니다. 단어 경계는 다른 ‘단어 문자’가 앞이나 뒤에 등장하지 않는 위치에 대응됩니다. 단어의 경계는 대응 결과에 포함되지 않는다는 사실에 주의하세요. 다른 말로는, 단어의 경계에 대응되는 문자열의 길이는 항상 0입니다. (패턴 [\\b]와 혼동하지 마세요.) 예제:/\\bm/는 &quot;moon&quot;의 &#39;m&#39;에 대응됩니다;/oo\\b/ 는 &quot;moon&quot;의 &#39;oo&#39; 부분에 대응되지 않는데, 왜냐하면 &#39;oo&#39;를 뒤따라오는 &#39;n&#39;이 단어 문자이기 때문입니다;/oon\\b/는 &quot;moon&quot;의 &#39;oon&#39;에 대응됩니다. 왜냐하면, &#39;oon&#39;은 문자열의 끝이라서, 뒤따라오는 단어 문자가 없기 때문입니다 ;/\\w\\b\\w/는 어떤 것에도 일치하지 않습니다. 왜냐하면, 단어 문자는 절대로 비 단어 문자와 단어 문자 두개가 뒤따라올수 없기 때문입니다. 자바스크립트의 정규식 엔진은 특정 문자 집합을 &#39;단어 문자&#39;로 정의합니다. 이 집단에 속하지 않는 모든 문자는 단어 분리(word break) 로 여겨집니다. 단어 문자로 간주되는 문자들은 얼마 없습니다: 오로지 로마자 소문자와 대문자, 10진수 숫자, 밑줄 문자로 구성되어 있습니다. &quot;é&quot; 또는 &quot;ü&quot; 같이, 강세 표시 문자들은 안타깝게도 단어 분리(word breaks) 로 취급됩니다. \\B단어 경계가 아닌 부분에 대응됩니다. 아래와 같은 경우들이 있습니다: 문자열의 첫 번째 문자가 단어 문자가 아닌 경우, 해당 문자의 앞 부분에 대응됩니다.문자열의 마지막 문자가 단어 문자가 아닌 경우, 해당 문자의 뒷 부분에 대응됩니다.두 단어 문자의 사이에 대응됩니다.단어 문자가 아닌 두 문자 사이에 대응됩니다.빈 문자열에 대응됩니다.문자열의 시작 부분과 끝 부분은 단어가 아닌 것으로 간주됩니다. 예를 들어, /\\B../ 는 &quot;noonday&quot;의 &#39;oo&#39;와 대응되며, /y\\B./ 는 &quot;possibly yesterday.&quot;의 &#39;ye&#39;와 대응됩니다. \\cX문자열 내부의 제어 문자에 대응됩니다. 여기서 X는 A에서 Z까지의 문자 중 하나입니다. 예를 들어, /\\cM/는 문자열에서 control-M (U+000D)에 대응됩니다. \\d숫자 문자에 대응됩니다. [0-9]와 동일합니다. 예를 들어, /\\d/ 또는 /[0-9]/는 &quot;B2 is the suite number.&quot;에서 ‘2’에 대응됩니다. \\D숫자 문자가 아닌 문자에 대응됩니다. [^0-9]와 동일합니다. 예를 들어, /\\D/ 또는 /[^0-9]/는 &quot;B2 is the suite number.&quot;의 ‘B’에 대응됩니다. \\f폼피드 (U+000C) 문자에 대응됩니다. \\n줄 바꿈 (U+000A) 문자에 대응됩니다. \\r캐리지 리턴(U+000D) 문자에 대응됩니다. \\s스페이스, 탭, 폼피드, 줄 바꿈 문자등을 포함한 하나의 공백 문자에 대응됩니다. [ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff]와 동일합니다. 예를 들어, /\\s\\w*/는 &quot;foo bar.&quot;의 &#39; bar&#39;에 대응됩니다. \\S공백 문자가 아닌 하나의 문자에 대응됩니다. [^ \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff] 와 동일합니다. 예를 들어, /\\S\\w*/는 &quot;foo bar.&quot;의 &#39;foo&#39; 에 대응됩니다. \\t탭 (U+0009) 문자에 대응됩니다. \\v수직 탭(U+000B) 문자에 대응됩니다. \\w밑줄 문자를 포함한 영숫자 문자에 대응됩니다. [A-Za-z0-9_] 와 동일합니다. (역주: 여기에 대응되는 문자를 단어 문자라고 합니다.) 예를 들어, /\\w/는 &quot;apple,&quot;의 &#39;a&#39; 에 대응되고, &quot;$5.28,&quot;의 &#39;5&#39;에 대응되고,&quot;3D.&quot;의 &#39;3&#39;에 대응됩니다. \\W단어 문자가 아닌 문자에 대응됩니다. [^A-Za-z0-9_] 와 동일합니다. 예를 들어, /\\W/ 또는 /[^A-Za-z0-9_]/는 &quot;50%.&quot;의 &#39;%&#39; 에 대응됩니다. \\n정규식 내부의 n번째 괄호에서 대응된 부분에 대한 역참조 입니다. 여기서, n은 양의 정수입니다. 예를 들어, /apple(,)\\sorange\\1/는 &quot;apple, orange, cherry, peach.&quot;의 &#39;apple, orange,&#39; 에 일치합니다. \\0널 (U+0000)문자에 대응합니다. 이 때 다른 숫자를 뒤에 쓰지 마세요. 왜냐하면 \\0&lt;digits&gt;는 8진 이스케이프 시퀀스이기 때문입니다. \\xhh코드가 hh(두 16진 숫자)인 문자에 일치합니다. \\uhhhh코드가 hhhh(네개의 16진 숫자)인 문자에 일치합니다.","categories":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/categories/Web/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"http://jung-max.github.io/categories/Web/Javascript/"}],"tags":[{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/tags/Web/"},{"name":"Java Script","slug":"Java-Script","permalink":"http://jung-max.github.io/tags/Java-Script/"}]},{"title":"Android MediaPlayer","slug":"Android-MediaPlayer","date":"2019-09-25T00:42:00.000Z","updated":"2022-02-08T02:11:11.760Z","comments":true,"path":"2019/09/25/Android-MediaPlayer/","link":"","permalink":"http://jung-max.github.io/2019/09/25/Android-MediaPlayer/","excerpt":"","text":"미디어 플레이어 개요Android 멀티미디어 프레임 워크에는 다양한 일반 미디어 유형의 재생을 지원하므로 오디오, 비디오 및 이미지를 애플리케이션에 쉽게 통합 할 수 있습니다. 응용 프로그램의 리소스 (원시 리소스)에 저장된 미디어 파일, 파일 시스템의 독립형 파일 또는 네트워크 연결을 통해 도착하는 데이터 스트림에서 모두 MediaPlayer API를 사용하여 오디오 또는 비디오를 재생할 수 있습니다. 참고 : 오디오 데이터는 표준 출력 장치로만 재생할 수 있습니다. 현재는 모바일 장치 스피커 또는 Bluetooth 헤드셋입니다. 통화 중에는 대화 오디오에서 사운드 파일을 재생할 수 없습니다. 기본다음 클래스는 Android 프레임 워크에서 사운드 및 비디오를 재생하는 데 사용됩니다. MediaPlayer이 클래스는 사운드 및 비디오를 재생하기위한 기본 API입니다. AudioManager이 클래스는 장치의 오디오 소스 및 오디오 출력을 관리합니다. Manifest 선언MediaPlayer를 사용하여 응용 프로그램 개발을 시작하기 전에 매니페스트에 관련 기능을 사용할 수 있는 적절한 선언이 있는지 확인하십시오. 인터넷 권한 : MediaPlayer를 사용하여 네트워크 기반 컨텐츠를 스트리밍하는 경우 응용 프로그램은 네트워크 액세스를 요청해야합니다. 1&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; 잠금 권한 깨우기 : 플레이어 응용 프로그램에서 화면이 어두워 지거나 프로세서가 절전 모드로 전환되지 않도록하거나 MediaPlayer.setScreenOnWhilePlaying() 또는 MediaPlayer.setWakeMode() 메서드를 사용하려면이 권한을 요청해야합니다. 1&lt;uses-permission android:name=\"android.permission.WAKE_LOCK\" /&gt; MediaPlayer 사용미디어 프레임 워크의 가장 중요한 구성 요소 중 하나는 MediaPlayer 클래스입니다. 이 클래스의 객체는 최소한의 설정으로 오디오와 비디오를 모두 가져 와서 디코딩하고 재생할 수 있습니다. 다음과 같은 여러 가지 미디어 소스를 지원합니다. 지역 자원 Content Resolver에서 얻을 수있는 것과 같은 내부 URI 외부 URL (스트리밍) Android가 지원하는 미디어 형식 목록은 지원되는 미디어 형식 페이지를 참조하십시오. 다음은 응용 프로그램의 res/raw/ 디렉토리에 저장된 로컬 raw 리소스로 사용 가능한 오디오를 재생하는 방법의 예입니다. 12MediaPlayer mediaPlayer = MediaPlayer.create(context, R.raw.sound_file_1);mediaPlayer.start(); // no need to call prepare(); create() does that for you 이 경우 “raw”리소스는 시스템이 특정 방식으로 구문 분석하지 않는 파일입니다. 그러나이 리소스의 내용은 원본 오디오가 아니어야합니다. 지원되는 형식 중 하나로 올바르게 인코딩되고 형식화 된 미디어 파일이어야합니다. 다음은 시스템에서 로컬로 사용 가능한 URI(예 : Content Resolver를 통해 얻은)에서 재생하는 방법입니다. 123456Uri myUri = ....; // initialize Uri hereMediaPlayer mediaPlayer = new MediaPlayer();mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);mediaPlayer.setDataSource(getApplicationContext(), myUri);mediaPlayer.prepare();mediaPlayer.start(); HTTP 스트리밍을 통해 원격 URL에서 재생하는 방법은 다음과 같습니다. 123456String url = \"http://........\"; // your URL hereMediaPlayer mediaPlayer = new MediaPlayer();mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);mediaPlayer.setDataSource(url);mediaPlayer.prepare(); // might take long! (for buffering, etc)mediaPlayer.start(); 참고 : 온라인 미디어 파일을 스트리밍하기 위해 URL을 전달하는 경우 파일을 점진적으로 다운로드 할 수 있어야합니다. 주의 : setDataSource()를 사용하는 경우 참조하는 파일이 없을 수 있으므로 IllegalArgumentException 및 IOException을 catch하거나 pass해야합니다. 비동기 준비MediaPlayer를 사용하는 것은 원칙적으로 간단 할 수 있습니다. 그러나 일반적인 Android 애플리케이션과 올바르게 통합하려면 몇 가지 사항이 더 필요하다는 점을 명심해야합니다. 예를 들어, 미디어 데이터를 가져오고 디코딩하는 작업이 필요할 수 있으므로 prepare() 호출에 시간이 오래 걸릴 수 있습니다. 따라서 실행하는 데 시간이 오래 걸릴 수있는 메소드의 경우와 마찬가지로 애플리케이션의 UI 스레드에서 호출하지 않아야합니다. 이렇게하면 메서드가 반환 될 때까지 UI가 중단됩니다. 이는 매우 나쁜 사용자 경험이며 ANR (Application Not Responding) 오류를 일으킬 수 있습니다. 리소스가 빠르게로드 될 것으로 예상 되더라도 UI에서 응답하는 데 10 초 이상 걸리는 작업이 눈에 띄게 일시 중지되고 사용자에게 응용 프로그램 속도가 느리다는 인상을줍니다. UI 스레드를 중단하지 않으려면 다른 스레드를 생성하여 MediaPlayer를 준비하고 완료되면 기본 스레드에 알리십시오. 그러나 스레딩 로직을 직접 작성할 수는 있지만 MediaPlayer를 사용할 때이 패턴이 일반적이므로 프레임 워크는 prepareAsync() 메소드를 사용하여이 작업을 수행하는 편리한 방법을 제공합니다. 이 방법은 백그라운드에서 미디어 준비를 시작하고 즉시 돌아옵니다. 미디어 준비가 끝나면 setOnPreparedListener()를 통해 구성된 MediaPlayer.OnPreparedListener의 onPrepared() 메서드가 호출됩니다. 상태 관리명심해야 할 MediaPlayer의 또 다른 측면은 상태 기반이라는 것입니다. 즉, MediaPlayer에는 코드를 작성할 때 항상 알아야하는 내부 상태가 있습니다. 특정 작업은 플레이어가 특정 상태에있을 때만 유효하기 때문입니다. 잘못된 상태에서 작업을 수행하면 시스템에서 예외가 발생하거나 다른 바람직하지 않은 동작이 발생할 수 있습니다. MediaPlayer 클래스의 설명서는 어떤 상태에서 MediaPlayer를 다른 상태로 옮길지를 설명하는 완전한 상태 다이어그램을 보여줍니다. 예를 들어 새 MediaPlayer를 만들면 유휴 상태입니다. 이 시점에서 setDataSource()를 호출하여 초기화 상태로 가져 와서 초기화해야합니다. 그 후, 당신은 prepare() 또는 PrepareAsync() 메소드를 사용하여 그것을 준비해야합니다. MediaPlayer가 준비를 마치면 준비 됨 상태가되며 start()를 호출하여 미디어를 재생할 수 있습니다. 이 시점에서 다이어그램이 보여주는 것처럼 start(), pause() 및 seekTo()와 같은 메서드를 호출하여 Started, Paused 및 PlaybackCompleted 상태 사이를 이동할 수 있습니다. 그러나 stop()을 호출하면 MediaPlayer를 다시 준비 할 때까지 start()를 다시 호출 할 수 없습니다. MediaPlayer객체와 상호 작용하는 코드를 작성할 때는 항상 잘못된 상태에서 메소드를 호출하는 것이 버그의 원인이므로 상태 다이어그램을 명심하십시오. 미디어 플레이어 릴리즈MediaPlayer는 귀중한 시스템 리소스를 소비 할 수 있습니다. 따라서 필요 이상으로 MediaPlayer 인스턴스에 매달리지 않도록 항상 추가 예방 조치를 취해야합니다. 작업이 끝나면 항상 release()를 호출하여 할당 된 시스템 리소스가 올바르게 해제되도록해야합니다. 예를 들어, MediaPlayer를 사용 중이고 활동이 onStop()에 대한 호출을 수신하는 경우 활동이 사용자와 상호 작용하지 않는 동안 (만약 재생하지 않는 한) MediaPlayer를 보류하는 것이 의미가 없으므로 MediaPlayer를 해제해야합니다. 물론 활동이 재개되거나 다시 시작되면 재생을 다시 시작하기 전에 새 MediaPlayer를 생성하고 다시 준비해야합니다. MediaPlayer를 해제 한 다음 무효화하는 방법은 다음과 같습니다. 12mediaPlayer.release();mediaPlayer = null; 예를 들어, 활동이 중지 될 때 MediaPlayer를 해제하는 것을 잊었을 때 발생할 수있는 문제를 고려하지만 활동이 다시 시작될 때 새로 작성하십시오. 아시다시피, 사용자가 화면 방향을 변경하거나 다른 방식으로 장치 구성을 변경하면 시스템은 활동을 다시 시작하여 (기본적으로)이를 처리하므로 사용자가 회전함에 따라 모든 시스템 리소스를 빠르게 소비 할 수 있습니다. 각 방향이 바뀔 때마다 절대 해제하지 않는 새 MediaPlayer를 생성하기 때문에 세로와 가로 사이의 장치를 앞뒤로 움직입니다. 런타임 재시작에 대한 자세한 정보는 런타임 변경 처리를 참조하십시오. 사용자가 활동을 떠날 때에도 내장 음악 응용 프로그램과 같은 방식으로 “백그라운드 미디어”를 계속 재생하려면 어떻게되는지 궁금 할 것입니다. 이 경우 다음 섹션에서 설명하는 것처럼 서비스가 제어하는 MediaPlayer가 필요합니다. 서비스에서 MediaPlayer 사용응용 프로그램이 화면에없는 경우에도 백그라운드에서 미디어를 재생하려는 경우 (즉, 사용자가 다른 응용 프로그램과 상호 작용하는 동안 계속 재생하려는 경우) 서비스를 시작하고 거기서부터 MediaPlayer 인스턴스를 제어해야합니다. MediaPlayer를 MediaBrowserServiceCompat 서비스에 포함시키고 다른 활동에서 MediaBrowserCompat와 상호 작용하도록해야합니다. 이 클라이언트 / 서버 설정에주의해야합니다. 백그라운드 서비스에서 실행중인 플레이어가 나머지 시스템과 상호 작용하는 방식에 대한 기대가 있습니다. 응용 프로그램이 이러한 기대치를 충족하지 못하면 사용자에게 좋지 않은 경험이있을 수 있습니다. 자세한 내용은 오디오 앱 빌드를 참조하십시오. 이 섹션에서는 서비스 내부에서 구현 될 때 MediaPlayer를 관리하기위한 특별 지침에 대해 설명합니다. 비동기 적으로 실행우선 Activity와 마찬가지로 서비스의 모든 작업은 기본적으로 단일 스레드에서 수행됩니다. 사실, 동일한 애플리케이션에서 활동 및 서비스를 실행하는 경우 기본적으로 동일한 스레드 (“메인 스레드”)를 사용합니다. 따라서 서비스는 들어오는 의도를 신속하게 처리해야하며 응답 할 때 긴 계산을 수행하지 않아야합니다. 과도한 작업이나 호출 차단이 예상되는 경우 직접 구현하는 다른 스레드에서 또는 비동기 처리를 위해 프레임 워크의 많은 기능을 사용하여 이러한 작업을 비동기 적으로 수행해야합니다. 예를 들어, 메인 스레드에서 MediaPlayer를 사용하는 경우, 준비가 완료되고 재생을 시작할 수 있도록 알림을 받으려면 Prepare()가 아니라 PrepareAsync()를 호출하고 MediaPlayer.OnPreparedListener를 구현해야합니다. 예를 들면 다음과 같습니다. 123456789101112131415161718public class MyService extends Service implements MediaPlayer.OnPreparedListener &#123; private static final String ACTION_PLAY = \"com.example.action.PLAY\"; MediaPlayer mediaPlayer = null; public int onStartCommand(Intent intent, int flags, int startId) &#123; ... if (intent.getAction().equals(ACTION_PLAY)) &#123; mediaPlayer = ... // initialize it here mediaPlayer.setOnPreparedListener(this); mediaPlayer.prepareAsync(); // prepare async to not block main thread &#125; &#125; /** Called when MediaPlayer is ready */ public void onPrepared(MediaPlayer player) &#123; player.start(); &#125;&#125; 비동기 오류 처리동기 작업의 경우 일반적으로 예외 또는 오류 코드와 함께 오류가 발생하지만 비동기 리소스를 사용할 때마다 응용 프로그램에 오류에 대한 적절한 알림이 표시되어야합니다. MediaPlayer의 경우 MediaPlayer.OnErrorListener를 구현하고 MediaPlayer 인스턴스에서 설정하여이를 수행 할 수 있습니다. 1234567891011121314public class MyService extends Service implements MediaPlayer.OnErrorListener &#123; MediaPlayer mediaPlayer; public void initMediaPlayer() &#123; // ...initialize the MediaPlayer here... mediaPlayer.setOnErrorListener(this); &#125; @Override public boolean onError(MediaPlayer mp, int what, int extra) &#123; // ... react appropriately ... // The MediaPlayer has moved to the Error state, must be reset! &#125;&#125; 오류가 발생하면 MediaPlayer가 오류 상태로 이동하고 (전체 상태 다이어그램은 MediaPlayer 클래스의 설명서 참조) 다시 사용하기 전에 재설정해야합니다. 깨우기 잠금 사용백그라운드에서 미디어를 재생하는 응용 프로그램을 디자인 할 때 서비스가 실행되는 동안 장치가 절전 모드로 전환 될 수 있습니다. Android 시스템은 기기가 절전 모드 일 때 배터리 절약을 시도하기 때문에 시스템은 CPU 및 WiFi 하드웨어를 포함하여 필요하지 않은 전화기 기능을 종료하려고합니다. 그러나 서비스가 음악을 재생하거나 스트리밍하는 경우 시스템이 재생을 방해하지 못하게하려고합니다. 이러한 조건에서 서비스가 계속 실행되도록하려면 “깨우기 잠금”을 사용해야합니다. 깨우기 잠금은 전화가 유휴 상태 인 경우에도 응용 프로그램에서 사용 가능한 일부 기능을 사용하고 있음을 시스템에 알리는 방법입니다. 참고 : 항상 잠금 장치를 사용하지 말고 장치의 배터리 수명을 크게 단축 시키므로 꼭 필요한만큼만 잡아야합니다. MediaPlayer가 재생되는 동안 CPU가 계속 실행되도록하려면 MediaPlayer를 초기화 할 때 setWakeMode() 메서드를 호출하십시오. 그렇게하면 MediaPlayer는 재생하는 동안 지정된 잠금을 유지하고 일시 중지 또는 중지되면 잠금을 해제합니다. 123mediaPlayer = new MediaPlayer();// ... other initialization here ...mediaPlayer.setWakeMode(getApplicationContext(), PowerManager.PARTIAL_WAKE_LOCK); 그러나이 위 예제에서 얻은 깨우기 잠금은 CPU가 깨어있는 상태 만 보장합니다. 네트워크를 통해 미디어를 스트리밍하고 Wi-Fi를 사용하는 경우 WifiLock도 잡고 싶을 것입니다. WifiLock은 수동으로 획득하여 해제해야합니다. 따라서 원격 URL을 사용하여 MediaPlayer를 준비하기 시작하면 Wi-Fi 잠금을 생성하고 획득해야합니다. 예를 들면 다음과 같습니다. 1234WifiLock wifiLock = ((WifiManager) getSystemService(Context.WIFI_SERVICE)) .createWifiLock(WifiManager.WIFI_MODE_FULL, \"mylock\");wifiLock.acquire(); 미디어를 일시 중지 또는 중지하거나 더 이상 네트워크가 필요하지 않은 경우 잠금을 해제해야합니다. 1wifiLock.release(); 정리 수행앞에서 언급했듯이 MediaPlayer 객체는 상당한 양의 시스템 리소스를 소비 할 수 있으므로 필요한만큼만 유지하고 작업이 끝나면 release()를 호출해야합니다. 가비지 수집기가 MediaPlayer를 회수하기까지 시간이 걸릴 수 있기 때문에 시스템 가비지 수집에 의존하지 않고이 정리 방법을 명시 적으로 호출하는 것이 중요합니다. 메모리 요구에만 민감하고 다른 미디어 관련 리소스가 부족하지 않기 때문입니다. 따라서 서비스를 사용하는 경우 항상 onDestroy() 메서드를 재정 의하여 MediaPlayer를 릴리스해야합니다. 12345678910public class MyService extends Service &#123; MediaPlayer mediaPlayer; // ... @Override public void onDestroy() &#123; super.onDestroy() if (mediaPlayer != null) mediaPlayer.release(); &#125;&#125; 종료 할 때 미디어 플레이어를 해제하는 것 외에 항상 미디어 플레이어를 릴리스 할 수있는 다른 기회를 찾아야합니다. 예를 들어, 오디오 포커스를 잃은 후 오랫동안 미디어를 재생할 수 없을 것으로 예상되는 경우 기존 MediaPlayer를 확실히 해제했다가 나중에 다시 만들어야합니다. 반면에 아주 짧은 시간 동안 만 재생을 중단 할 것으로 예상되는 경우 MediaPlayer를 다시 작성하여 다시 준비해야하는 오버 헤드를 피하기 위해 MediaPlayer를 기다려야합니다. 디지털 권한 관리 (DRM)Android 8.0 (API 레벨 26)부터 MediaPlayer에는 DRM으로 보호되는 자료의 재생을 지원하는 API가 포함되어 있습니다. MediaDrm에서 제공하는 저수준 API와 비슷하지만 더 높은 수준에서 작동하며 기본 추출기, drm 및 암호화 개체를 노출하지 않습니다. MediaPlayer DRM API는 MediaDrm의 모든 기능을 제공하지는 않지만 가장 일반적인 사용 사례를 지원합니다. 현재 구현은 다음 컨텐츠 유형을 처리 할 수 있습니다. Widevine으로 보호되는 로컬 미디어 파일 광범위하게 보호되는 원격 / 스트리밍 미디어 파일 다음 코드 스 니펫은 간단한 동기 구현에서 새 DRM MediaPlayer 메소드를 사용하는 방법을 보여줍니다. DRM 제어 미디어를 관리하려면 다음과 같이 일반적인 MediaPlayer 호출 흐름과 함께 새로운 방법을 포함해야합니다. 1234567891011121314setDataSource();setOnDrmConfigHelper(); // optional, for custom configurationprepare();if (getDrmInfo() != null) &#123; prepareDrm(); getKeyRequest(); provideKeyResponse();&#125;// MediaPlayer is now ready to usestart();// ...play/pause/resume...stop();releaseDrm(); 평소와 같이 MediaPlayer 객체를 초기화하고 setDataSource()를 사용하여 소스를 설정하여 시작합니다. 그런 다음 DRM을 사용하려면 다음 단계를 수행하십시오. 앱이 사용자 지정 구성을 수행하도록하려면 OnDrmConfigHelper 인터페이스를 정의하고 setOnDrmConfigHelper()를 사용하여 플레이어에 연결하십시오. prepare()를 호출하십시오. getDrmInfo()를 호출하십시오. 소스에 DRM 내용이 있으면이 메서드는 null이 아닌 MediaPlayer.DrmInfo 값을 반환합니다. MediaPlayer.DrmInfo가 존재하는 경우 : 사용 가능한 UUID의 맵을 검사하고 하나를 선택하십시오. PrepareDrm()을 호출하여 현재 소스에 대한 DRM 구성을 준비하십시오. OnDrmConfigHelper 콜백을 작성하고 등록한 경우, PrepareDrm()이 실행되는 동안 호출됩니다. 이를 통해 DRM 세션을 열기 전에 DRM 속성의 사용자 지정 구성을 수행 할 수 있습니다. 콜백은 PrepareDrm()을 호출 한 스레드에서 동 기적으로 호출됩니다. DRM 특성에 액세스하려면 getDrmPropertyString() 및 setDrmPropertyString()을 호출하십시오. 긴 작업을 수행하지 마십시오. 장치가 아직 준비되지 않은 경우, PrepareDrm()은 프로비저닝 서버에 액세스하여 장치를 공급합니다. 네트워크 연결에 따라 시간이 달라질 수 있습니다. 라이센스 키로 보낼 불투명 한 키 요청 바이트 배열을 얻으려면 getKeyRequest()를 호출하십시오. 라이센스 서버로부터받은 키 응답에 대해 DRM 엔진에 알리려면 provideKeyResponse()를 호출하십시오. 결과는 키 요청 유형에 따라 다릅니다. 응답이 오프라인 키 요청에 대한 것이라면 결과는 키 세트 식별자입니다. 이 키 세트 ID를 restoreKeys()와 함께 사용하여 키를 새 세션으로 복원 할 수 있습니다. 응답이 스트리밍 또는 릴리스 요청에 대한 경우 결과는 널입니다. PrepareDrm()을 비동기 적으로 실행기본적으로 PrepareDrm()은 동기적으로 실행되어 준비가 완료 될 때까지 차단됩니다. 그러나 새 장치에서 처음으로 DRM을 준비하는 경우 공급을 요구할 수도 있는데, 이는 PrepareDrm()에 의해 내부적으로 처리되며 관련된 네트워크 작업으로 인해 완료하는 데 시간이 걸릴 수 있습니다. MediaPlayer.OnDrmPreparedListener를 정의하고 설정하여 PrepareDrm()에서 블로킹을 피할 수 있습니다. OnDrmPreparedListener를 설정하면 PrepareDrm()은 백그라운드에서 프로비저닝 (필요한 경우) 및 준비를 수행합니다. 프로비저닝 및 준비가 완료되면 리스너가 호출됩니다. 리스너가 핸들러 스레드에 등록되지 않은 경우 호출 시퀀스 또는 리스너가 실행되는 스레드에 대해 가정해서는 안됩니다. 리스너는 prepareDrm()이 리턴되기 전 또는 후에 호출 될 수 있습니다. 비동기 적으로 DRM 설정DRM 준비를 위해 MediaPlayer.OnDrmInfoListener를 생성하고 등록하여 플레이어를 시작하여 MediaPlayer.OnDrmPreparedListener를 비동기 적으로 초기화 할 수 있습니다. 아래 그림과 같이 prepareAsync()와 함께 작동합니다. 1234567891011121314151617181920setOnPreparedListener();setOnDrmInfoListener();setDataSource();prepareAsync();// ...// If the data source content is protected you receive a call to the onDrmInfo() callback.onDrmInfo() &#123; prepareDrm(); getKeyRequest(); provideKeyResponse();&#125;// When prepareAsync() finishes, you receive a call to the onPrepared() callback.// If there is a DRM, onDrmInfo() sets it up before executing this callback,// so you can start the player.onPrepared() &#123;start();&#125; 암호화 된 미디어 처리Android 8.0 (API 레벨 26)부터 MediaPlayer는 기본 스트림 유형 H.264 및 AAC에 대해 CENC (Common Encryption Scheme) 및 HLS 샘플 레벨 암호화 미디어 (METHOD = SAMPLE-AES)를 해독 할 수 있습니다. 전체 세그먼트 암호화 미디어 (METHOD = AES-128)는 이전에 지원되었습니다. ContentResolver에서 미디어 검색미디어 플레이어 응용 프로그램에 유용 할 수있는 또 다른 기능은 사용자가 장치에서 가지고있는 음악을 검색하는 기능입니다. 외부 미디어에 대해 ContentResolver를 쿼리하여이를 수행 할 수 있습니다. 12345678910111213141516ContentResolver contentResolver = getContentResolver();Uri uri = android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;Cursor cursor = contentResolver.query(uri, null, null, null, null);if (cursor == null) &#123; // query failed, handle error.&#125; else if (!cursor.moveToFirst()) &#123; // no media on the device&#125; else &#123; int titleColumn = cursor.getColumnIndex(android.provider.MediaStore.Audio.Media.TITLE); int idColumn = cursor.getColumnIndex(android.provider.MediaStore.Audio.Media._ID); do &#123; long thisId = cursor.getLong(idColumn); String thisTitle = cursor.getString(titleColumn); // ...process entry... &#125; while (cursor.moveToNext());&#125; 이것을 MediaPlayer와 함께 사용하려면 다음을 수행하십시오. 123456789long id = /* retrieve it from somewhere */;Uri contentUri = ContentUris.withAppendedId( android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id);mediaPlayer = new MediaPlayer();mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);mediaPlayer.setDataSource(getApplicationContext(), contentUri);// ...prepare and start...","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"MediaPlayer","slug":"Android/MediaPlayer","permalink":"http://jung-max.github.io/categories/Android/MediaPlayer/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"MediaPlayer","slug":"MediaPlayer","permalink":"http://jung-max.github.io/tags/MediaPlayer/"}]},{"title":"마크다운과 마크다운 문법 설명","slug":"Github-Pages-마크다운","date":"2019-09-19T01:55:00.000Z","updated":"2022-02-08T02:11:11.810Z","comments":true,"path":"2019/09/19/Github-Pages-마크다운/","link":"","permalink":"http://jung-max.github.io/2019/09/19/Github-Pages-마크다운/","excerpt":"","text":"❤이모티콘 사이트🎆(복사해서 쓰세요) 1. 마크다운에 관하여1.1. 마크다운이란?Markdown은 텍스트 기반의 마크업언어로 2004년 존그루버에 의해 만들어졌으며 쉽게 쓰고 읽을 수 있으며 HTML로 변환이 가능하다. 특수기호와 문자를 이용한 매우 간단한 구조의 문법을 사용하여 웹에서도 보다 빠르게 컨텐츠를 작성하고 보다 직관적으로 인식할 수 있다.마크다운이 최근 각광받기 시작한 이유는 깃헙(https://github.com) 덕분이다. 깃헙의 저장소Repository에 관한 정보를 기록하는 README.md는 깃헙을 사용하는 사람이라면 누구나 가장 먼저 접하게 되는 마크다운 문서였다. 마크다운을 통해서 설치방법, 소스코드 설명, 이슈 등을 간단하게 기록하고 가독성을 높일 수 있다는 강점이 부각되면서 점점 여러 곳으로 퍼져가게 된다. 1.2. 마크다운의 장-단점1.2.1. 장점1. 간결하다. 2. 별도의 도구없이 작성가능하다. 3. 다양한 형태로 변환이 가능하다. 3. 텍스트(Text)로 저장되기 때문에 용량이 적어 보관이 용이하다. 4. 텍스트파일이기 때문에 버전관리시스템을 이용하여 변경이력을 관리할 수 있다. 5. 지원하는 프로그램과 플랫폼이 다양하다.1.2.2. 단점1. 표준이 없다. 2. 표준이 없기 때문에 도구에 따라서 변환방식이나 생성물이 다르다. 3. 모든 HTML 마크업을 대신하지 못한다. 2. 마크다운 사용법(문법)2.1. 헤더Headers 큰제목: 문서 제목 12This is an H1============= This is an H1 작은제목: 문서 부제목 12This is an H2------------- This is an H2 글머리: 1~6까지만 지원 123456# This is a H1## This is a H2### This is a H3#### This is a H4##### This is a H5###### This is a H6 This is a H1This is a H2This is a H3This is a H4This is a H5This is a H6####### This is a 7. 2.2. BlockQuote이메일에서 사용하는 &gt; 블럭인용문자를 이용한다. 1&gt; This is a blockqute. This is a first blockqute. This is a second blockqute. This is a third blockqute. 이 안에서는 다른 마크다운 요소를 포함할 수 있다. This is a H3 List 12&gt; code&gt; 2.3. 목록● 순서있는 목록(번호)순서있는 목록은 숫자와 점을 사용한다. 1231. 첫번째2. 두번째3. 세번째 첫번째 두번째 세번째 현재까지는 어떤 번호를 입력해도 순서는 내림차순으로 정의된다. 1231. 첫번째3. 세번째2. 두번째 첫번째 세번째 두번째 딱히 개선될 것 같지는 않다. 존 그루버가 신경안쓰고 있다고… ● 순서없는 목록(글머리 기호)1234567891011* 빨강 * 녹색 * 파랑+ 빨강 + 녹색 + 파랑- 빨강 - 녹색 - 파랑 빨강 녹색 파랑 빨강 녹색 파랑 빨강 녹색 파랑 혼합해서 사용하는 것도 가능하다(내가 선호하는 방식) 1234* 1단계 - 2단계 + 3단계 = 4단계 1단계 2단계 3단계 = 4단계 2.4. 코드1234개의 공백 또는 하나의 탭으로 들여쓰기를 만나면 변환되기 시작하여 들여쓰지 않은 행을 만날때까지 변환이 계속된다.&gt; 한줄 띄어쓰면 인식이 제대로 안되는 문제가 발생하곤 합니다.This is a normal paragraph: This is a code block.end code block. 12&lt;code&gt; This is a normal paragraph: This is a code block.end code block. 123456789&lt;/code&gt;실제로 적용해보면,This is a normal paragraph: This is a code block.end code block.## 2.5. 수평선```&lt;hr/&gt; 아래 줄은 모두 수평선을 만든다. 마크다운 문서를 미리보기로 출력할 때 페이지 나누기 용도로 많이 사용한다. 123456789* * *********- - ---------------------------------------- 2.6. 링크 참조링크 12345[link keyword][id][id]: URL &quot;Optional Title here&quot;Link: [Google][googlelink][googlelink]: https://google.com &quot;Go google&quot; Link: [Google][googlelink][googlelink]: https://google.com “Go google” 인라인 링크1syntax: [Title](link) Link: Google 자동연결12&lt;http://example.com/&gt;&lt;address@example.com&gt; http://example.com/&#x61;&#x64;&#x64;&#x72;&#101;&#x73;&#115;&#x40;&#x65;&#120;&#x61;&#x6d;&#112;&#x6c;&#101;&#46;&#x63;&#x6f;&#109; 2.7. 강조123456*single asterisks*_single underscores_**double asterisks**__double underscores__++underline++~~cancelline~~ single asteriskssingle underscoresdouble asterisksdouble underscores++underline++cancelline 2.8. 이미지12![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 사이즈 조절 기능은 없기 때문에 &lt;img width=&quot;&quot; height=&quot;&quot;&gt;&lt;/img&gt;를 이용한다. 3. 마크다운 사용기3.1. 이지윅(WSYWIG) 에디터우리가 흔하게 접하는 웹에서 사용되는 에디터(네이버, 다음, 구글 등)이 대부분 이지웍 에디터에 속하며 기본적으로 HTML을 이용하여 스타일을 적용하여 문장을 꾸미는 형태를 취하게 된다. 그래서 하루패드와 같은 마크다운 에디터의 View 영역의 내용을 복사하여 붙여넣기를 하면 대체적으로 View영역에서 보이는 그대로 복사되는 편이다. 다만, 붙여넣기 이후에 문장들을 수정하려고 할 떄 문제가 되는데, 이는 스타일이 포함된 태그가 수정과정에서 변형되면서 전체적인 영향을 끼치는 탓이다. 티스토리 블로그에서는 쉽지 않고… 워드프레스의 경우에는 마크다운으로 작성된 포스트를 HTML로 변환해주는 기능을 활용하는 것이 좋다.결론은, 복사해서 붙여넣기하면 가급적이면 본문은 수정하지 않는 것이 좋다. 3.2. 깃헙Github, 비트버킷Bitbucket과 요비Yobi 등최근 유행하는 협업개발플랫폼의 경우에는 마크다운을 변환하는 컨버터 기능을 기본탑재하고 있기 때문에 마크다운 문법으로 작성한 텍스트를 그대로 복사해서 붙여넣거나 업로드하는 것만으로 마크다운의 적용이 가능하다. 3.3. MS워드 적용View 영역의 항목을 그대로 붙여넣거나 HTML 내보내기 등으로 생성한 파일을 불러오는 형태로 사용가능하다. 적용한 헤더를 워드가 읽어드리면서 목차에 적용하기 때문에 이를 활용하면 목차까지도 손쉽게 적용이 가능해진다. 4. 정리마크다운은 기본문법만 알고 있다면 일반 텍스트편집기에서도 손쉽게 작성이 가능한 마크업언어다. 현재 다양한 도구와 플랫폼에서 지원하고 있기 때문에 더욱 손쉽게 스타일적용된 문서를 작성할 수 있기 때문에 점점 널리 사용되고 있다. 마크다운을 이해하고 사용하면서 쉽고 빠르게 스타일문서를 작성해보세요.저는 Dropbox 프로를 구매해서 집-랩탑-스마트폰이 각각 연동을 시켜서 사용하고 있습니다. 드랍박스에 저장된 마크다운 문서는 Dropbox 웹서비스 상에서 제공하기 때문에 웹상에서 바로 열람할 수도 있어 링크를 걸어서 다른 사람과 공유하는 형식으로 사용하고 있다. 링크 예: Markdown 설명 5. 색깔 넣기&lt;span style=&quot;color:blue&quot;&gt;some *This is Blue italic.* text&lt;/span&gt;some This is Blue italic. text 6. Table of Contents(TOC) GitLab wiki용: [[_TOC_]] GitHub Wiki TOC generator ○ 참고문서 78 Tools for writing and previewing Markdown John gruber 마크다운 번역 깃허브 취향의 마크다운 번역 허니몬의 마크다운 작성법","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"Markdown","slug":"기타/Markdown","permalink":"http://jung-max.github.io/categories/기타/Markdown/"}],"tags":[{"name":"Github Pages","slug":"Github-Pages","permalink":"http://jung-max.github.io/tags/Github-Pages/"},{"name":"Markdown","slug":"Markdown","permalink":"http://jung-max.github.io/tags/Markdown/"},{"name":"마크다운","slug":"마크다운","permalink":"http://jung-max.github.io/tags/마크다운/"},{"name":"마크다운 문법","slug":"마크다운-문법","permalink":"http://jung-max.github.io/tags/마크다운-문법/"}]},{"title":"Github Pages Hexo 검색엔진최적화(SEO)","slug":"Github-Pages-Hexo-검색엔진최적화","date":"2019-09-17T05:44:00.000Z","updated":"2022-02-08T02:11:11.800Z","comments":true,"path":"2019/09/17/Github-Pages-Hexo-검색엔진최적화/","link":"","permalink":"http://jung-max.github.io/2019/09/17/Github-Pages-Hexo-검색엔진최적화/","excerpt":"","text":"블로그 등을 운영하면서 나의 게시물이 검색엔진에 잘 노출되기 위해서는 몇가지 선행조건이 필요합니다. 크게 네이버와 구글, 다음에 등록하시는 것을 추천합니다. 네이버 웹마스터 도구 구글 Search Console 다음 검색등록 위 사이트에 등록을 잘하기 위해서는 몇가지 도구들이 필요합니다. 이를 위한 hexo 플러그인을 소개합니다. hexo-autonofollow해당 포스트에서 참고하고 있는 외부 링크에 nofollow 속성을 자동으로 추가해주는 플러그인입니다. 먼저 nofollow 속성이 무엇이고 왜 추가해야하는지 알아보겠습니다. nofollow특정 페이지의 링크를 추적하지 않도록 하거나 특정 링크의 추적을 막을때 nofollow 속성값을 사용 할 수 있습니다. 검색엔진마다 nofollow 속성을 처리하는 방식이 다를 수 있습니다. 이 페이지의 링크를 추적하지 않도록 설정할때 : 1&lt;meta name=\"robots\" content=\"nofollow\" /&gt; 특정 링크의 추적을 하지 않도록 설정할때 : 1&lt;a href=\"http://www.test.com/\" rel=\"nofollow\"&gt;링크&lt;/a&gt; 보통 신뢰할 수 없는 콘텐츠나 유료 링크의 경우 다른 사용자의 검색에 노출되지 않아야 하므로 nofollow 속성을 사용하는 것이 좋습니다. 기능 모든 외부 링크에 rel=”external nofollow” 속성을 자동으로 추가합니다. 외부링크에만 동작하기 때문에 본인 사이트의 도메인 링크는 제외됩니다. 외부 링크에 target=”_blank” 속성을 넣어서 클릭할 경우 새로운 탭 또는 윈도우에서 열리게 합니다. 설치1$ npm install hexo-autonofollow --save 옵션_config.yml 12345nofollow: enable: true exclude: - exclude1.com - exclude2.com 옵션 설명 enable 플러그인 활성화 exclude 제외할 호스트 hexo-generator-robotstxt robots.txt 문서는 일반 사용자 분들이나 사이트를 제작한지 얼마 안되신 분들에게는 아마 생소한 문서 이실겁니다. 무엇을 하고 이게 왜 필요 한지에 대해서도 모르실것이구요. 구글이나 위키백과 같은 곳에서는 다음과 같이 정의 하고 있습니다. robots.txt 파일은 사이트의 루트에 위치하며 사이트에서 검색 엔진 크롤러가 액세스하지 않기를 바라는부분을 표시합니다. 파일에서는 로봇 배제 표준 프로토콜의 명령을 사용하여 섹션별, 웹 크롤러 종류별(모바일 크롤러, 데스크톱 크롤러 등)로 사이트에 대한 액세스 권한을 표시합니다. 출처 : 구글(https://support.google.com/webmasters/answer/6062608?hl=ko) 간단하게 말하자만 내 사이트에서 포털사이트(검색엔진)의 로봇이 가져가도 괜찮다고 허락하는 부분과 가져가면 안된다 라는 설정을 하는 부분이라고 보시면 됩니다. robots.txt 문서를 작성하는데 있어서 중요한 3가지 키워드가 있습니다. User-agent / Disallow / Allow 위에 보시는 3가지 입니다. 각각의 의미하는 내용은 아래와 같습니다. User-agent : 다음 규칙이 적용되는 로봇의 이름 Disallow : 차단할 URL 경로 Allow : 차단 된 상위 디렉토리의 하위 디렉토리에있는 URL 경로이며 차단 해제 할 디렉토리 hexo-generator-robotstxt는 이 robots.txt를 자동으로 생성해 줍니다. 설치1$ npm install hexo-generator-robotstxt --save 옵션_config.yml 1234567891011121314plugins:- hexo-generator-robotstxtrobotstxt: useragent: \"*\" disallow: - /one_file_to_disallow.html - /2nd_file_to_disallow.html - /3rd_file_to_disallow.html allow: - /one_file_to_allow.html - /2nd_file_to_allow.html - /3rd_file_to_allow.html sitemap: /sitemap.xml 옵션 설명 useragent 다음 규칙이 적용되는 로봇의 이름 disallow 차단할 URL 경로 allow 차단 된 상위 디렉토리의 하위 디렉토리에있는 URL 경로이며 차단 해제 할 디렉토리 sitemap sitemap의 경로 hexo-auto-canonical &lt;meta&gt; 태그 중 canonical 속성은 대표 URL (선호 URL) 을 나타냅니다. 동일 콘텐츠를 여러개의 URL로 표현이 가능할 경우 가장 선호되는 대표 URL을 지정하는 것이 바로 대표 URL 입니다. 중복되거나 비슷한 콘텐츠에 대한 링크를 통합해서 같은 주제에 통계를 내기가 쉽고 사용자가 검색을 통해 페이지에 방문하기에 유리합니다. hexo-auto-canonical를 사용하면 자동으로 각 포스트마다 canonical을 넣어줍니다. 설치1$ npm install hexo-auto-canonical --save 사용법이제 태그 안에 대표 URL 속성을 집어넣어야합니다. head.ejs 안에 다음 코드를 넣으면 generate 할 때 코드를 생성해줍니다. 파일 중간 쯤에 &lt;%- meta(page) %&gt; 라고 있는데 그 바로 아래 붙여넣으시면 됩니다. 1&lt;%- autoCanonical(config, page) %&gt; hexo-generator-seo-friendly-sitemap sitemap이란 홈페이지에 있는 정보가 어떻게 설계되어 있는지를 표준화된 규칙으로 작성한 xml 파일을 말합니다. 검색엔진(크롤러)가 복잡한 홈페이지에서 길을 잃지 않게 도와주는 동반자 역활을 합니다. sitemap.xml을 자동으로 만들어주는 플러그인을 알아보겠습니다. 설치1$ npm install hexo-generator-seo-friendly-sitemap --save 사용법_config.yml 123# sitemap auto generatorsitemap: path: sitemap.xml path 값을 sitemap.xml 이라고 지정했기 때문에 root 폴더에 sitemap.xml 이 생성됩니다. hexo-generator-feed RSS feed 는 사이트내의 최신 콘텐츠를 담고 있는 파일입니다. 등록한 사이트에서 새 글이 올라오면 바로 읽을 수 있는 RSS feed Reader 를 생각해보시면 되겠습니다. 이 또한 검색엔진에 제출할 수 있습니다. RSS를 자동으로 만들어주는 플러그인을 알아보겠습니다. 설치1$ npm install hexo-generator-feed --save 사용법_config.yml 123456# rss feed auto generatorfeed: type: rss2 path: feed.xml limit: 20 hub: 옵션 설명 type feed 타입 설정 (atom/rss2) path feed 파일을 저장할 경로 (기본값 atom.xml/rss2.xml) limit 최신 포스트의 갯수 설정. (0 또는 false 입력 시 전체 포스트) root 경로에 feed.xml 이 생긴 것을 확인하실 수 있습니다. 네이버 웹마스터 도구는 atom을 신식하지 못하기 때문에 rss2 type으로 설정하시는 것이 좋습니다.(구글 서치 콘솔은 atom도 인식합니다.)","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"GitHub Pages","slug":"기타/GitHub-Pages","permalink":"http://jung-max.github.io/categories/기타/GitHub-Pages/"}],"tags":[{"name":"Github Pages","slug":"Github-Pages","permalink":"http://jung-max.github.io/tags/Github-Pages/"},{"name":"Hexo","slug":"Hexo","permalink":"http://jung-max.github.io/tags/Hexo/"}]},{"title":"SEAndroid 적용","slug":"Android-SEAndroid적용","date":"2019-09-16T06:40:00.000Z","updated":"2022-02-08T02:11:11.778Z","comments":true,"path":"2019/09/16/Android-SEAndroid적용/","link":"","permalink":"http://jung-max.github.io/2019/09/16/Android-SEAndroid적용/","excerpt":"","text":"SEAndroid(Security Enhancements for Android)SEAndroid는 Android를 지원하기 위해 SELinux를 확장/개선한 보안기능이며 권한이 있는 시스템관리자만 변경할 수 있도록 지원해 줍니다. SELinux(Security-Enhanced Linux)란 Open Source인 Linux에 추가된 MAC(Mandatory Access Control)을 의미합니다. Access Control관련 보안 정책(Security Policy)을 포함합니다. 보안정책에 맞춰 Android Module을 추가해야 하며 관련 파일이 없거나 잘못 작성된 경우 Booting시 실행이 안되거나 다른 Module로 접근이 안되거나 기능을 사용하지 못하게 됩니다. SEAndroid의 보안라벨의 흐름은 크게 5가지로 구분됩니다. 첫째는 Service 실행을 위한 보안라벨입니다. 둘째는 Binder기반 서비스의 경우 Service Manager에 등록을 허락받기 위한 보안라벨입니다. 셋째는 Booting시 Property 실행을 위한 보안라벨입니다. 넷째는 Device driver 사용 허락을 위한 보안라벨입니다. 마지막으로 Untrusted application(등록되지 않은 앱)에 관련된 보안라벨 설정입니다. 아래에서 하나씩 각 설정에 관련되서 살펴보겠습니다. ①Service 실행SEAndroid는 Android 4.4부터 추가된 보안 관련 Module이며 버전이 올라갈수록 보안관련 정책이 엄격해지고 있습니다. Android 6.x(Marshmallow)이후에 추가되는 Service의 경우 관련파일이 없거나 잘못 작성된 경우 Booting시 실행이 안됩니다. ~Android 6.x는 external/sepolicy 또는 device/.../sepolicy에 xxx.te 파일을 추가하면 보안정책에 맟춰 실행이 가능합니다. Android 7.x~는 system/sepolicy에 xxx.te 파일을 추가하면 보안정책에 맟춰 실행이 가능합니다. 같은 경로에 있는 file_contexts 파일에도 항목을 추가해야 합니다. 서비스 실행을 위해서는 서비스 관련 보안라벨(그림에서는 devtest.te)와 file_contexts에 관련 내용 추가가 필요합니다. ②Binder 기반 Service(Service Manager에 등록 가능)실행되는 Service가 Binder기반의 Service인 경우 xxx.te 파일에 추가적인 항목이 더 들어가야 합니다. ~Android 6.x는 external/sepolicy 또는 device/.../sepolicy에 service.te에도 항목 추가가 필요합니다. Android 7.x~는 system/sepolicy에 service.te에도 항목 추가가 필요합니다. Binder 기반서비스 실행을 위해서는 Service Manger에 등록이 필요합니다. 이를 위해서 서비스 관련 보안라벨(그림에서는 devtest.te)와 서비스 매니저 관련 보안라벨(servicervice_contextsce.te), file_contexts에 관련 내용 추가가 필요합니다. ③Property를 사용한 Service제어Booting시 실행이 안되는 Service의 경우 Property를 사용하여 제어(Start/Stop 등)하는 것이 가능합니다. Default값을 사용할 수도 있지만 property 값을 새로 지정해서 사용하는 것도 가능합니다. 보안정책(Security Policy)관련 설정이 없는 경우에는 실행이 불가능 합니다. Property를 사용한 Service제어에 관련된 보안 정책(Security Policy)관련 설정 파일은 다음과 같습니다. ~Android 6.x는 external/sepolicy 또는 device/.../sepolicy에 xxx.te Android 7.x~는 system/sepolicy에 service.te에 xxx.te 수정이 필요한 xxx.te는 surfaceflinger의 예를 들어보면 surfaceflinger.te property_contexts property.te 가 수정이 필요합니다. Property를 사용한 Service제어 실행을 위해서는 서비스 관련 보안라벨(그림에서는 surfaceflinger.te)와 property 관련 보안라벨(property.te), property_contexts에 관련 내용 추가가 필요합니다. ④Device Driver 사용SEAndroid가 설정된 경우 Device Driver를 사용하기 위해서는 보안라벨을 사용해 허락을 받는 것이 필요합니다. 먼저 device driver를 접근하기 위한 흐름은 아래와 그림과 같습니다. 먼저 APP(devtest_server)에서 HAL module에 장치 제어를 요청합니다. HAL module은 systemCall을 사용해서 Device Driver(Kernel)에 접근합니다. 이때 장치파일(/dev/test_dev)을 사용해 드라이버를 접근하기 위해서는 보안라벨의 허락이 필요합니다. Device Driver와 관련된 보안라벨 관련 파일은 아래와 같습니다. ~Android 6.x는 external/sepolicy 또는 device/.../sepolicy Android 7.x~는 system/sepolicy Device driver의 보안라벨을 수정하기 위해선 아래의 3개 파일을 수정해야합니다. service와 관련된 보안라벨(그림에서 devtest.te) device driver 관련 보안라벨(device.te) file_contexts파일 ⑤Untrusted application 사용Untrusted application이란 보안라벨을 적용받지 않은 서비스나 앱을 통칭합니다. 보통 다운받은 APP등은 모두 Untrusted application에 속합니다. 기본적으로 Untrusted application 관련 보안라벨 파일은 다음과 같습니다. ~Android 6.x는 external/sepolicy/untrusted_app.te Android 7.x~는 system/sepolicy/untrusted_app.te 해당 파일에서 ②번에 등록되 있는 서비스에 관련되 Untrusted application이 접근을 허락하게 하는 가에 대해서 설정하는 것입니다. Untrusted application이 접근 가능한 서비스를 추가하기 위해서는 untrusted_app.te 파일에 추가가 필요합니다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform SEAndroid","slug":"Android/Platform-SEAndroid","permalink":"http://jung-max.github.io/categories/Android/Platform-SEAndroid/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"SEAndroid","slug":"SEAndroid","permalink":"http://jung-max.github.io/tags/SEAndroid/"}]},{"title":"JNI 동작 구조","slug":"Android-JNI-동작구조","date":"2019-09-16T04:48:00.000Z","updated":"2022-02-08T02:11:11.749Z","comments":true,"path":"2019/09/16/Android-JNI-동작구조/","link":"","permalink":"http://jung-max.github.io/2019/09/16/Android-JNI-동작구조/","excerpt":"","text":"JNI 개요JNI(Java Native Interface)는 java로 만들어진 프로그램에서 해당 플랫폼에서만 실행 가능한 Native code에 접근하기 위해 만들어진 응용 프로그램의 인터페이스(API)입니다. 기존 C/C++(Native)로 구성된 프로그램을 Java에서 바로 사용할 수 있는 장점을 가지고 있습니다. Java 모듈과 C/C++ 모듈은 서로 상호 작용을 합니다. Java 모듈에서 C/C++ 모듈을 호출하고 C/C++ 모듈에서 Java 모듈을 호출합니다. System.loadLibrary()가 실행되면 ART(Android Runtime)은 해당 이름의 공유 라이브러리를 로딩한 후 함수 심볼 검색을 합니다. JNI Native 함수 등록 및 실행 - 자동매핑로딩한 라이브러리에서 심볼을 검색한 후 JNI_OnLoad()함수가 구현되어 있는지 확인합니다. JNI_OnLoad()함수가 없으면 DVM은 자동으로 라이브러리 내에 JNI Native 함수 심볼을 비교해 매핑 작업을 수행합니다. Android Framework처럼 Native를 포함한 Java Class가 많은 경우 ART에서 라이브러리를 로딩하고 심볼을 일일이 검색해 매핑하는 작업은 성능 저하의 원인이 될 수 있습니다. 자동으로 연결작업을 수행하기 위해서는 Native Layer의 함수를 JNIEXPORT &lt;리턴 타입&gt; JNICALL java_&lt;패키지명&gt;_&lt;클래스명&gt;_&lt;네이티브함수명&gt;으로 수정해야 합니다. javah를 이용하면 JAVA 파일을 빌드하여 얻은 class파일로 부터 JNI 규약에 맞는 헤더파일을 얻을 수 있습니다. 12345package com.exampleclass Helloworld &#123; private native void print();&#125;static System.loadLibrary(\"HelloWorld\"); ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓12//JNIEXPORT &lt;리턴 타입&gt; JNICALL java_&lt;패키지명&gt;_&lt;클래스명&gt;_&lt;네이티브함수명&gt;JNIEXPORT void JNICALL Java_com_example_HelloWorld_print(JNIEnv *env, jobject thiz)&#123; &#125; JNI Native 함수 등록 및 실행 - 수동매핑로딩한 라이브러리에서 심볼을 검색한 후 JNI_OnLoad()함수가 구현되어 있는지 확인하고 해당 함수가 포함되어 있으면 자동으로 호출합니다. RegisterNative()함수를 사용해서 ART에서 자동으로 라이브러리 내에 JNI Native함수 심볼을 비교하여 연결해 주는 작업 대신 프로그래머가 직접 연결 작업을 처리하기 때문에 로딩 속도를 향상시킬 수 있습니다. 연결방법은 아래와 같습니다. ① Application or Application Framwork 12Syatme.loadLibrary(\"android_servers\")nativeInit(); ② libandroid_servers.so → JNI_OnLoad() 실행 → RegisterNatives() 매핑 수행 1234static JNINativeMethod gMethods[] = &#123;/* name(자바함수), signature(리턴타입), funcPtr(c/c++함수) */&#123; \"nativeInit\", \"()V\", (void*)android_server_SystemServer_nativeInit&#125;,&#125;;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform JNI","slug":"Android/Platform-JNI","permalink":"http://jung-max.github.io/categories/Android/Platform-JNI/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"JNI","slug":"JNI","permalink":"http://jung-max.github.io/tags/JNI/"}]},{"title":"Android로 Bluetooth HID 장치(Joystick) 만들기 - 03","slug":"Android-Bluetooth-HID-장치만들기03","date":"2019-09-16T01:29:00.000Z","updated":"2022-02-08T02:11:11.735Z","comments":true,"path":"2019/09/16/Android-Bluetooth-HID-장치만들기03/","link":"","permalink":"http://jung-max.github.io/2019/09/16/Android-Bluetooth-HID-장치만들기03/","excerpt":"","text":"들어가면서첫번째 포스트에서 우리는 Bluetoooth HID 장치를 구현하기 위해 모든 것을 설정했습니다. 두번째 포스트에서는 제어 입력을 연결된 장치로 전송하는 법을 살펴보았습니다. 해당 소스는 https://github.com/Jung-Max/BleHidJoystick를 참고하시면 됩니다. 앱 다운로드는 https://play.google.com/store/apps/details?id=com.ckbs.blehidjoystick를 참고하세요. 이번 포스트에서는 조이스틱의 UI를 구성하는 법에 대해서 살펴보겠습니다. 조이스틱 앱에서 특이한 UI 구성으로는 크게 2가지가 있습니다. 하나는 조이스틱(방향) UI이고 또 하나는 버튼 UI 입니다. 조이스틱 UI먼저 조이스틱 UI에 대해서 설명하겠습니다. 조이스틱 UI는 open source 기반으로 구성하였습니다. 출처는 아래와 같습니다.https://github.com/controlwear/virtual-joystick-android 조이스틱 UI를 사용하기 위한 설명은 해당 사이트에 설명되어 있습니다. 여기서는 angle과 strength를 사용해서 x,y 값을 구하는 방법을 설명하겠습니다. 일단 예제를 살펴보겠습니다. 123456789101112131415@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ... JoystickView joystick = (JoystickView) findViewById(R.id.joystickView); joystick.setOnMoveListener(new JoystickView.OnMoveListener() &#123; @Override public void onMove(int angle, int strength) &#123; // do whatever you want &#125; &#125;);&#125; 해당 구현을 위해서는 onMove에 구현을 해야합니다. 여기서 받는 파라미터값은 angle과 strength입니다. github 소스를 보시면 아래와 같은 그림으로 설명되어 있습니다. 여기서 angle은 각도이고 strength는 퍼센트값입니다. angle은 계산을 위해서 라디안 값으로 변경하고 strength는 퍼센트값이기 때문에 상수로 변경합니다. 12double rad = Math.toRadians(angle);double dist = strength / 100.0; 그 후 거리(dist)에 cos와 sin을 곱하여 조이스틱베이스가 같은 각도의 x와 y 끝 좌표를 얻을 수 있습니다. 12joystick.setTag(R.id.tag_x_pos, dist * Math.cos(rad));joystick.setTag(R.id.tag_y_pos, dist * Math.sin(rad)); x,y 좌표를 구한 후 Range클래스의 clamp 함수를 사용해 byte의 범위인 -127~127 범위로 한정시켜 줍니다. byte값으로 한정시켜 주는 이유는 앞서 포스트에서 설명한 것처럼 Joystick의 descriptor를 정의할 때 x,y의 min, max값을 1바이트 값인 -127, 127로 정했기 때문입니다. 123Range&lt;Integer&gt; bounds = new Range&lt;&gt;(-127, 127);int adjX = bounds.clamp((int) ((double) joystick.getT(R.id.tag_x_pos) * 127));int adjY = bounds.clamp((int) ((double) joystick.getT(R.id.tag_y_pos) * -127)); 이제 변환한 x, y값을 sendReport()를 사용해 송신하면 됩니다. 버튼 UI두번째는 버튼 UI입니다. 버튼 UI는 ImageButton클래스를 써 사용했기 때문에 크게 고려할 점은 없습니다. 여기서 살펴볼 것으로는 버튼의 그림인 △, □, ○, X를 구현하는데 사용한 vector에 있습니다. 해당 구현은 물론 png같은 이미지로 구성해도 되지만 여기서는 vector에 대해서 간단히 살펴보겠습니다. 일단 vector를 사용하기 위해서는 xml(android vector drawable)를 사용해야 합니다. 가지고 있는 svg 포멧이 있다면 안드로이드 스튜디오에 있는 vector asset studio 에서 변환 가능합니다. xml 은 /res/drawable/ 에 넣으면 됩니다. vector로 구현된 ○ 예제는 아래와 같습니다. 123456789&lt;vector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:width=\"24dp\" android:height=\"24dp\" android:viewportWidth=\"24.0\" android:viewportHeight=\"24.0\"&gt; &lt;path android:fillColor=\"#FF000000\" android:pathData=\"M12,2C6.47,2 2,6.47 2,12s4.47,10 10,10 10,-4.47 10,-10S17.53,2 12,2zM12,20c-4.41,0 -8,-3.59 -8,-8s3.59,-8 8,-8 8,3.59 8,8 -3.59,8 -8,8z\"/&gt;&lt;/vector&gt; 여기서 pathData값은 SGV 튜토리얼인 http://tutorials.jenkov.com/svg/index.html에서 공부할 수 있습니다. 보통은 인터넷에 예제를 찾아보는 것을 추천합니다. 다음은 추천 블로그입니다.https://blog.naver.com/ljeljy/220420083431","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"HID","slug":"Android/HID","permalink":"http://jung-max.github.io/categories/Android/HID/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"Bluetooth","slug":"Bluetooth","permalink":"http://jung-max.github.io/tags/Bluetooth/"},{"name":"HID","slug":"HID","permalink":"http://jung-max.github.io/tags/HID/"}]},{"title":"Android로 Bluetooth HID 장치(Joystick) 만들기 - 02","slug":"Android-Bluetooth-HID-장치만들기02","date":"2019-09-11T02:02:00.000Z","updated":"2022-02-08T02:11:11.736Z","comments":true,"path":"2019/09/11/Android-Bluetooth-HID-장치만들기02/","link":"","permalink":"http://jung-max.github.io/2019/09/11/Android-Bluetooth-HID-장치만들기02/","excerpt":"","text":"첫번째 포스트에서 우리는 Bluetoooth HID 장치를 구현하기 위해 모든 것을 설정했습니다. 해당 소스는 https://github.com/Jung-Max/BleHidJoystick를 참고하시면 됩니다. 앱 다운로드는 https://play.google.com/store/apps/details?id=com.ckbs.blehidjoystick를 참고하세요. 이제 제어 입력을 연결된 장치로 전송하기 만하면됩니다. 설정하는 것보다 훨씬 간단합니다. Send reportreport를 보내기위한 관련 API는 BluetoothHidDevice.sendReport입니다. 입력을 보내는 BluetoothDevice(이전에 연결되어 있어야 함), report ID (report ID를 사용하지 않는 경우 0) 및 실제 report를 가져옵니다. 처음 두 파라미터는 매우 간단합니다. Report 데이터는 report descriptor를 따라야합니다. 예를 들어 HID report descriptor를 살펴 보면 너무 복잡하지 않아야합니다. Joystick 예제Joystick의 descriptor를 예로 들겠습니다. 12340x05, 0x01, // USAGE_PAGE (Generic Desktop)0x09, 0x05, // USAGE (Game Pad)(byte) 0xa1, 0x01, // COLLECTION (Application)(byte) 0xa1, 0x00, // COLLECTION (Physical) 위 예제는 장치가 게임 패드(Joystick)임을 선언하는 상용구입니다. 123456780x05, 0x09, // USAGE_PAGE (Button)0x19, 0x01, // USAGE_MINIMUM (Button 1)0x29, 0x04, // USAGE_MAXIMUM (Button 4)0x15, 0x00, // LOGICAL_MINIMUM (0)0x25, 0x01, // LOGICAL_MAXIMUM (1)0x75, 0x01, // REPORT_SIZE (1)(byte) 0x95, 0x04, // REPORT_COUNT (4)(byte) 0x81, 0x02, // INPUT (Data,Var,Abs) 여기에는 4 개의 버튼 세트 (사용 최소 / 최대로 표시)가 설명되어 있습니다. 각각은 (1의 값) 누르거나 (0의 값) 눌러 논리 최대 값 / 최소값을 제공 할 수 있습니다. 각 버튼은 1 비트(보고서 크기)를 차지하며 그 중 4 개(보고서 수)가 있습니다. 입력 명령문은이 블록을 종료합니다. 1230x75, 0x04, // REPORT_SIZE (4)(byte) 0x95, 0x01, // REPORT_COUNT (1)(byte) 0x81, 0x03, // INPUT (Cnst,Var,Abs) 이것은 4 비트의 패딩 (일정)으로 후속 값이 바이트 경계에 정렬되도록합니다. 123456780x05, 0x01, // USAGE_PAGE (Generic Desktop)0x09, 0x30, // USAGE (X)0x09, 0x31, // USAGE (Y)0x15, (byte) 0x81, // LOGICAL_MINIMUM (-127)0x25, 0x7f, // LOGICAL_MAXIMUM (127)0x75, 0x08, // REPORT_SIZE (8)(byte) 0x95, 0x02, // REPORT_COUNT (2)(byte) 0x81, 0x02, // INPUT (Data,Var,Abs) X 및 Y 좌표로 설명 된 위치를 가진 조이스틱을 선언합니다. 각 값은 8 비트로 저장되며 그 중 2 개가 있습니다. 이것들은 -127에서 127까지 다양합니다 (1 바이트의 최대 값). 12(byte) 0xc0, // END_COLLECTION(byte) 0xc0 // END_COLLECTION 디스크립터가 완료됩니다. 이를 통해 보고서 형식을 결정할 수 있습니다. 1234byte | bit 7 6 5 4 3 2 1 0 0 [ --pad-- 4 3 2 1 ] - buttons 1 [ X axis ] 2 [ Y axis ] 위 형식에 따라 report를 작성하고 입력이 변경 될 때마다 sendReport()를 보내면 작동합니다. 123456789101112131415161718192021222324 private void sendReport() &#123; // get button state byte state = 0; for (int i = 0; i &lt; 4; ++i) &#123; if ((boolean) buttons[i].getTag(R.id.tag_pressed)) &#123; state |= (1 &lt;&lt; i); &#125; &#125; // get joystick state Range&lt;Integer&gt; bounds = new Range&lt;&gt;(-127, 127); int adjX = bounds.clamp((int) ((double) joystick.getTag(R.id.tag_x_pos) * 127)); int adjY = bounds.clamp((int) ((double) joystick.getTag(R.id.tag_y_pos) * -127)); Log.d(TAG, \"sendReport(): \" + state + \" \" + adjX + \" \" + adjY); for (BluetoothDevice btDev : mBtHidDevice.getConnectedDevices()) &#123; mBtHidDevice.sendReport(btDev, 0, new byte[]&#123; state, (byte) adjX, (byte) adjY, &#125;); &#125;&#125; 다음 포스트는 Joystick의 UI 설정에 관해서 살펴보겠습니다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"HID","slug":"Android/HID","permalink":"http://jung-max.github.io/categories/Android/HID/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"Bluetooth","slug":"Bluetooth","permalink":"http://jung-max.github.io/tags/Bluetooth/"},{"name":"HID","slug":"HID","permalink":"http://jung-max.github.io/tags/HID/"}]},{"title":"Android로 Bluetooth HID 장치(Joystick) 만들기 - 01","slug":"Android-Bluetooth-HID-장치만들기01","date":"2019-09-09T04:39:00.000Z","updated":"2022-02-08T02:11:11.735Z","comments":true,"path":"2019/09/09/Android-Bluetooth-HID-장치만들기01/","link":"","permalink":"http://jung-max.github.io/2019/09/09/Android-Bluetooth-HID-장치만들기01/","excerpt":"","text":"개요Android 9(API Level 28, Pie)에서는 휴대 전화를 Bluetooth HID로 사용할 수 있도록 지원하므로 키보드, 마우스 또는 게임 패드로 사용할 수 있습니다. BluetoothHidDevice를 사용해서 Bluetooth Joystick을 구현하는 것을 설명하겠습니다. 해당 소스는 https://github.com/Jung-Max/BleHidJoystick를 참고하시면 됩니다. 앱 다운로드는 https://play.google.com/store/apps/details?id=com.ckbs.blehidjoystick를 참고하세요. Bluetooth 준비하기가장 먼저 Bluetooth를 설정하고 적절한 프로파일을 가져와야 합니다. 처음으로 블루투스 어댑터를 가져옵니다. 아직 활성화 되지 않은 경우 블루투스를 활성화 해야합니다. 123456789private BluetoothAdapter mBtAdapter = BluetoothAdapter.getDefaultAdapter();// Get bluetooth enabled before continuingif (!mBtAdapter.isEnabled()) &#123; Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);&#125; else &#123; btListDevices();&#125; 그런 다음 기존 페어링된 장치의 목록을 가져와야 합니다. 123456789101112131415161718192021private ArrayList&lt;BluetoothDevice&gt; mDevices = new ArrayList&lt;&gt;();private void btListDevices() &#123; Set&lt;BluetoothDevice&gt; pairedDevices = mBtAdapter.getBondedDevices(); // Add devices to adapter List&lt;String&gt; names = new ArrayList&lt;&gt;(); // add empty names.add(\"(disconnected)\"); mDevices.add(null); for (BluetoothDevice btDev : pairedDevices) &#123; names.add(btDev.getName()); mDevices.add(btDev); &#125; ...&#125; BluetoothHidDevice 취득하기블루투스 기기의 정보를 취득 후에는 활성화한 HID 서비스와 통신할 수 있도록 프록시(BluetoothHidDevice)를 가져와야 합니다. 이것은 BluetoothAdapter.getProfileProxy()을 사용해서 취득 할 수 있습니다. 123456789101112131415161718192021mBtAdapter.getProfileProxy(this, new BluetoothProfile.ServiceListener() &#123; @Override @SuppressLint(\"NewApi\") public void onServiceConnected(int profile, BluetoothProfile proxy) &#123; if (profile == BluetoothProfile.HID_DEVICE) &#123; Log.d(TAG, \"Got HID device\"); mBtHidDevice = (BluetoothHidDevice) proxy; ... mBtHidDevice.registerApp(); &#125; &#125; @Override public void onServiceDisconnected(int profile) &#123; if (profile == BluetoothProfile.HID_DEVICE) &#123; Log.d(TAG, \"Lost HID device\"); &#125; &#125;&#125;, BluetoothProfile.HID_DEVICE); 이 호출은 기본적으로 프록시를 요청하고 저장합니다. registerApp()Bluetooth HID의 registerApp()의 파라미터는 아래와 같습니다. 123456public boolean registerApp( BluetoothHidDeviceAppSdpSettings sdp, BluetoothHidDeviceAppQosSettings inQos, BluetoothHidDeviceAppQosSettings outQos, Executor executor, Callback callback) sdpBluetoothHidDeviceAppSdpSettings는 Bluetooth HID 장치 응용 프로그램의 SDP (Service Discovery Protocol) 설정을 나타냅니다. BluetoothHidDevice 프레임 워크는 앱 등록 중에 SDP 레코드를 추가하여 Android 장치를 Bluetooth HID 장치로 검색 할 수 있습니다. BluetoothHidDeviceAppSdpSettings의 파라미터를 살펴보면 다음과 같습니다. 12345public BluetoothHidDeviceAppSdpSettings (String name, String description, String provider, byte subclass, byte[] descriptors) name, description, provider은 각자 목적에 맞는 문자열을 넣어주면 됩니다.(50byte 이하로만) subclass는 HID 스팩문서의 4.2 Subclass를 참고합니다. subclass는 0 또는 1만 설정할 수 있습니다. 보통은 0으로 설정하게 됩니다. HID descriptorsdescriptors는 HID 스팩문서의 6절을 보면 나와있습니다. 디스크립터는 기본 HID 디스크립터로 구성되며 그 뒤에 다른 디스크립터가 있습니다 (문자 적으로 연결됨). 아래 테이블은 주 디스크립터의 레이아웃입니다. (추가 디스크립터는 하나만 필요하며 추가 디스크립터의 필드는 선택 사항 임). Part Byte(s) Description bLength 0 Length of main descriptor (not including other descriptor) - 0x09 bDescriptorType 1 HID descriptor type - 0x21 bcdHID 2-3 HID specification version, in little endian binary coded decimal - 0x11 0x01 bCountryCode 4 Country code - 0x00 for not localised (only relevant for keyboards) bNumDescriptors 5 Number of extra descriptors - 0x01 (the report descriptor) bDescriptorType 6 Report type 0x22 wDescriptorLength 7-8 Length of the report descriptor type, in little endian HID 디스크립터와 관련된 HID descriptor tool과 tutorial about USB HID report descriptors를 참고하면 더 많은 것을 알 수 있습니다. 최종적으로 4 buttons, 1 X/Y joystick의 descriptor은 아래와 같습니다. 12345678910111213141516171819202122232425262728293031323334353637private static final byte[] descriptor = new byte[] &#123; // HID descriptor 0x09, // bLength 0x21, // bDescriptorType 0x11, 0x01, // bcdHID 0x00, // bCountryCode 0x01, // bNumDescriptors 0x22, // bDescriptorType 0x30, 0x00, // wDescriptorLength (48 in decimal) // Report descriptor - 4 buttons, 1 X/Y joystick 0x05, 0x01, // USAGE_PAGE (Generic Desktop) 0x09, 0x05, // USAGE (Game Pad) (byte) 0xa1, 0x01, // COLLECTION (Application) (byte) 0xa1, 0x00, // COLLECTION (Physical) 0x05, 0x09, // USAGE_PAGE (Button) 0x19, 0x01, // USAGE_MINIMUM (Button 1) 0x29, 0x04, // USAGE_MAXIMUM (Button 4) 0x15, 0x00, // LOGICAL_MINIMUM (0) 0x25, 0x01, // LOGICAL_MAXIMUM (1) 0x75, 0x01, // REPORT_SIZE (1) (byte) 0x95, 0x04, // REPORT_COUNT (4) (byte) 0x81, 0x02, // INPUT (Data,Var,Abs) 0x75, 0x04, // REPORT_SIZE (4) (byte) 0x95, 0x01, // REPORT_COUNT (1) (byte) 0x81, 0x03, // INPUT (Cnst,Var,Abs) 0x05, 0x01, // USAGE_PAGE (Generic Desktop) 0x09, 0x30, // USAGE (X) 0x09, 0x31, // USAGE (Y) 0x15, (byte) 0x81, // LOGICAL_MINIMUM (-127) 0x25, 0x7f, // LOGICAL_MAXIMUM (127) 0x75, 0x08, // REPORT_SIZE (8) (byte) 0x95, 0x02, // REPORT_COUNT (2) (byte) 0x81, 0x02, // INPUT (Data,Var,Abs) (byte) 0xc0, // END_COLLECTION (byte) 0xc0 // END_COLLECTION&#125;; inQos, outQos수신 / 발신시의 QoS 셋팅과 관련된 파라미터 입니다. 기본적으로 null을 사용합니다. BluetoothHidDeviceAppQosSettings는 Bluetooth HID 장치 응용 프로그램의 QoS(서비스 품질) 설정을 나타냅니다. BluetoothHidDevice 프레임 워크는 등록 중에 앱의 L2CAP QoS 설정을 업데이트합니다. Parameters 설명 serviceType L2CAP service type, default = SERVICE_BEST_EFFORT tokenRate L2CAP token rate, default = 0 tokenBucketSize L2CAP token bucket size, default = 0 peakBandwidth L2CAP peak bandwidth, default = 0 latency L2CAP latency, default = MAX delayVariation L2CAP delay variation, default = MAX executorExecutor는 콜백이 실행될 Executor 객체입니다. Executor 객체가 필요합니다. Executors.newSingleThreadExecutor()로 Executor 객체를 생성해 줍니다. callbackcallback은 콜백 메시지가 전송 될 콜백 객체입니다. 콜백 객체가 필요합니다. 기본적으로 callback에는 특별한 설정을 하지 않아도 됩니다. 하지만 연결 준비가 완료된 시점과 종료 된 시점을 알 수 있도록 onConnectionStateChanged를 구현하면 도움이됩니다. 123456789101112131415161718192021222324252627282930new BluetoothHidDevice.Callback() &#123; @Override public void onGetReport(BluetoothDevice device, byte type, byte id, int bufferSize) &#123; Log.v(TAG, \"onGetReport: device=\" + device + \" type=\" + type + \" id=\" + id + \" bufferSize=\" + bufferSize); &#125; @Override public void onConnectionStateChanged(BluetoothDevice device, final int state) &#123; Log.v(TAG, \"onConnectionStateChanged: device=\" + device + \" state=\" + state); if (device.equals(mBtDevice)) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; TextView status = findViewById(R.id.status); if (state == BluetoothProfile.STATE_DISCONNECTED) &#123; status.setText(R.string.status_disconnected); mBtDevice = null; &#125; else if (state == BluetoothProfile.STATE_CONNECTING) &#123; status.setText(R.string.status_connecting); &#125; else if (state == BluetoothProfile.STATE_CONNECTED) &#123; status.setText(R.string.status_connected); &#125; else if (state == BluetoothProfile.STATE_DISCONNECTING) &#123; status.setText(R.string.status_disconnecting); &#125; &#125; &#125;); &#125; &#125;&#125; 연결최종적으로 앱을 등록하고 장치를 연결할 수 있습니다. 123456789101112131415BluetoothHidDeviceAppSdpSettings sdp = new BluetoothHidDeviceAppSdpSettings( \"BleHidJoystick\", \"Android BLE HID Joystick\", \"Android\", (byte) 0x00, descriptor);mBtHidDevice.registerApp(sdp, null, mBluetoothHidDeviceAppQosSettings, Executors.newSingleThreadExecutor(), new BluetoothHidDevice.Callback() &#123; ... //omitted&#125;);mBtHidDevice.connect(device);&#125; 다음 포스트에서는 연결된 장비로 어떻게 input을 보내는지 설명하겠습니다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"HID","slug":"Android/HID","permalink":"http://jung-max.github.io/categories/Android/HID/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"Bluetooth","slug":"Bluetooth","permalink":"http://jung-max.github.io/tags/Bluetooth/"},{"name":"HID","slug":"HID","permalink":"http://jung-max.github.io/tags/HID/"}]},{"title":"Finding BLE Devices","slug":"Android-BLE-Finding-Devices","date":"2019-09-08T23:42:00.000Z","updated":"2022-02-08T02:11:11.728Z","comments":true,"path":"2019/09/09/Android-BLE-Finding-Devices/","link":"","permalink":"http://jung-max.github.io/2019/09/09/Android-BLE-Finding-Devices/","excerpt":"","text":"Bluetooth API를 사용하려면 다음 권한이 필요합니다. 12android.permission.BLUETOOTHandroid.permission.BLUETOOTH_ADMIN Android 6.0 (API 레벨 23) 이상의 장치를 대상으로하고 스캔 / advertising 작업을 수행하려는 경우 위치 권한이 필요합니다. 12345android.permission.ACCESS_FINE_LOCATIONorandroid.permission.ACCESS_COARSE_LOCATION 참고 : Android 6.0 (API 레벨 23) 이상의 장치도 위치 서비스를 활성화해야합니다. 스캔 / advertising 작업을 시작하려면 BluetoothAdapter 객체가 필요합니다. 12BluetoothManager bluetoothManager = (BluetoothManager) context.getSystemService(Context.BLUETOOTH_SERVICE);bluetoothAdapter = bluetoothManager.getAdapter(); BluetoothLeScanner 클래스의 startScan(ScanCallback 콜백) 방법은 스캔 작업을 시작하는 가장 기본적인 방법입니다. 결과를 받으려면 ScanCallback 객체가 필요합니다. 1234567bluetoothAdapter.getBluetoothLeScanner().startScan(new ScanCallback() &#123; @Override public void onScanResult(int callbackType, ScanResult result) &#123; super.onScanResult(callbackType, result); Log.i(TAG, \"Remote device name: \" + result.getDevice().getName()); &#125; &#125;);","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"BLE","slug":"Android/BLE","permalink":"http://jung-max.github.io/categories/Android/BLE/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"BLE","slug":"BLE","permalink":"http://jung-max.github.io/tags/BLE/"}]},{"title":"Characteristics 읽고쓰기","slug":"Android-BLE-Characteristics-읽고쓰기","date":"2019-09-08T23:42:00.000Z","updated":"2022-02-08T02:11:11.730Z","comments":true,"path":"2019/09/09/Android-BLE-Characteristics-읽고쓰기/","link":"","permalink":"http://jung-max.github.io/2019/09/09/Android-BLE-Characteristics-읽고쓰기/","excerpt":"","text":"Gatt 서버에 연결되면 서버의 Characteristics을 읽고 읽음으로써 Gatt 서버와 상호 작용하게됩니다. 이렇게하려면 먼저이 서버에서 사용할 수 있는 서비스와 각 서비스에서 사용할 수 있는 Characteristics을 찾아야합니다. 1234567891011121314151617181920212223 @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; if (newState == BluetoothProfile.STATE_CONNECTED) &#123; Log.i(TAG, \"Connected to GATT server.\"); gatt.discoverServices(); &#125;. . . @Override public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; List&lt;BluetoothGattService&gt; services = gatt.getServices(); for (BluetoothGattService service : services) &#123; List&lt;BluetoothGattCharacteristic&gt; characteristics = service.getCharacteristics(); for (BluetoothGattCharacteristic characteristic : characteristics) &#123; ///Once you have a characteristic object, you can perform read/write //operations with it &#125; &#125; &#125; &#125; 기본 쓰기 작업은 다음과 같습니다. 123characteristic.setValue(newValue);characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT);gatt.writeCharacteristic(characteristic); 쓰기 프로세스가 완료되면 BluetoothGattCallback의 onCharacteristicWrite 메소드가 호출됩니다. 12345@Overridepublic void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; super.onCharacteristicWrite(gatt, characteristic, status); Log.d(TAG, \"Characteristic \" + characteristic.getUuid() + \" written);&#125; 기본 쓰기 작업은 다음과 같습니다. 1gatt.readCharacteristic(characteristic); 쓰기 프로세스가 완료되면 BluetoothGattCallback의 onCharacteristicRead 메소드가 호출됩니다. 12345@Overridepublic void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; super.onCharacteristicRead(gatt, characteristic, status); byte[] value = characteristic.getValue(); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"BLE","slug":"Android/BLE","permalink":"http://jung-max.github.io/categories/Android/BLE/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"BLE","slug":"BLE","permalink":"http://jung-max.github.io/tags/BLE/"}]},{"title":"Advertising a BLE Device","slug":"Android-Advertising-BLE-Device","date":"2019-09-08T23:42:00.000Z","updated":"2022-02-08T02:11:11.712Z","comments":true,"path":"2019/09/09/Android-Advertising-BLE-Device/","link":"","permalink":"http://jung-max.github.io/2019/09/09/Android-Advertising-BLE-Device/","excerpt":"","text":"Bluetooth LE Advertising을 사용하여 먼저 연결하지 않고도 데이터 패키지를 근처의 모든 장치에 브로드 캐스트 할 수 있습니다. Advertising 데이터는 31 바이트로 제한됩니다. 기기 Advertising은 다른 사용자가 나에게 연결하도록하는 첫 번째 단계입니다. 모든 장치가 Bluetooth LE Advertising을 지원하는 것은 아니므로 첫 번째 단계는 장치를 지원하는 데 필요한 모든 요구 사항이 장치에 있는지 확인하는 것입니다. 이후에 BluetoothLeAdvertiser 객체를 초기화하고이를 통해 Advertising 작업을 시작할 수 있습니다. 1234567891011121314151617181920212223242526272829303132if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP &amp;&amp; bluetoothAdapter.isMultipleAdvertisementSupported())&#123; BluetoothLeAdvertiser advertiser = bluetoothAdapter.getBluetoothLeAdvertiser(); AdvertiseData.Builder dataBuilder = new AdvertiseData.Builder(); //Define a service UUID according to your needs dataBuilder.addServiceUuid(SERVICE_UUID); dataBuilder.setIncludeDeviceName(true); AdvertiseSettings.Builder settingsBuilder = new AdvertiseSettings.Builder(); settingsBuilder.setAdvertiseMode(AdvertiseSettings.ADVERTISE_MODE_LOW_POWER); settingsBuilder.setTimeout(0); //Use the connectable flag if you intend on opening a Gatt Server //to allow remote connections to your device. settingsBuilder.setConnectable(true); AdvertiseCallback advertiseCallback=new AdvertiseCallback() &#123; @Override public void onStartSuccess(AdvertiseSettings settingsInEffect) &#123; super.onStartSuccess(settingsInEffect); Log.i(TAG, \"onStartSuccess: \"); &#125; @Override public void onStartFailure(int errorCode) &#123; super.onStartFailure(errorCode); Log.e(TAG, \"onStartFailure: \"+errorCode ); &#125; &#125;; advertising.startAdvertising(settingsBuilder.build(),dataBuilder.build(),advertiseCallback);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"BLE","slug":"Android/BLE","permalink":"http://jung-max.github.io/categories/Android/BLE/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"BLE","slug":"BLE","permalink":"http://jung-max.github.io/tags/BLE/"}]},{"title":"Gatt Server로 부터 알림 받기","slug":"Android-BLE-GattServer로부터-알림받기","date":"2019-09-08T23:42:00.000Z","updated":"2022-02-08T02:11:11.729Z","comments":true,"path":"2019/09/09/Android-BLE-GattServer로부터-알림받기/","link":"","permalink":"http://jung-max.github.io/2019/09/09/Android-BLE-GattServer로부터-알림받기/","excerpt":"","text":"특성 값이 변경되면 Gatt 서버에 알림을 요청할 수 있습니다. 12345gatt.setCharacteristicNotification(characteristic, true);BluetoothGattDescriptor descriptor = characteristic.getDescriptor( UUID.fromString(\"00002902-0000-1000-8000-00805f9b34fb\");descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);mBluetoothGatt.writeDescriptor(descriptor); 서버의 모든 알림은 BluetoothGattCallback의 onCharacteristicChanged 메소드로 수신됩니다. 12345 @Override public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; super.onCharacteristicChanged(gatt, characteristic); byte[] newValue = characteristic.getValue();&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"BLE","slug":"Android/BLE","permalink":"http://jung-max.github.io/categories/Android/BLE/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"BLE","slug":"BLE","permalink":"http://jung-max.github.io/tags/BLE/"}]},{"title":"Connecting to a GATT Server","slug":"Android-BLE-Connecting-GATT-Server","date":"2019-09-08T23:42:00.000Z","updated":"2022-02-08T02:11:11.728Z","comments":true,"path":"2019/09/09/Android-BLE-Connecting-GATT-Server/","link":"","permalink":"http://jung-max.github.io/2019/09/09/Android-BLE-Connecting-GATT-Server/","excerpt":"","text":"원하는 BluetoothDevice 객체를 발견하면 Context 객체, BLE 장치에 자동으로 연결할지 여부를 나타내는 부울 및 연결 이벤트 및 클라이언트 작업이있는 BluetoothGattCallback 참조를 매개 변수로 사용하는 connectGatt() 메서드를 사용하여 연결할 수 있습니다. 12345if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123; device.connectGatt(context, false, bluetoothGattCallback, BluetoothDevice.TRANSPORT_AUTO); &#125; else &#123; device.connectGatt(context, false, bluetoothGattCallback); &#125; 연결 끊김 이벤트를 수신하려면 BluetoothGattCallback의 onConnectionStateChange를 Override 하세요. 1234567891011121314 BluetoothGattCallback bluetoothGattCallback = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; if (newState == BluetoothProfile.STATE_CONNECTED) &#123; Log.i(TAG, \"Connected to GATT server.\"); &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123; Log.i(TAG, \"Disconnected from GATT server.\"); &#125; &#125;&#125;;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"BLE","slug":"Android/BLE","permalink":"http://jung-max.github.io/categories/Android/BLE/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"BLE","slug":"BLE","permalink":"http://jung-max.github.io/tags/BLE/"}]},{"title":"Gatt Server 사용하기","slug":"Android-BLE-Gatt서버-사용하기","date":"2019-09-08T23:42:00.000Z","updated":"2022-02-08T02:11:11.729Z","comments":true,"path":"2019/09/09/Android-BLE-Gatt서버-사용하기/","link":"","permalink":"http://jung-max.github.io/2019/09/09/Android-BLE-Gatt서버-사용하기/","excerpt":"","text":"장치가 주변 장치로 작동하려면 먼저 BluetoothGattServer를 열고 하나 이상의 BluetoothGattService 및 하나의 BluetoothGattCharacteristic로 채워야합니다. 123BluetoothGattServer server=bluetoothManager.openGattServer(context, bluetoothGattServerCallback);BluetoothGattService service = new BluetoothGattService(SERVICE_UUID, BluetoothGattService.SERVICE_TYPE_PRIMARY); 전체 쓰기, 읽기 및 알림 권한이있는 BluetoothGattCharacteristic의 예입니다. 필요에 따라이 특성을 부여하는 권한을 미세 조정할 수 있습니다. 12345678910BluetoothGattCharacteristic characteristic = new BluetoothGattCharacteristic(CHARACTERISTIC_UUID, BluetoothGattCharacteristic.PROPERTY_READ | BluetoothGattCharacteristic.PROPERTY_WRITE | BluetoothGattCharacteristic.PROPERTY_NOTIFY, BluetoothGattCharacteristic.PERMISSION_READ | BluetoothGattCharacteristic.PERMISSION_WRITE);characteristic.addDescriptor(new BluetoothGattDescriptor(UUID.fromString(\"00002902-0000-1000-8000-00805f9b34fb\"), BluetoothGattCharacteristic.PERMISSION_WRITE));service.addCharacteristic(characteristic);server.addService(service); BluetoothGattServerCallback은 BluetoothGattServer와 관련된 모든 이벤트를 수신합니다. 12345678910111213141516171819202122232425BluetoothGattServerCallback bluetoothGattServerCallback= new BluetoothGattServerCallback() &#123; @Override public void onConnectionStateChange(BluetoothDevice device, int status, int newState) &#123; super.onConnectionStateChange(device, status, newState); &#125; @Override public void onCharacteristicReadRequest(BluetoothDevice device, int requestId, int offset, BluetoothGattCharacteristic characteristic) &#123; super.onCharacteristicReadRequest(device, requestId, offset, characteristic); &#125; @Override public void onCharacteristicWriteRequest(BluetoothDevice device, int requestId, BluetoothGattCharacteristic characteristic, boolean preparedWrite, boolean responseNeeded, int offset, byte[] value) &#123; super.onCharacteristicWriteRequest(device, requestId, characteristic, preparedWrite, responseNeeded, offset, value); &#125; @Override public void onDescriptorReadRequest(BluetoothDevice device, int requestId, int offset, BluetoothGattDescriptor descriptor) &#123; super.onDescriptorReadRequest(device, requestId, offset, descriptor); &#125; @Override public void onDescriptorWriteRequest(BluetoothDevice device, int requestId, BluetoothGattDescriptor descriptor, boolean preparedWrite, boolean responseNeeded, int offset, byte[] value) &#123; super.onDescriptorWriteRequest(device, requestId, descriptor, preparedWrite, responseNeeded, offset, value); &#125; characteristic 또는 descriptor에 대한 쓰기 / 읽기 요청을받을 때마다 요청을 성공적으로 완료하려면 응답을 보내야합니다. 12345@Override public void onCharacteristicReadRequest(BluetoothDevice device, int requestId, int offset, BluetoothGattCharacteristic characteristic) &#123; super.onCharacteristicReadRequest(device, requestId, offset, characteristic); server.sendResponse(device, requestId, BluetoothGatt.GATT_SUCCESS, offset, YOUR_RESPONSE);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"BLE","slug":"Android/BLE","permalink":"http://jung-max.github.io/categories/Android/BLE/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"BLE","slug":"BLE","permalink":"http://jung-max.github.io/tags/BLE/"}]},{"title":"Bluetooth low energy","slug":"Android-BLE-overview","date":"2019-09-06T02:50:00.000Z","updated":"2022-02-08T02:11:11.731Z","comments":true,"path":"2019/09/06/Android-BLE-overview/","link":"","permalink":"http://jung-max.github.io/2019/09/06/Android-BLE-overview/","excerpt":"","text":"Bluetooth low energy 개요Android 4.3 (API 레벨 18)부터 중심 역할에 BLE (Bluetooth Low Energy)에 대한 기본 제공 플랫폼 지원을 도입하고 앱이 장치를 검색하고 서비스를 쿼리하고 정보를 전송하는 데 사용할 수있는 API를 제공합니다. 클래식 Bluetooth와 달리 BLE (Bluetooth Low Energy)는 전력 소비를 크게 줄 이도록 설계되었습니다. 이를 통해 Android 앱은 근접 센서, 심박수 모니터 및 피트니스 장치와 같이 더 엄격한 전원 요구 사항이있는 BLE 장치와 통신 할 수 있습니다. GATT(Generic Attribute Profile)GATT 프로파일은 BLE 링크를 통해 “attributes”라고하는 짧은 데이터 조각을 송수신하기위한 일반 사양입니다. 현재 모든 저에너지 애플리케이션 프로파일은 GATT를 기반으로합니다. Bluetooth SIG는 저에너지 장치에 대한 많은 프로파일을 정의합니다. 프로파일은 장치가 특정 응용 프로그램에서 작동하는 방식에 대한 사양입니다. 장치는 둘 이상의 프로필을 구현할 수 있습니다. 예를 들어, 장치에는 심박수 모니터와 배터리 수준 감지기가 포함될 수 있습니다. Attribute Protocol (ATT)GATT는 ATT (Attribute Protocol) 위에 구축됩니다. 이것을 GATT / ATT라고도합니다. ATT는 BLE 장치에서 실행되도록 최적화되었습니다. 이를 위해 가능한 적은 바이트를 사용합니다. 각 attributes는 정보를 고유하게 식별하는 데 사용되는 문자열 ID의 표준화 된 128 비트 형식 인 UUID (Universally Unique Identifier)로 고유하게 식별됩니다. ATT에 의해 전송 된 attributes는 characteristics 및 services로 형식화됩니다. CharacteristicCharacteristic에는 단일 값과 특성 값을 설명하는 0-n 설명자가 포함됩니다. Characteristic은 클래스와 유사한 유형으로 생각할 수 있습니다. DescriptorDescriptor는 특성 값을 설명하는 정의 된 속성입니다. 예를 들어 Descriptor는 사람이 읽을 수있는 설명, 특성 값의 허용 가능한 범위 또는 특성 값에 특정한 측정 단위를 지정할 수 있습니다. Service서비스는 characteristics의 모음입니다. 예를 들어 “심박수 측정”과 같은 characteristics을 포함하는 “심박수 모니터”라는 서비스가있을 수 있습니다. bluetooth.org에서 기존 GATT 기반 프로파일 및 서비스 목록을 찾을 수 있습니다. Roles and responsibilitiesCentral vs. peripheral(주변장치)이것은 BLE 연결 자체에 적용됩니다. 중앙 역할의 장치가 advertisement를 검색하고 주변 역할의 장치가 advertisement를 만듭니다. GATT server vs. GATT client연결이 설정되면 두 장치가 서로 통신하는 방법을 결정합니다. 차이점을 이해하려면 Android 전화와 BLE 장치 인 활동 추적기가 있다고 가정하세요. 전화는 중심적인 역할을 지원합니다. 활동 추적기는 주변 장치 역할을 지원합니다.(BLE 연결을 설정하려면 주변 장치 만 지원하는 두 가지 또는 중앙 통신 장치 만 지원하는 두 가지 중 하나). 전화와 활동 추적기가 연결되면 GATT 메타 데이터를 서로에게 전송하기 시작합니다. 전송하는 데이터의 종류에 따라 하나 또는 다른 서버가 서버로 작동 할 수 있습니다. 예를 들어, 활동 추적기가 센서 데이터를 전화로보고하려는 경우 활동 추적기가 서버 역할을하는 것이 적합 할 수 있습니다. 활동 추적기가 전화기에서 업데이트를 수신하려는 경우 전화기가 서버 역할을하는 것이 좋습니다. BLE permissions응용 프로그램에서 Bluetooth 기능을 사용하려면 Bluetooth 권한 BLUETOOTH를 선언해야합니다. 연결 요청, 연결 수락 및 데이터 전송과 같은 Bluetooth 통신을 수행하려면이 권한이 필요합니다. 앱이 장치 검색을 시작하거나 Bluetooth 설정을 조작하도록하려면 BLUETOOTH_ADMIN 권한도 선언해야합니다. 12&lt;uses-permission android:name=\"android.permission.BLUETOOTH\"/&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\"/&gt; 앱을 BLE 지원 장치에서만 사용할 수 있다고 선언하려면 앱 매니페스트에 다음을 포함하십시오. 1&lt;uses-feature android:name=\"android.hardware.bluetooth_le\" android:required=\"true\"/&gt; 그러나 BLE를 지원하지 않는 장치에서 앱을 사용하려면 앱의 매니페스트에이 요소를 포함시켜야하지만 required = “false”를 설정해야합니다. 그런 다음 런타임에 PackageManager.hasSystemFeature ()를 사용하여 BLE 가용성을 확인할 수 있습니다. 123456// Use this check to determine whether BLE is supported on the device. Then// you can selectively disable BLE-related features.if (!getPackageManager().hasSystemFeature(PackageManager.FEATURE_BLUETOOTH_LE)) &#123; Toast.makeText(this, R.string.ble_not_supported, Toast.LENGTH_SHORT).show(); finish();&#125; Set up BLE애플리케이션이 BLE를 통해 통신하기 전에 디바이스에서 BLE가 지원되는지 확인하고, 가능하면 사용 가능해야합니다. 이 점검은 &lt;uses-feature … /&gt;가 false로 설정된 경우에만 필요합니다. BLE가 지원되지 않으면 BLE 기능을 정상적으로 비활성화해야합니다. BLE가 지원되지만 비활성화 된 경우 응용 프로그램을 종료하지 않고 사용자에게 Bluetooth를 활성화하도록 요청할 수 있습니다. 이 설정은 BluetoothAdapter를 사용하여 두 단계로 수행됩니다. Get the BluetoothAdapterBluetoothAdapter는 모든 Bluetooth 활동에 필요합니다. BluetoothAdapter는 장치 자체의 Bluetooth 어댑터 (Bluetooth 라디오)를 나타냅니다. 전체 시스템에 하나의 Bluetooth 어댑터가 있으며이 객체를 사용하여 응용 프로그램과 상호 작용할 수 있습니다. 아래는 어댑터를 얻는 방법을 보여줍니다. 이 접근 방식은 getSystemService ()를 사용하여 BluetoothManager 인스턴스를 리턴 한 다음 어댑터를 얻는 데 사용됩니다. Android 4.3 (API 레벨 18)에 BluetoothManager가 도입되었습니다. 123456private BluetoothAdapter bluetoothAdapter;...// Initializes Bluetooth adapter.final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);bluetoothAdapter = bluetoothManager.getAdapter(); Enable Bluetooth다음으로, 블루투스가 활성화되어 있는지 확인해야합니다. isEnabled ()를 호출하여 현재 Bluetooth가 활성화되어 있는지 확인하십시오. 이 방법이 false를 반환하면 Bluetooth가 비활성화 된 것입니다. 다음은 블루투스가 활성화되어 있는지 확인합니다. 그렇지 않은 경우 사용자가 설정으로 이동하여 Bluetooth를 활성화하라는 오류 메시지가 표시됩니다. 123456// Ensures Bluetooth is available on the device and it is enabled. If not,// displays a dialog requesting user permission to enable Bluetooth.if (bluetoothAdapter == null || !bluetoothAdapter.isEnabled()) &#123; Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);&#125; BLE 장치 찾기BLE 장치를 찾으려면 startLeScan() 메소드를 사용하십시오. 이 메소드는 BluetoothAdapter.LeScanCallback을 매개 변수로 사용합니다. 이 콜백은 스캔 결과가 리턴되는 방식이므로 구현해야합니다. 스캔은 배터리를 많이 사용하므로 다음 지침을 준수해야합니다. 원하는 장치를 찾으면 스캔을 중지하십시오. 루프를 스캔하지 말고 스캔 시간 제한을 설정하십시오. 이전에 사용 가능했던 장치가 범위를 벗어 났으며 스캔을 계속하면 배터리가 소진됩니다. 다음은 스캔을 시작하고 중지하는 방법을 보여줍니다. 123456789101112131415161718192021222324252627282930313233/** * Activity for scanning and displaying available BLE devices. */public class DeviceScanActivity extends ListActivity &#123; private BluetoothAdapter bluetoothAdapter; private boolean mScanning; private Handler handler; // Stops scanning after 10 seconds. private static final long SCAN_PERIOD = 10000; ... private void scanLeDevice(final boolean enable) &#123; if (enable) &#123; // Stops scanning after a pre-defined scan period. handler.postDelayed(new Runnable() &#123; @Override public void run() &#123; mScanning = false; bluetoothAdapter.stopLeScan(leScanCallback); &#125; &#125;, SCAN_PERIOD); mScanning = true; bluetoothAdapter.startLeScan(leScanCallback); &#125; else &#123; mScanning = false; bluetoothAdapter.stopLeScan(leScanCallback); &#125; ... &#125;...&#125; 특정 유형의 주변 장치 만 검색하려는 경우 대신 startLeScan (UUID [], BluetoothAdapter.LeScanCallback)을 호출하여 앱이 지원하는 GATT 서비스를 지정하는 UUID 객체 배열을 제공 할 수 있습니다. 다음은 BLE 스캔 결과를 제공하는 데 사용되는 인터페이스 인 BluetoothAdapter.LeScanCallback의 구현입니다. 1234567891011121314151617private LeDeviceListAdapter leDeviceListAdapter;...// Device scan callback.private BluetoothAdapter.LeScanCallback leScanCallback = new BluetoothAdapter.LeScanCallback() &#123; @Override public void onLeScan(final BluetoothDevice device, int rssi, byte[] scanRecord) &#123; runOnUiThread(new Runnable() &#123; @Override public void run() &#123; leDeviceListAdapter.addDevice(device); leDeviceListAdapter.notifyDataSetChanged(); &#125; &#125;); &#125;&#125;; Bluetooth에 설명 된대로 Bluetooth LE 장치 만 검색하거나 Classic Bluetooth 장치 만 검색 할 수 있습니다. Bluetooth LE와 클래식 장치를 동시에 검색 할 수 없습니다. Connect to a GATT serverBLE 장치와 상호 작용하는 첫 번째 단계는 장치, 특히 장치의 GATT 서버에 연결하는 것입니다. BLE 장치의 GATT 서버에 연결하려면 connectGatt() 메소드를 사용하십시오. 이 메소드는 Context 객체, autoConnect(BLE 장치가 사용 가능 해지면 자동으로 연결할지 여부를 나타내는 부울) 및 BluetoothGattCallback에 대한 참조의 세 가지 매개 변수를 사용합니다. 1bluetoothGatt = device.connectGatt(this, false, gattCallback); 이것은 BLE 장치가 호스팅하는 GATT 서버에 연결하고 BluetoothGatt 인스턴스를 반환 한 다음 GATT 클라이언트 작업을 수행하는 데 사용할 수 있습니다. 발신자 (Android 앱)는 GATT 클라이언트입니다. BluetoothGattCallback은 연결 상태 및 추가 GATT 클라이언트 작업과 같은 결과를 클라이언트에 전달하는 데 사용됩니다. 아래 예에서 BLE 앱은 장치에서 지원하는 GATT 서비스 및 특성을 연결, 표시 및 표시하는 활동 (DeviceControlActivity)을 제공합니다. 사용자 입력에 따라이 활동은 BluetoothLeService라는 서비스와 통신하며, 이 서비스는 Android BLE API를 통해 BLE 장치와 상호 작용합니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// A service that interacts with the BLE device via the Android BLE API.public class BluetoothLeService extends Service &#123; private final static String TAG = BluetoothLeService.class.getSimpleName(); private BluetoothManager bluetoothManager; private BluetoothAdapter bluetoothAdapter; private String bluetoothDeviceAddress; private BluetoothGatt bluetoothGatt; private int connectionState = STATE_DISCONNECTED; private static final int STATE_DISCONNECTED = 0; private static final int STATE_CONNECTING = 1; private static final int STATE_CONNECTED = 2; public final static String ACTION_GATT_CONNECTED = \"com.example.bluetooth.le.ACTION_GATT_CONNECTED\"; public final static String ACTION_GATT_DISCONNECTED = \"com.example.bluetooth.le.ACTION_GATT_DISCONNECTED\"; public final static String ACTION_GATT_SERVICES_DISCOVERED = \"com.example.bluetooth.le.ACTION_GATT_SERVICES_DISCOVERED\"; public final static String ACTION_DATA_AVAILABLE = \"com.example.bluetooth.le.ACTION_DATA_AVAILABLE\"; public final static String EXTRA_DATA = \"com.example.bluetooth.le.EXTRA_DATA\"; public final static UUID UUID_HEART_RATE_MEASUREMENT = UUID.fromString(SampleGattAttributes.HEART_RATE_MEASUREMENT); // Various callback methods defined by the BLE API. private final BluetoothGattCallback gattCallback = new BluetoothGattCallback() &#123; @Override public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) &#123; String intentAction; if (newState == BluetoothProfile.STATE_CONNECTED) &#123; intentAction = ACTION_GATT_CONNECTED; connectionState = STATE_CONNECTED; broadcastUpdate(intentAction); Log.i(TAG, \"Connected to GATT server.\"); Log.i(TAG, \"Attempting to start service discovery:\" + bluetoothGatt.discoverServices()); &#125; else if (newState == BluetoothProfile.STATE_DISCONNECTED) &#123; intentAction = ACTION_GATT_DISCONNECTED; connectionState = STATE_DISCONNECTED; Log.i(TAG, \"Disconnected from GATT server.\"); broadcastUpdate(intentAction); &#125; &#125; @Override // New services discovered public void onServicesDiscovered(BluetoothGatt gatt, int status) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_GATT_SERVICES_DISCOVERED); &#125; else &#123; Log.w(TAG, \"onServicesDiscovered received: \" + status); &#125; &#125; @Override // Result of a characteristic read operation public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) &#123; if (status == BluetoothGatt.GATT_SUCCESS) &#123; broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic); &#125; &#125; ... &#125;;...&#125; 특정 콜백이 트리거되면 적절한 broadcastUpdate() 헬퍼 메소드를 호출하고 액션을 전달합니다. 이 섹션의 데이터 구문 분석은 Bluetooth 심박수 측정 프로파일 사양에 따라 수행됩니다. 12345678910111213141516171819202122232425262728293031323334353637private void broadcastUpdate(final String action) &#123; final Intent intent = new Intent(action); sendBroadcast(intent);&#125;private void broadcastUpdate(final String action, final BluetoothGattCharacteristic characteristic) &#123; final Intent intent = new Intent(action); // This is special handling for the Heart Rate Measurement profile. Data // parsing is carried out as per profile specifications. if (UUID_HEART_RATE_MEASUREMENT.equals(characteristic.getUuid())) &#123; int flag = characteristic.getProperties(); int format = -1; if ((flag &amp; 0x01) != 0) &#123; format = BluetoothGattCharacteristic.FORMAT_UINT16; Log.d(TAG, \"Heart rate format UINT16.\"); &#125; else &#123; format = BluetoothGattCharacteristic.FORMAT_UINT8; Log.d(TAG, \"Heart rate format UINT8.\"); &#125; final int heartRate = characteristic.getIntValue(format, 1); Log.d(TAG, String.format(\"Received heart rate: %d\", heartRate)); intent.putExtra(EXTRA_DATA, String.valueOf(heartRate)); &#125; else &#123; // For all other profiles, writes the data formatted in HEX. final byte[] data = characteristic.getValue(); if (data != null &amp;&amp; data.length &gt; 0) &#123; final StringBuilder stringBuilder = new StringBuilder(data.length); for(byte byteChar : data) stringBuilder.append(String.format(\"%02X \", byteChar)); intent.putExtra(EXTRA_DATA, new String(data) + \"\\n\" + stringBuilder.toString()); &#125; &#125; sendBroadcast(intent);&#125; DeviceControlActivity로 돌아 가면이 이벤트는 BroadcastReceiver에 의해 처리됩니다. 1234567891011121314151617181920212223242526272829// Handles various events fired by the Service.// ACTION_GATT_CONNECTED: connected to a GATT server.// ACTION_GATT_DISCONNECTED: disconnected from a GATT server.// ACTION_GATT_SERVICES_DISCOVERED: discovered GATT services.// ACTION_DATA_AVAILABLE: received data from the device. This can be a// result of read or notification operations.private final BroadcastReceiver gattUpdateReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; final String action = intent.getAction(); if (BluetoothLeService.ACTION_GATT_CONNECTED.equals(action)) &#123; connected = true; updateConnectionState(R.string.connected); invalidateOptionsMenu(); &#125; else if (BluetoothLeService.ACTION_GATT_DISCONNECTED.equals(action)) &#123; connected = false; updateConnectionState(R.string.disconnected); invalidateOptionsMenu(); clearUI(); &#125; else if (BluetoothLeService. ACTION_GATT_SERVICES_DISCOVERED.equals(action)) &#123; // Show all the supported services and characteristics on the // user interface. displayGattServices(bluetoothLeService.getSupportedGattServices()); &#125; else if (BluetoothLeService.ACTION_DATA_AVAILABLE.equals(action)) &#123; displayData(intent.getStringExtra(BluetoothLeService.EXTRA_DATA)); &#125; &#125;&#125;; Read BLE attributesAndroid 앱이 GATT 서버에 연결되고 서비스를 발견하면 지원되는 경우 속성을 읽고 쓸 수 있습니다. 예를 들어 아래 예는 서버의 서비스와 특성을 반복하여 UI에 표시합니다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class DeviceControlActivity extends Activity &#123; ... // Demonstrates how to iterate through the supported GATT // Services/Characteristics. // In this sample, we populate the data structure that is bound to the // ExpandableListView on the UI. private void displayGattServices(List&lt;BluetoothGattService&gt; gattServices) &#123; if (gattServices == null) return; String uuid = null; String unknownServiceString = getResources(). getString(R.string.unknown_service); String unknownCharaString = getResources(). getString(R.string.unknown_characteristic); ArrayList&lt;HashMap&lt;String, String&gt;&gt; gattServiceData = new ArrayList&lt;HashMap&lt;String, String&gt;&gt;(); ArrayList&lt;ArrayList&lt;HashMap&lt;String, String&gt;&gt;&gt; gattCharacteristicData = new ArrayList&lt;ArrayList&lt;HashMap&lt;String, String&gt;&gt;&gt;(); mGattCharacteristics = new ArrayList&lt;ArrayList&lt;BluetoothGattCharacteristic&gt;&gt;(); // Loops through available GATT Services. for (BluetoothGattService gattService : gattServices) &#123; HashMap&lt;String, String&gt; currentServiceData = new HashMap&lt;String, String&gt;(); uuid = gattService.getUuid().toString(); currentServiceData.put( LIST_NAME, SampleGattAttributes. lookup(uuid, unknownServiceString)); currentServiceData.put(LIST_UUID, uuid); gattServiceData.add(currentServiceData); ArrayList&lt;HashMap&lt;String, String&gt;&gt; gattCharacteristicGroupData = new ArrayList&lt;HashMap&lt;String, String&gt;&gt;(); List&lt;BluetoothGattCharacteristic&gt; gattCharacteristics = gattService.getCharacteristics(); ArrayList&lt;BluetoothGattCharacteristic&gt; charas = new ArrayList&lt;BluetoothGattCharacteristic&gt;(); // Loops through available Characteristics. for (BluetoothGattCharacteristic gattCharacteristic : gattCharacteristics) &#123; charas.add(gattCharacteristic); HashMap&lt;String, String&gt; currentCharaData = new HashMap&lt;String, String&gt;(); uuid = gattCharacteristic.getUuid().toString(); currentCharaData.put( LIST_NAME, SampleGattAttributes.lookup(uuid, unknownCharaString)); currentCharaData.put(LIST_UUID, uuid); gattCharacteristicGroupData.add(currentCharaData); &#125; mGattCharacteristics.add(charas); gattCharacteristicData.add(gattCharacteristicGroupData); &#125; ... &#125;...&#125; Receive GATT notifications장치의 특정 characteristic가 변경 될 때 BLE 앱에 알림을 요청하는 것이 일반적입니다. 아래 예는 setCharacteristicNotification() 메소드를 사용하여 특성에 대한 알림을 설정하는 방법을 보여줍니다. 12345678910private BluetoothGatt bluetoothGatt;BluetoothGattCharacteristic characteristic;boolean enabled;...bluetoothGatt.setCharacteristicNotification(characteristic, enabled);...BluetoothGattDescriptor descriptor = characteristic.getDescriptor( UUID.fromString(SampleGattAttributes.CLIENT_CHARACTERISTIC_CONFIG));descriptor.setValue(BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE);bluetoothGatt.writeDescriptor(descriptor); 특성에 대한 알림이 활성화되면 원격 장치에서 특성이 변경되면 onCharacteristicChanged() 콜백이 트리거됩니다. 123456@Override// Characteristic notificationpublic void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) &#123; broadcastUpdate(ACTION_DATA_AVAILABLE, characteristic);&#125; Close the client app앱이 BLE 장치 사용을 마치면 close ()를 호출하여 시스템에서 리소스를 적절하게 해제 할 수 있습니다. 1234567public void close() &#123; if (bluetoothGatt == null) &#123; return; &#125; bluetoothGatt.close(); bluetoothGatt = null;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"BLE","slug":"Android/BLE","permalink":"http://jung-max.github.io/categories/Android/BLE/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"BLE","slug":"BLE","permalink":"http://jung-max.github.io/tags/BLE/"}]},{"title":"Android Kernel 가상 마우스 드라이버 구현하기","slug":"Android-kernel-가상-마우스-드라이버-구현하기","date":"2019-09-02T07:17:00.000Z","updated":"2022-02-08T02:11:11.751Z","comments":true,"path":"2019/09/02/Android-kernel-가상-마우스-드라이버-구현하기/","link":"","permalink":"http://jung-max.github.io/2019/09/02/Android-kernel-가상-마우스-드라이버-구현하기/","excerpt":"","text":"개요 가상 마우스 동작 방식은 다음과 같다. App이 마우스 동작의 좌표 정보를 sysfs노드인 /sys/devices/platform/virmouse/vmevent를 거쳐 가상 마우스 드라이버(virmouse.c)에 통지한다. 가상 마우스 드라이버는 evdev를 거쳐 이동 정보를 사용자 영역으로 보낸다. evdev란 범용 입력 이벤트 드라이버를 뜻한다. evdev가 생섯하는 각 이벤트 패킷은 include/linux/input.h에 정의되어 있다. gpm(general-purpose mouse)은 X 서버의 도움 없이 텍스트 환경에서 마우스 사용을 가능하게 하는 서버다. gpm이 evdev 메시지를 이해하므로 가상 마우스 드라이버는 gpm과 직접 의사소통이 가능하다. 초기화초기화 과정에서 가상마우스 드라이버는 자신을 입력장치 드라이버로 등록한다. 이를 위해 먼저 핵심 API인 input_allocate_device()를 사용해 input_dev 구조체를 할당한다. 123456/* Allocate an input device data structure */virmouse_input_dev = input_allocate_device();if (!virmouse_input_dev) &#123; printk(\"Bad input_allocate_device()\\n\"); return -ENOMEM;&#125; 그리고 상대적인 이벤트를 생성하는 주체가 가상 마우스라고 선언한다. 12/* 이벤트 형식은 EV_REL */set_bit(EV_REL, virmouse_input_dev-&gt;evbit); 다음으로 가상 마우스가 만드는 이벤트 코드를 선언한다. 123set_bit(REL_X, virmouse_input_dev-&gt;relbit); //상대적인 x 움직임set_bit(REL_Y, virmouse_input_dev-&gt;relbit); //상대적인 y 움직임set_bit(REL_WHEEL, virmouse_input_dev-&gt;relbit); //휠 움직임 다음은 가상마우스가 만드는 버튼 클릭이다. 1234set_bit(EV_KEY, virmouse_input_dev-&gt;evbit); //이벤트 형식은 EV_KEYset_bit(BTN_LEFT, virmouse_input_dev-&gt;keybit); //좌클릭set_bit(BTN_MIDDLE, virmouse_input_dev-&gt;keybit); //가운데 클릭set_bit(BTN_RIGHT, virmouse_input_dev-&gt;keybit); //우클릭 최종적으로 다음과 같이 등록한다. 12/* Register with the input subsystem */ret = input_register_device(virmouse_input_dev); writewrite_virmouse()는 /sys/devices/platform/virmouse/vmevent에 붙어있는 sysfs의 store() 메소드이다.App이 x y key값을 쓸때 다음 작업을 수행한다. x,y값 입력시 상대적 좌표 이동값을 입력한다. 123input_report_rel(virmouse_input_dev, REL_X, tmpx);input_report_rel(virmouse_input_dev, REL_Y, tmpy);input_sync(virmouse_input_dev); key입력시(여기선 좌클릭) key입력을 구현한다. 좌,우,가운에 클릭은 클릭시 1, 때었을때 0값이 들어간다. 그러므로 가상 마우스 클릭을 구현하려면 1,0파라미터 값이 순차적으로 들어가야 한다. 12345input_report_key(virmouse_input_dev, BTN_LEFT, 1);input_sync(virmouse_input_dev);msleep(10);input_report_key(virmouse_input_dev, BTN_LEFT, 0);input_sync(virmouse_input_dev); 이후 input_sync()가 이 이벤트가 끝났음을 가리킨다. 입력 하위시스템은 입력된 이벤트를 evdev 패킷 하나로 모아 /dev/input/eventX를 거쳐 밖으로 내보낸다. X는 가상 마우스 드라이버에 할당된 인터페이스 번호를 의미한다. 최종 구현 소스123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/* * A Virtual Mouse Driver to send fake events from userspace.*/#include &lt;linux/fs.h&gt;#include &lt;asm/uaccess.h&gt;#include &lt;linux/pci.h&gt;#include &lt;linux/input.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/delay.h&gt;struct input_dev *virmouse_input_dev;static struct platform_device *virmouse_dev; /* Device structure *//* Sysfs method to input simulated coordinates */static ssize_t write_virmouse(struct device *dev, struct device_attribute *attr, const char *buffer, size_t count)&#123; int x, y, key, tmpx, tmpy, i; /* parsing input data */ sscanf(buffer, \"%d%d%d\", &amp;x, &amp;y, &amp;key); /* Report relative coordinates */ printk (\"virmouse_event!!: X:%d Y:%d %d\\n\", x, y, key); /* Report key event */ if (key == 4) &#123; input_report_rel(virmouse_input_dev, REL_WHEEL, y); &#125;else if(key==1)&#123; input_report_key(virmouse_input_dev, BTN_LEFT, 1); input_sync(virmouse_input_dev); msleep(10); input_report_key(virmouse_input_dev, BTN_LEFT, 0); input_sync(virmouse_input_dev); &#125; else if (key==2)&#123; input_report_key(virmouse_input_dev, BTN_MIDDLE, 1); input_sync(virmouse_input_dev); msleep(10); input_report_key(virmouse_input_dev, BTN_MIDDLE, 0); input_sync(virmouse_input_dev); &#125; else if (key==3)&#123; input_report_key(virmouse_input_dev, BTN_RIGHT, 1); input_sync(virmouse_input_dev); msleep(10); input_report_key(virmouse_input_dev, BTN_RIGHT, 0); input_sync(virmouse_input_dev); &#125; else if(key==0)&#123; tmpx = x/3; tmpy = y/3; for(i = 0; i&lt;3; i++) &#123; input_report_rel(virmouse_input_dev, REL_X, tmpx); input_report_rel(virmouse_input_dev, REL_Y, tmpy); input_sync(virmouse_input_dev); msleep(5); &#125; &#125; return count;&#125;/* Attach the sysfs write method */DEVICE_ATTR(vmevent, 0644, NULL, write_virmouse);/* Attribute Descriptor */static struct attribute *virmouse_attrs[] = &#123; &amp;dev_attr_vmevent.attr, NULL&#125;;/* Attribute group */static struct attribute_group virmouse_attr_group = &#123; .attrs = virmouse_attrs,&#125;;/* Driver Initializing */int __init virmouse_init(void)&#123; int ret = 0; /* Register a platform device */ virmouse_dev = platform_device_register_simple(\"virmouse\", -1, NULL, 0); if (IS_ERR(virmouse_dev))&#123; printk (\"virmouse_init: error\\n\"); return PTR_ERR(virmouse_dev); &#125; /* Create a sysfs node to read simulated coordinates */ ret = sysfs_create_group(&amp;virmouse_dev-&gt;dev.kobj, &amp;virmouse_attr_group); /* Allocate an input device data structure */ virmouse_input_dev = input_allocate_device(); if (!virmouse_input_dev) &#123; printk(\"Bad input_allocate_device()\\n\"); return -ENOMEM; &#125; /* Announce that the virtual mouse will generate relative coordinates */ set_bit(EV_REL, virmouse_input_dev-&gt;evbit); set_bit(REL_X, virmouse_input_dev-&gt;relbit); set_bit(REL_Y, virmouse_input_dev-&gt;relbit); set_bit(REL_WHEEL, virmouse_input_dev-&gt;relbit); /* Announce key event */ set_bit(EV_KEY, virmouse_input_dev-&gt;evbit); set_bit(BTN_LEFT, virmouse_input_dev-&gt;keybit); set_bit(BTN_MIDDLE, virmouse_input_dev-&gt;keybit); set_bit(BTN_RIGHT, virmouse_input_dev-&gt;keybit); set_bit(BTN_0, virmouse_input_dev-&gt;keybit); /* Register with the input subsystem */ ret = input_register_device(virmouse_input_dev); /* print messages in the dmesg */ printk(\"Virtual Mouse Driver Initialized.\\n\"); return ret;&#125;/* Driver Uninitializing */void virmouse_uninit(void)&#123; /* Unregister from the input subsystem */ input_unregister_device(virmouse_input_dev); /* Remove sysfs node */ sysfs_remove_group(&amp;virmouse_dev-&gt;dev.kobj, &amp;virmouse_attr_group); /* Unregister driver */ platform_device_unregister(virmouse_dev); return;&#125;module_init(virmouse_init);module_exit(virmouse_uninit);","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Kernel","slug":"Android/Platform-Kernel","permalink":"http://jung-max.github.io/categories/Android/Platform-Kernel/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"}]},{"title":"Android NDK를 사용해서 kernel드라이버 사용하기","slug":"Android-NDK를-사용해서-kernel드라이버-사용하기","date":"2019-09-02T07:17:00.000Z","updated":"2022-02-08T02:11:11.769Z","comments":true,"path":"2019/09/02/Android-NDK를-사용해서-kernel드라이버-사용하기/","link":"","permalink":"http://jung-max.github.io/2019/09/02/Android-NDK를-사용해서-kernel드라이버-사용하기/","excerpt":"","text":"kernel의 드라이버를 쓰기 위해서는 driver 장치 파일의 write 권한이 있어야 한다.기본적으로 장치 파일의 write 권한은 플랫폼 소스에서 부팅시 *.rc파일을 수정해서 변경 가능하다. 여기서는 앱에서 write 권한을 취득하는 것부터 시작한다. 앱이 파일의 접근 권한을 변경하기 위해서는 su권한이 있어야 한다. 1234567891011121314151617181920212223Process process = null;DataOutputStream dataOutputStream = null;try &#123; process = Runtime.getRuntime().exec(\"su\"); dataOutputStream = new DataOutputStream(process.getOutputStream()); dataOutputStream.writeBytes(\"chmod 777 /sys/class/tidlp_i2c/i2c_w\\n\"); dataOutputStream.writeBytes(\"chmod 777 /sys/class/tidlp_i2c/i2c_r\\n\"); dataOutputStream.writeBytes(\"chmod 777 /sys/devices/platform/virmouse/vmevent\\n\"); dataOutputStream.writeBytes(\"exit\\n\"); dataOutputStream.flush(); process.waitFor();&#125; catch (Exception e) &#123;&#125; finally &#123; try &#123; if (dataOutputStream != null) &#123; dataOutputStream.close(); &#125; process.destroy(); &#125; catch (Exception e) &#123; &#125;&#125; 장치 파일의 write권한을 획득했으면 ndk를 사용해 c/c++ 파일에서 드라이버 관련 함수를 구현한다. 첫번째로 드라이버 장치파일을 open한다. 그 후 write를 통해 드라이버 장치파일에 값을 써주어서 드라이버를 동작한다. 1234567891011121314151617181920/* Brightness */extern \"C\" JNIEXPORT void JNICALLJava_ckbs_ywjung_btremocon_MainActivity_dlpBr( JNIEnv *env, jobject /* this */, jint k) &#123; static int br = 0; int fd; char buf[60]; char send_buff[100]; snprintf(buf, sizeof(buf), \"/sys/class/tidlp_i2c/i2c_w\"); fd = open(buf, O_RDWR); if (fd &gt; 0) &#123; br = k; sprintf(send_buff, \"0x80 0x1 0x%x\", br); write(fd, send_buff, strlen(send_buff)); close(fd); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"}]},{"title":"bluetooth로 받은 byte 데이터 분석하기","slug":"Android-bluetooth로-받은-byte-데이터-분석하기","date":"2019-09-02T02:42:00.000Z","updated":"2022-02-08T02:11:11.748Z","comments":true,"path":"2019/09/02/Android-bluetooth로-받은-byte-데이터-분석하기/","link":"","permalink":"http://jung-max.github.io/2019/09/02/Android-bluetooth로-받은-byte-데이터-분석하기/","excerpt":"","text":"앞서 client측에서 마우스 x,y데이터를 보낼때 사용했던 프로토콜을 예로 든다. 여기서 0번째 바이트는 마우스 이동인 것을 알려주기 위해 0x02로 온다.14 바이트는 x값, 58 바이트는 y값이다. 12345678910111213141516171819BufferedInputStream in = null;in = new BufferedInputStream(socket.getInputStream());byte[] buffer = new byte[1024];int bytes;bytes = in.read(buffer);if(buffer[0] == (byte)2)&#123; byte[] xbuffer = new byte[4]; byte[] ybuffer = new byte[4]; for(int i = 0; i&lt;4; i++)&#123; xbuffer[i] = buffer[1+i]; ybuffer[i] = buffer[5+i]; &#125; int x = byteToInt(xbuffer, ByteOrder.LITTLE_ENDIAN); int y = byteToInt(ybuffer, ByteOrder.LITTLE_ENDIAN); mouseMove(x, y);&#125; 바이트를 int로 바꾸기 위한 함수인 byteToInt는 아래와 같이 구현한다. 123456789101112131415public static int byteToInt(byte[] bytes, ByteOrder order) &#123; ByteBuffer buff = ByteBuffer.allocate(Integer.SIZE/8); buff.order(order); // buff사이즈는 4인 상태임 // bytes를 put하면 position과 limit는 같은 위치가 됨. buff.put(bytes); // flip()가 실행 되면 position은 0에 위치 하게 됨. buff.flip(); System.out.println(\"byteToInt : \" + buff); return buff.getInt(); // position위치(0)에서 부터 4바이트를 int로 변경하여 반환&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"bluetooth로 받은 byte 데이터 분석하기","slug":"Android-KeyEvent-발생하기","date":"2019-09-02T02:42:00.000Z","updated":"2022-02-08T02:11:11.761Z","comments":true,"path":"2019/09/02/Android-KeyEvent-발생하기/","link":"","permalink":"http://jung-max.github.io/2019/09/02/Android-KeyEvent-발생하기/","excerpt":"","text":"안드로이드의 Key 이벤트를 발생하기 위해선 INJECT_EVENTS가 필요하다. 해당 권한은 AndroidManifest.xml에 선언해 준다. 1&lt;uses-permission android:name=\"android.permission.INJECT_EVENTS\" /&gt; INJECT_EVENTS 권한을 취득하기 위해선 System App 권한이 필요하다. 관련 포스트는 여기를 참고한다. 그 후 Key event 발생을 위해서는 아래와 같이 Instrumentation().sendKeyDownUpSync()를 사용한다. 12345new Thread(new Runnable() &#123; public void run() &#123; new Instrumentation().sendKeyDownUpSync(KeyEvent.KEYCODE_MEDIA_PREVIOUS); &#125;&#125;).start(); 발생 가능한 KeyEvent는 아래를 참고한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730/** Key code constant: Unknown key code. */public static final int KEYCODE_UNKNOWN = 0;/** Key code constant: Soft Left key. * Usually situated below the display on phones and used as a multi-function * feature key for selecting a software defined function shown on the bottom left * of the display. */public static final int KEYCODE_SOFT_LEFT = 1;/** Key code constant: Soft Right key. * Usually situated below the display on phones and used as a multi-function * feature key for selecting a software defined function shown on the bottom right * of the display. */public static final int KEYCODE_SOFT_RIGHT = 2;/** Key code constant: Home key. * This key is handled by the framework and is never delivered to applications. */public static final int KEYCODE_HOME = 3;/** Key code constant: Back key. */public static final int KEYCODE_BACK = 4;/** Key code constant: Call key. */public static final int KEYCODE_CALL = 5;/** Key code constant: End Call key. */public static final int KEYCODE_ENDCALL = 6;/** Key code constant: '0' key. */public static final int KEYCODE_0 = 7;/** Key code constant: '1' key. */public static final int KEYCODE_1 = 8;/** Key code constant: '2' key. */public static final int KEYCODE_2 = 9;/** Key code constant: '3' key. */public static final int KEYCODE_3 = 10;/** Key code constant: '4' key. */public static final int KEYCODE_4 = 11;/** Key code constant: '5' key. */public static final int KEYCODE_5 = 12;/** Key code constant: '6' key. */public static final int KEYCODE_6 = 13;/** Key code constant: '7' key. */public static final int KEYCODE_7 = 14;/** Key code constant: '8' key. */public static final int KEYCODE_8 = 15;/** Key code constant: '9' key. */public static final int KEYCODE_9 = 16;/** Key code constant: '*' key. */public static final int KEYCODE_STAR = 17;/** Key code constant: '#' key. */public static final int KEYCODE_POUND = 18;/** Key code constant: Directional Pad Up key. * May also be synthesized from trackball motions. */public static final int KEYCODE_DPAD_UP = 19;/** Key code constant: Directional Pad Down key. * May also be synthesized from trackball motions. */public static final int KEYCODE_DPAD_DOWN = 20;/** Key code constant: Directional Pad Left key. * May also be synthesized from trackball motions. */public static final int KEYCODE_DPAD_LEFT = 21;/** Key code constant: Directional Pad Right key. * May also be synthesized from trackball motions. */public static final int KEYCODE_DPAD_RIGHT = 22;/** Key code constant: Directional Pad Center key. * May also be synthesized from trackball motions. */public static final int KEYCODE_DPAD_CENTER = 23;/** Key code constant: Volume Up key. * Adjusts the speaker volume up. */public static final int KEYCODE_VOLUME_UP = 24;/** Key code constant: Volume Down key. * Adjusts the speaker volume down. */public static final int KEYCODE_VOLUME_DOWN = 25;/** Key code constant: Power key. */public static final int KEYCODE_POWER = 26;/** Key code constant: Camera key. * Used to launch a camera application or take pictures. */public static final int KEYCODE_CAMERA = 27;/** Key code constant: Clear key. */public static final int KEYCODE_CLEAR = 28;/** Key code constant: 'A' key. */public static final int KEYCODE_A = 29;/** Key code constant: 'B' key. */public static final int KEYCODE_B = 30;/** Key code constant: 'C' key. */public static final int KEYCODE_C = 31;/** Key code constant: 'D' key. */public static final int KEYCODE_D = 32;/** Key code constant: 'E' key. */public static final int KEYCODE_E = 33;/** Key code constant: 'F' key. */public static final int KEYCODE_F = 34;/** Key code constant: 'G' key. */public static final int KEYCODE_G = 35;/** Key code constant: 'H' key. */public static final int KEYCODE_H = 36;/** Key code constant: 'I' key. */public static final int KEYCODE_I = 37;/** Key code constant: 'J' key. */public static final int KEYCODE_J = 38;/** Key code constant: 'K' key. */public static final int KEYCODE_K = 39;/** Key code constant: 'L' key. */public static final int KEYCODE_L = 40;/** Key code constant: 'M' key. */public static final int KEYCODE_M = 41;/** Key code constant: 'N' key. */public static final int KEYCODE_N = 42;/** Key code constant: 'O' key. */public static final int KEYCODE_O = 43;/** Key code constant: 'P' key. */public static final int KEYCODE_P = 44;/** Key code constant: 'Q' key. */public static final int KEYCODE_Q = 45;/** Key code constant: 'R' key. */public static final int KEYCODE_R = 46;/** Key code constant: 'S' key. */public static final int KEYCODE_S = 47;/** Key code constant: 'T' key. */public static final int KEYCODE_T = 48;/** Key code constant: 'U' key. */public static final int KEYCODE_U = 49;/** Key code constant: 'V' key. */public static final int KEYCODE_V = 50;/** Key code constant: 'W' key. */public static final int KEYCODE_W = 51;/** Key code constant: 'X' key. */public static final int KEYCODE_X = 52;/** Key code constant: 'Y' key. */public static final int KEYCODE_Y = 53;/** Key code constant: 'Z' key. */public static final int KEYCODE_Z = 54;/** Key code constant: ',' key. */public static final int KEYCODE_COMMA = 55;/** Key code constant: '.' key. */public static final int KEYCODE_PERIOD = 56;/** Key code constant: Left Alt modifier key. */public static final int KEYCODE_ALT_LEFT = 57;/** Key code constant: Right Alt modifier key. */public static final int KEYCODE_ALT_RIGHT = 58;/** Key code constant: Left Shift modifier key. */public static final int KEYCODE_SHIFT_LEFT = 59;/** Key code constant: Right Shift modifier key. */public static final int KEYCODE_SHIFT_RIGHT = 60;/** Key code constant: Tab key. */public static final int KEYCODE_TAB = 61;/** Key code constant: Space key. */public static final int KEYCODE_SPACE = 62;/** Key code constant: Symbol modifier key. * Used to enter alternate symbols. */public static final int KEYCODE_SYM = 63;/** Key code constant: Explorer special function key. * Used to launch a browser application. */public static final int KEYCODE_EXPLORER = 64;/** Key code constant: Envelope special function key. * Used to launch a mail application. */public static final int KEYCODE_ENVELOPE = 65;/** Key code constant: Enter key. */public static final int KEYCODE_ENTER = 66;/** Key code constant: Backspace key. * Deletes characters before the insertion point, unlike &#123;@link #KEYCODE_FORWARD_DEL&#125;. */public static final int KEYCODE_DEL = 67;/** Key code constant: '`' (backtick) key. */public static final int KEYCODE_GRAVE = 68;/** Key code constant: '-'. */public static final int KEYCODE_MINUS = 69;/** Key code constant: '=' key. */public static final int KEYCODE_EQUALS = 70;/** Key code constant: '[' key. */public static final int KEYCODE_LEFT_BRACKET = 71;/** Key code constant: ']' key. */public static final int KEYCODE_RIGHT_BRACKET = 72;/** Key code constant: '\\' key. */public static final int KEYCODE_BACKSLASH = 73;/** Key code constant: ';' key. */public static final int KEYCODE_SEMICOLON = 74;/** Key code constant: ''' (apostrophe) key. */public static final int KEYCODE_APOSTROPHE = 75;/** Key code constant: '/' key. */public static final int KEYCODE_SLASH = 76;/** Key code constant: '@' key. */public static final int KEYCODE_AT = 77;/** Key code constant: Number modifier key. * Used to enter numeric symbols. * This key is not Num Lock; it is more like &#123;@link #KEYCODE_ALT_LEFT&#125; and is * interpreted as an ALT key by &#123;@link android.text.method.MetaKeyKeyListener&#125;. */public static final int KEYCODE_NUM = 78;/** Key code constant: Headset Hook key. * Used to hang up calls and stop media. */public static final int KEYCODE_HEADSETHOOK = 79;/** Key code constant: Camera Focus key. * Used to focus the camera. */public static final int KEYCODE_FOCUS = 80; // *Camera* focus/** Key code constant: '+' key. */public static final int KEYCODE_PLUS = 81;/** Key code constant: Menu key. */public static final int KEYCODE_MENU = 82;/** Key code constant: Notification key. */public static final int KEYCODE_NOTIFICATION = 83;/** Key code constant: Search key. */public static final int KEYCODE_SEARCH = 84;/** Key code constant: Play/Pause media key. */public static final int KEYCODE_MEDIA_PLAY_PAUSE= 85;/** Key code constant: Stop media key. */public static final int KEYCODE_MEDIA_STOP = 86;/** Key code constant: Play Next media key. */public static final int KEYCODE_MEDIA_NEXT = 87;/** Key code constant: Play Previous media key. */public static final int KEYCODE_MEDIA_PREVIOUS = 88;/** Key code constant: Rewind media key. */public static final int KEYCODE_MEDIA_REWIND = 89;/** Key code constant: Fast Forward media key. */public static final int KEYCODE_MEDIA_FAST_FORWARD = 90;/** Key code constant: Mute key. * Mutes the microphone, unlike &#123;@link #KEYCODE_VOLUME_MUTE&#125;. */public static final int KEYCODE_MUTE = 91;/** Key code constant: Page Up key. */public static final int KEYCODE_PAGE_UP = 92;/** Key code constant: Page Down key. */public static final int KEYCODE_PAGE_DOWN = 93;/** Key code constant: Picture Symbols modifier key. * Used to switch symbol sets (Emoji, Kao-moji). */public static final int KEYCODE_PICTSYMBOLS = 94; // switch symbol-sets (Emoji,Kao-moji)/** Key code constant: Switch Charset modifier key. * Used to switch character sets (Kanji, Katakana). */public static final int KEYCODE_SWITCH_CHARSET = 95; // switch char-sets (Kanji,Katakana)/** Key code constant: A Button key. * On a game controller, the A button should be either the button labeled A * or the first button on the bottom row of controller buttons. */public static final int KEYCODE_BUTTON_A = 96;/** Key code constant: B Button key. * On a game controller, the B button should be either the button labeled B * or the second button on the bottom row of controller buttons. */public static final int KEYCODE_BUTTON_B = 97;/** Key code constant: C Button key. * On a game controller, the C button should be either the button labeled C * or the third button on the bottom row of controller buttons. */public static final int KEYCODE_BUTTON_C = 98;/** Key code constant: X Button key. * On a game controller, the X button should be either the button labeled X * or the first button on the upper row of controller buttons. */public static final int KEYCODE_BUTTON_X = 99;/** Key code constant: Y Button key. * On a game controller, the Y button should be either the button labeled Y * or the second button on the upper row of controller buttons. */public static final int KEYCODE_BUTTON_Y = 100;/** Key code constant: Z Button key. * On a game controller, the Z button should be either the button labeled Z * or the third button on the upper row of controller buttons. */public static final int KEYCODE_BUTTON_Z = 101;/** Key code constant: L1 Button key. * On a game controller, the L1 button should be either the button labeled L1 (or L) * or the top left trigger button. */public static final int KEYCODE_BUTTON_L1 = 102;/** Key code constant: R1 Button key. * On a game controller, the R1 button should be either the button labeled R1 (or R) * or the top right trigger button. */public static final int KEYCODE_BUTTON_R1 = 103;/** Key code constant: L2 Button key. * On a game controller, the L2 button should be either the button labeled L2 * or the bottom left trigger button. */public static final int KEYCODE_BUTTON_L2 = 104;/** Key code constant: R2 Button key. * On a game controller, the R2 button should be either the button labeled R2 * or the bottom right trigger button. */public static final int KEYCODE_BUTTON_R2 = 105;/** Key code constant: Left Thumb Button key. * On a game controller, the left thumb button indicates that the left (or only) * joystick is pressed. */public static final int KEYCODE_BUTTON_THUMBL = 106;/** Key code constant: Right Thumb Button key. * On a game controller, the right thumb button indicates that the right * joystick is pressed. */public static final int KEYCODE_BUTTON_THUMBR = 107;/** Key code constant: Start Button key. * On a game controller, the button labeled Start. */public static final int KEYCODE_BUTTON_START = 108;/** Key code constant: Select Button key. * On a game controller, the button labeled Select. */public static final int KEYCODE_BUTTON_SELECT = 109;/** Key code constant: Mode Button key. * On a game controller, the button labeled Mode. */public static final int KEYCODE_BUTTON_MODE = 110;/** Key code constant: Escape key. */public static final int KEYCODE_ESCAPE = 111;/** Key code constant: Forward Delete key. * Deletes characters ahead of the insertion point, unlike &#123;@link #KEYCODE_DEL&#125;. */public static final int KEYCODE_FORWARD_DEL = 112;/** Key code constant: Left Control modifier key. */public static final int KEYCODE_CTRL_LEFT = 113;/** Key code constant: Right Control modifier key. */public static final int KEYCODE_CTRL_RIGHT = 114;/** Key code constant: Caps Lock key. */public static final int KEYCODE_CAPS_LOCK = 115;/** Key code constant: Scroll Lock key. */public static final int KEYCODE_SCROLL_LOCK = 116;/** Key code constant: Left Meta modifier key. */public static final int KEYCODE_META_LEFT = 117;/** Key code constant: Right Meta modifier key. */public static final int KEYCODE_META_RIGHT = 118;/** Key code constant: Function modifier key. */public static final int KEYCODE_FUNCTION = 119;/** Key code constant: System Request / Print Screen key. */public static final int KEYCODE_SYSRQ = 120;/** Key code constant: Break / Pause key. */public static final int KEYCODE_BREAK = 121;/** Key code constant: Home Movement key. * Used for scrolling or moving the cursor around to the start of a line * or to the top of a list. */public static final int KEYCODE_MOVE_HOME = 122;/** Key code constant: End Movement key. * Used for scrolling or moving the cursor around to the end of a line * or to the bottom of a list. */public static final int KEYCODE_MOVE_END = 123;/** Key code constant: Insert key. * Toggles insert / overwrite edit mode. */public static final int KEYCODE_INSERT = 124;/** Key code constant: Forward key. * Navigates forward in the history stack. Complement of &#123;@link #KEYCODE_BACK&#125;. */public static final int KEYCODE_FORWARD = 125;/** Key code constant: Play media key. */public static final int KEYCODE_MEDIA_PLAY = 126;/** Key code constant: Pause media key. */public static final int KEYCODE_MEDIA_PAUSE = 127;/** Key code constant: Close media key. * May be used to close a CD tray, for example. */public static final int KEYCODE_MEDIA_CLOSE = 128;/** Key code constant: Eject media key. * May be used to eject a CD tray, for example. */public static final int KEYCODE_MEDIA_EJECT = 129;/** Key code constant: Record media key. */public static final int KEYCODE_MEDIA_RECORD = 130;/** Key code constant: F1 key. */public static final int KEYCODE_F1 = 131;/** Key code constant: F2 key. */public static final int KEYCODE_F2 = 132;/** Key code constant: F3 key. */public static final int KEYCODE_F3 = 133;/** Key code constant: F4 key. */public static final int KEYCODE_F4 = 134;/** Key code constant: F5 key. */public static final int KEYCODE_F5 = 135;/** Key code constant: F6 key. */public static final int KEYCODE_F6 = 136;/** Key code constant: F7 key. */public static final int KEYCODE_F7 = 137;/** Key code constant: F8 key. */public static final int KEYCODE_F8 = 138;/** Key code constant: F9 key. */public static final int KEYCODE_F9 = 139;/** Key code constant: F10 key. */public static final int KEYCODE_F10 = 140;/** Key code constant: F11 key. */public static final int KEYCODE_F11 = 141;/** Key code constant: F12 key. */public static final int KEYCODE_F12 = 142;/** Key code constant: Num Lock key. * This is the Num Lock key; it is different from &#123;@link #KEYCODE_NUM&#125;. * This key alters the behavior of other keys on the numeric keypad. */public static final int KEYCODE_NUM_LOCK = 143;/** Key code constant: Numeric keypad '0' key. */public static final int KEYCODE_NUMPAD_0 = 144;/** Key code constant: Numeric keypad '1' key. */public static final int KEYCODE_NUMPAD_1 = 145;/** Key code constant: Numeric keypad '2' key. */public static final int KEYCODE_NUMPAD_2 = 146;/** Key code constant: Numeric keypad '3' key. */public static final int KEYCODE_NUMPAD_3 = 147;/** Key code constant: Numeric keypad '4' key. */public static final int KEYCODE_NUMPAD_4 = 148;/** Key code constant: Numeric keypad '5' key. */public static final int KEYCODE_NUMPAD_5 = 149;/** Key code constant: Numeric keypad '6' key. */public static final int KEYCODE_NUMPAD_6 = 150;/** Key code constant: Numeric keypad '7' key. */public static final int KEYCODE_NUMPAD_7 = 151;/** Key code constant: Numeric keypad '8' key. */public static final int KEYCODE_NUMPAD_8 = 152;/** Key code constant: Numeric keypad '9' key. */public static final int KEYCODE_NUMPAD_9 = 153;/** Key code constant: Numeric keypad '/' key (for division). */public static final int KEYCODE_NUMPAD_DIVIDE = 154;/** Key code constant: Numeric keypad '*' key (for multiplication). */public static final int KEYCODE_NUMPAD_MULTIPLY = 155;/** Key code constant: Numeric keypad '-' key (for subtraction). */public static final int KEYCODE_NUMPAD_SUBTRACT = 156;/** Key code constant: Numeric keypad '+' key (for addition). */public static final int KEYCODE_NUMPAD_ADD = 157;/** Key code constant: Numeric keypad '.' key (for decimals or digit grouping). */public static final int KEYCODE_NUMPAD_DOT = 158;/** Key code constant: Numeric keypad ',' key (for decimals or digit grouping). */public static final int KEYCODE_NUMPAD_COMMA = 159;/** Key code constant: Numeric keypad Enter key. */public static final int KEYCODE_NUMPAD_ENTER = 160;/** Key code constant: Numeric keypad '=' key. */public static final int KEYCODE_NUMPAD_EQUALS = 161;/** Key code constant: Numeric keypad '(' key. */public static final int KEYCODE_NUMPAD_LEFT_PAREN = 162;/** Key code constant: Numeric keypad ')' key. */public static final int KEYCODE_NUMPAD_RIGHT_PAREN = 163;/** Key code constant: Volume Mute key. * Mutes the speaker, unlike &#123;@link #KEYCODE_MUTE&#125;. * This key should normally be implemented as a toggle such that the first press * mutes the speaker and the second press restores the original volume. */public static final int KEYCODE_VOLUME_MUTE = 164;/** Key code constant: Info key. * Common on TV remotes to show additional information related to what is * currently being viewed. */public static final int KEYCODE_INFO = 165;/** Key code constant: Channel up key. * On TV remotes, increments the television channel. */public static final int KEYCODE_CHANNEL_UP = 166;/** Key code constant: Channel down key. * On TV remotes, decrements the television channel. */public static final int KEYCODE_CHANNEL_DOWN = 167;/** Key code constant: Zoom in key. */public static final int KEYCODE_ZOOM_IN = 168;/** Key code constant: Zoom out key. */public static final int KEYCODE_ZOOM_OUT = 169;/** Key code constant: TV key. * On TV remotes, switches to viewing live TV. */public static final int KEYCODE_TV = 170;/** Key code constant: Window key. * On TV remotes, toggles picture-in-picture mode or other windowing functions. * On Android Wear devices, triggers a display offset. */public static final int KEYCODE_WINDOW = 171;/** Key code constant: Guide key. * On TV remotes, shows a programming guide. */public static final int KEYCODE_GUIDE = 172;/** Key code constant: DVR key. * On some TV remotes, switches to a DVR mode for recorded shows. */public static final int KEYCODE_DVR = 173;/** Key code constant: Bookmark key. * On some TV remotes, bookmarks content or web pages. */public static final int KEYCODE_BOOKMARK = 174;/** Key code constant: Toggle captions key. * Switches the mode for closed-captioning text, for example during television shows. */public static final int KEYCODE_CAPTIONS = 175;/** Key code constant: Settings key. * Starts the system settings activity. */public static final int KEYCODE_SETTINGS = 176;/** Key code constant: TV power key. * On TV remotes, toggles the power on a television screen. */public static final int KEYCODE_TV_POWER = 177;/** Key code constant: TV input key. * On TV remotes, switches the input on a television screen. */public static final int KEYCODE_TV_INPUT = 178;/** Key code constant: Set-top-box power key. * On TV remotes, toggles the power on an external Set-top-box. */public static final int KEYCODE_STB_POWER = 179;/** Key code constant: Set-top-box input key. * On TV remotes, switches the input mode on an external Set-top-box. */public static final int KEYCODE_STB_INPUT = 180;/** Key code constant: A/V Receiver power key. * On TV remotes, toggles the power on an external A/V Receiver. */public static final int KEYCODE_AVR_POWER = 181;/** Key code constant: A/V Receiver input key. * On TV remotes, switches the input mode on an external A/V Receiver. */public static final int KEYCODE_AVR_INPUT = 182;/** Key code constant: Red \"programmable\" key. * On TV remotes, acts as a contextual/programmable key. */public static final int KEYCODE_PROG_RED = 183;/** Key code constant: Green \"programmable\" key. * On TV remotes, actsas a contextual/programmable key. */public static final int KEYCODE_PROG_GREEN = 184;/** Key code constant: Yellow \"programmable\" key. * On TV remotes, acts as a contextual/programmable key. */public static final int KEYCODE_PROG_YELLOW = 185;/** Key code constant: Blue \"programmable\" key. * On TV remotes, acts as a contextual/programmable key. */public static final int KEYCODE_PROG_BLUE = 186;/** Key code constant: App switch key. * Should bring up the application switcher dialog. */public static final int KEYCODE_APP_SWITCH = 187;/** Key code constant: Generic Game Pad Button #1.*/public static final int KEYCODE_BUTTON_1 = 188;/** Key code constant: Generic Game Pad Button #2.*/public static final int KEYCODE_BUTTON_2 = 189;/** Key code constant: Generic Game Pad Button #3.*/public static final int KEYCODE_BUTTON_3 = 190;/** Key code constant: Generic Game Pad Button #4.*/public static final int KEYCODE_BUTTON_4 = 191;/** Key code constant: Generic Game Pad Button #5.*/public static final int KEYCODE_BUTTON_5 = 192;/** Key code constant: Generic Game Pad Button #6.*/public static final int KEYCODE_BUTTON_6 = 193;/** Key code constant: Generic Game Pad Button #7.*/public static final int KEYCODE_BUTTON_7 = 194;/** Key code constant: Generic Game Pad Button #8.*/public static final int KEYCODE_BUTTON_8 = 195;/** Key code constant: Generic Game Pad Button #9.*/public static final int KEYCODE_BUTTON_9 = 196;/** Key code constant: Generic Game Pad Button #10.*/public static final int KEYCODE_BUTTON_10 = 197;/** Key code constant: Generic Game Pad Button #11.*/public static final int KEYCODE_BUTTON_11 = 198;/** Key code constant: Generic Game Pad Button #12.*/public static final int KEYCODE_BUTTON_12 = 199;/** Key code constant: Generic Game Pad Button #13.*/public static final int KEYCODE_BUTTON_13 = 200;/** Key code constant: Generic Game Pad Button #14.*/public static final int KEYCODE_BUTTON_14 = 201;/** Key code constant: Generic Game Pad Button #15.*/public static final int KEYCODE_BUTTON_15 = 202;/** Key code constant: Generic Game Pad Button #16.*/public static final int KEYCODE_BUTTON_16 = 203;/** Key code constant: Language Switch key. * Toggles the current input language such as switching between English and Japanese on * a QWERTY keyboard. On some devices, the same function may be performed by * pressing Shift+Spacebar. */public static final int KEYCODE_LANGUAGE_SWITCH = 204;/** Key code constant: Manner Mode key. * Toggles silent or vibrate mode on and off to make the device behave more politely * in certain settings such as on a crowded train. On some devices, the key may only * operate when long-pressed. */public static final int KEYCODE_MANNER_MODE = 205;/** Key code constant: 3D Mode key. * Toggles the display between 2D and 3D mode. */public static final int KEYCODE_3D_MODE = 206;/** Key code constant: Contacts special function key. * Used to launch an address book application. */public static final int KEYCODE_CONTACTS = 207;/** Key code constant: Calendar special function key. * Used to launch a calendar application. */public static final int KEYCODE_CALENDAR = 208;/** Key code constant: Music special function key. * Used to launch a music player application. */public static final int KEYCODE_MUSIC = 209;/** Key code constant: Calculator special function key. * Used to launch a calculator application. */public static final int KEYCODE_CALCULATOR = 210;/** Key code constant: Japanese full-width / half-width key. */public static final int KEYCODE_ZENKAKU_HANKAKU = 211;/** Key code constant: Japanese alphanumeric key. */public static final int KEYCODE_EISU = 212;/** Key code constant: Japanese non-conversion key. */public static final int KEYCODE_MUHENKAN = 213;/** Key code constant: Japanese conversion key. */public static final int KEYCODE_HENKAN = 214;/** Key code constant: Japanese katakana / hiragana key. */public static final int KEYCODE_KATAKANA_HIRAGANA = 215;/** Key code constant: Japanese Yen key. */public static final int KEYCODE_YEN = 216;/** Key code constant: Japanese Ro key. */public static final int KEYCODE_RO = 217;/** Key code constant: Japanese kana key. */public static final int KEYCODE_KANA = 218;/** Key code constant: Assist key. * Launches the global assist activity. Not delivered to applications. */public static final int KEYCODE_ASSIST = 219;/** Key code constant: Brightness Down key. * Adjusts the screen brightness down. */public static final int KEYCODE_BRIGHTNESS_DOWN = 220;/** Key code constant: Brightness Up key. * Adjusts the screen brightness up. */public static final int KEYCODE_BRIGHTNESS_UP = 221;/** Key code constant: Audio Track key. * Switches the audio tracks. */public static final int KEYCODE_MEDIA_AUDIO_TRACK = 222;/** Key code constant: Sleep key. * Puts the device to sleep. Behaves somewhat like &#123;@link #KEYCODE_POWER&#125; but it * has no effect if the device is already asleep. */public static final int KEYCODE_SLEEP = 223;/** Key code constant: Wakeup key. * Wakes up the device. Behaves somewhat like &#123;@link #KEYCODE_POWER&#125; but it * has no effect if the device is already awake. */public static final int KEYCODE_WAKEUP = 224;/** Key code constant: Pairing key. * Initiates peripheral pairing mode. Useful for pairing remote control * devices or game controllers, especially if no other input mode is * available. */public static final int KEYCODE_PAIRING = 225;/** Key code constant: Media Top Menu key. * Goes to the top of media menu. */public static final int KEYCODE_MEDIA_TOP_MENU = 226;/** Key code constant: '11' key. */public static final int KEYCODE_11 = 227;/** Key code constant: '12' key. */public static final int KEYCODE_12 = 228;/** Key code constant: Last Channel key. * Goes to the last viewed channel. */public static final int KEYCODE_LAST_CHANNEL = 229;/** Key code constant: TV data service key. * Displays data services like weather, sports. */public static final int KEYCODE_TV_DATA_SERVICE = 230;/** Key code constant: Voice Assist key. * Launches the global voice assist activity. Not delivered to applications. */public static final int KEYCODE_VOICE_ASSIST = 231;/** Key code constant: Radio key. * Toggles TV service / Radio service. */public static final int KEYCODE_TV_RADIO_SERVICE = 232;/** Key code constant: Teletext key. * Displays Teletext service. */public static final int KEYCODE_TV_TELETEXT = 233;/** Key code constant: Number entry key. * Initiates to enter multi-digit channel nubmber when each digit key is assigned * for selecting separate channel. Corresponds to Number Entry Mode (0x1D) of CEC * User Control Code. */public static final int KEYCODE_TV_NUMBER_ENTRY = 234;/** Key code constant: Analog Terrestrial key. * Switches to analog terrestrial broadcast service. */public static final int KEYCODE_TV_TERRESTRIAL_ANALOG = 235;/** Key code constant: Digital Terrestrial key. * Switches to digital terrestrial broadcast service. */public static final int KEYCODE_TV_TERRESTRIAL_DIGITAL = 236;/** Key code constant: Satellite key. * Switches to digital satellite broadcast service. */public static final int KEYCODE_TV_SATELLITE = 237;/** Key code constant: BS key. * Switches to BS digital satellite broadcasting service available in Japan. */public static final int KEYCODE_TV_SATELLITE_BS = 238;/** Key code constant: CS key. * Switches to CS digital satellite broadcasting service available in Japan. */public static final int KEYCODE_TV_SATELLITE_CS = 239;/** Key code constant: BS/CS key. * Toggles between BS and CS digital satellite services. */public static final int KEYCODE_TV_SATELLITE_SERVICE = 240;/** Key code constant: Toggle Network key. * Toggles selecting broacast services. */public static final int KEYCODE_TV_NETWORK = 241;/** Key code constant: Antenna/Cable key. * Toggles broadcast input source between antenna and cable. */public static final int KEYCODE_TV_ANTENNA_CABLE = 242;/** Key code constant: HDMI #1 key. * Switches to HDMI input #1. */public static final int KEYCODE_TV_INPUT_HDMI_1 = 243;/** Key code constant: HDMI #2 key. * Switches to HDMI input #2. */public static final int KEYCODE_TV_INPUT_HDMI_2 = 244;/** Key code constant: HDMI #3 key. * Switches to HDMI input #3. */public static final int KEYCODE_TV_INPUT_HDMI_3 = 245;/** Key code constant: HDMI #4 key. * Switches to HDMI input #4. */public static final int KEYCODE_TV_INPUT_HDMI_4 = 246;/** Key code constant: Composite #1 key. * Switches to composite video input #1. */public static final int KEYCODE_TV_INPUT_COMPOSITE_1 = 247;/** Key code constant: Composite #2 key. * Switches to composite video input #2. */public static final int KEYCODE_TV_INPUT_COMPOSITE_2 = 248;/** Key code constant: Component #1 key. * Switches to component video input #1. */public static final int KEYCODE_TV_INPUT_COMPONENT_1 = 249;/** Key code constant: Component #2 key. * Switches to component video input #2. */public static final int KEYCODE_TV_INPUT_COMPONENT_2 = 250;/** Key code constant: VGA #1 key. * Switches to VGA (analog RGB) input #1. */public static final int KEYCODE_TV_INPUT_VGA_1 = 251;/** Key code constant: Audio description key. * Toggles audio description off / on. */public static final int KEYCODE_TV_AUDIO_DESCRIPTION = 252;/** Key code constant: Audio description mixing volume up key. * Louden audio description volume as compared with normal audio volume. */public static final int KEYCODE_TV_AUDIO_DESCRIPTION_MIX_UP = 253;/** Key code constant: Audio description mixing volume down key. * Lessen audio description volume as compared with normal audio volume. */public static final int KEYCODE_TV_AUDIO_DESCRIPTION_MIX_DOWN = 254;/** Key code constant: Zoom mode key. * Changes Zoom mode (Normal, Full, Zoom, Wide-zoom, etc.) */public static final int KEYCODE_TV_ZOOM_MODE = 255;/** Key code constant: Contents menu key. * Goes to the title list. Corresponds to Contents Menu (0x0B) of CEC User Control * Code */public static final int KEYCODE_TV_CONTENTS_MENU = 256;/** Key code constant: Media context menu key. * Goes to the context menu of media contents. Corresponds to Media Context-sensitive * Menu (0x11) of CEC User Control Code. */public static final int KEYCODE_TV_MEDIA_CONTEXT_MENU = 257;/** Key code constant: Timer programming key. * Goes to the timer recording menu. Corresponds to Timer Programming (0x54) of * CEC User Control Code. */public static final int KEYCODE_TV_TIMER_PROGRAMMING = 258;/** Key code constant: Help key. */public static final int KEYCODE_HELP = 259;/** Key code constant: Navigate to previous key. * Goes backward by one item in an ordered collection of items. */public static final int KEYCODE_NAVIGATE_PREVIOUS = 260;/** Key code constant: Navigate to next key. * Advances to the next item in an ordered collection of items. */public static final int KEYCODE_NAVIGATE_NEXT = 261;/** Key code constant: Navigate in key. * Activates the item that currently has focus or expands to the next level of a navigation * hierarchy. */public static final int KEYCODE_NAVIGATE_IN = 262;/** Key code constant: Navigate out key. * Backs out one level of a navigation hierarchy or collapses the item that currently has * focus. */public static final int KEYCODE_NAVIGATE_OUT = 263;/** Key code constant: Primary stem key for Wear * Main power/reset button on watch. */public static final int KEYCODE_STEM_PRIMARY = 264;/** Key code constant: Generic stem key 1 for Wear */public static final int KEYCODE_STEM_1 = 265;/** Key code constant: Generic stem key 2 for Wear */public static final int KEYCODE_STEM_2 = 266;/** Key code constant: Generic stem key 3 for Wear */public static final int KEYCODE_STEM_3 = 267;/** Key code constant: Directional Pad Up-Left */public static final int KEYCODE_DPAD_UP_LEFT = 268;/** Key code constant: Directional Pad Down-Left */public static final int KEYCODE_DPAD_DOWN_LEFT = 269;/** Key code constant: Directional Pad Up-Right */public static final int KEYCODE_DPAD_UP_RIGHT = 270;/** Key code constant: Directional Pad Down-Right */public static final int KEYCODE_DPAD_DOWN_RIGHT = 271;/** Key code constant: Skip forward media key. */public static final int KEYCODE_MEDIA_SKIP_FORWARD = 272;/** Key code constant: Skip backward media key. */public static final int KEYCODE_MEDIA_SKIP_BACKWARD = 273;/** Key code constant: Step forward media key. * Steps media forward, one frame at a time. */public static final int KEYCODE_MEDIA_STEP_FORWARD = 274;/** Key code constant: Step backward media key. * Steps media backward, one frame at a time. */public static final int KEYCODE_MEDIA_STEP_BACKWARD = 275;/** Key code constant: put device to sleep unless a wakelock is held. */public static final int KEYCODE_SOFT_SLEEP = 276;/** Key code constant: Cut key. */public static final int KEYCODE_CUT = 277;/** Key code constant: Copy key. */public static final int KEYCODE_COPY = 278;/** Key code constant: Paste key. */public static final int KEYCODE_PASTE = 279;/** Key code constant: Consumed by the system for navigation up */public static final int KEYCODE_SYSTEM_NAVIGATION_UP = 280;/** Key code constant: Consumed by the system for navigation down */public static final int KEYCODE_SYSTEM_NAVIGATION_DOWN = 281;/** Key code constant: Consumed by the system for navigation left*/public static final int KEYCODE_SYSTEM_NAVIGATION_LEFT = 282;/** Key code constant: Consumed by the system for navigation right */public static final int KEYCODE_SYSTEM_NAVIGATION_RIGHT = 283;/** Key code constant: Show all apps */public static final int KEYCODE_ALL_APPS = 284;/** Key code constant: Refresh key. */public static final int KEYCODE_REFRESH = 285;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"bluetooth로 받은 byte 데이터 분석하기","slug":"Android-bluetooth로-받은-string-데이터-분석하기","date":"2019-09-02T02:42:00.000Z","updated":"2022-02-08T02:11:11.748Z","comments":true,"path":"2019/09/02/Android-bluetooth로-받은-string-데이터-분석하기/","link":"","permalink":"http://jung-max.github.io/2019/09/02/Android-bluetooth로-받은-string-데이터-분석하기/","excerpt":"","text":"bluetooth로 받은 데이터는 기본적으로 byte형태이다. String 데이터를 받았다면 String 형으로 변형이 필요하다. 12345678910111213141516BufferedInputStream in = null;in = new BufferedInputStream(socket.getInputStream());byte[] buffer = new byte[1024];int bytes;bytes = in.read(buffer);String readStr = new String(buffer, 0, bytes);/* 파싱된 String을 분석하여 필요한 함수 실행 */if (readStr.contains(\"pw\")) &#123; String arr[] = readStr.split(\":\"); int value = Integer.valueOf(arr[1]); dlpCu(value);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"App에서 서비스 구동 방법","slug":"Android-App에서-서비스-구동","date":"2019-09-02T02:17:00.000Z","updated":"2022-02-08T02:11:11.720Z","comments":true,"path":"2019/09/02/Android-App에서-서비스-구동/","link":"","permalink":"http://jung-max.github.io/2019/09/02/Android-App에서-서비스-구동/","excerpt":"","text":"서비스 생성Android Studio에서 java폴더를 우클릭해 Service를 생성한다. 그 후 MainActivity에서 intent를 사용 서비스를 시작한다. 12345678@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(this, MyService.class); startService(intent);&#125; 서비스 구동시 실행 동작 구현서비스 구동시 실행 동작은 Service의 생성자에 구현하면 된다. 1234567891011public class MyService extends Service &#123; public MyService() &#123; /* 구동시 실행 동작 구현 */ &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(\"Not yet implemented\"); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"bluetooth 클라이언트쪽 스레드 구현","slug":"Android-bluetooth-클라이언트쪽-스레드-구현","date":"2019-09-02T01:54:00.000Z","updated":"2022-02-08T02:11:11.737Z","comments":true,"path":"2019/09/02/Android-bluetooth-클라이언트쪽-스레드-구현/","link":"","permalink":"http://jung-max.github.io/2019/09/02/Android-bluetooth-클라이언트쪽-스레드-구현/","excerpt":"","text":"client thread 생성device 리스트에서 device가 선택되면 그 정보를 가지고 ClientThread를 시작한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546for (BluetoothDevice device : devices) &#123; if (device.getName().equals(selectDeivceStr)) &#123; MainActivity.this.device = device; showProgressDialgo(device.getName()); if(socket != null)&#123; try &#123; if (writeThread != null) &#123; writeHandler.getLooper().quit(); &#125; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); ClientThread clientThread = new ClientThread(); clientThread.start(); &#125;&#125;class ClientThread extends Thread &#123; @Override public void run() &#123; try &#123; bluetoothAdapter.cancelDiscovery(); socket = device.createRfcommSocketToServiceRecord(MY_UUID); socket.connect(); if (readThread != null) &#123; readFlag = false; &#125; readThread = new ReadThread(socket); readThread.start(); if (writeThread != null) &#123; writeHandler.getLooper().quit(); &#125; writeThread = new WriteThread(socket); writeThread.start(); socketIsConnected = new SocketIsConnected(socket); socketIsConnected.start(); isConnected = true; //최초에 연결 되었다는 신호 보낸다. isConnectMessage = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ClientThread는 UUID 정보를 사용해서 socket을 생성하고 server와 연결한다. 또한 ReadThread와 WriteThread를 생성한다. ReadThreadReadThread는 server에서 온 데이터를 읽기 위한 Thread이다.BufferedInputStream을 사용하고 read()함수로 데이터를 받아온다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445class ReadThread extends Thread &#123; BluetoothSocket socket; BufferedInputStream in = null; public ReadThread(BluetoothSocket socket) &#123; this.socket = socket; try &#123; in = new BufferedInputStream(socket.getInputStream()); &#125; catch (Exception e) &#123; &#125; &#125; @Override public void run() &#123; while (readFlag) &#123; try &#123; byte[] buffer = new byte[1024]; int bytes; bytes = in.read(buffer); String readStr = new String(buffer, 0, bytes); if (readStr.equals(\"connect..\")) &#123; Message msg1 = new Message(); msg1.what = 40; mainHandler.sendMessage(msg1); &#125; if (readStr.equals(\"destory..\")) &#123; isConnected = false; if (socket != null) &#123; socket.close(); &#125; readFlag = false; writeHandler.getLooper().quit(); &#125; Message message = new Message(); message.what = 100; message.obj = readStr; mainHandler.sendMessage(message); &#125; catch (Exception e) &#123; readFlag = false; isConnected = false; &#125; &#125; Message msg = new Message(); msg.what = 20; mainHandler.sendMessage(msg); &#125;&#125; WriteThreadWriteThread는 서버에 데이터를 보내기 위한 Thread이다.OutputStream을 사용해 write()함수를 사용 데이터를 송신한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class WriteThread extends Thread &#123; BluetoothSocket socket = null; OutputStream out = null; public WriteThread(BluetoothSocket socket) &#123; this.socket = socket; try &#123; out = socket.getOutputStream(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @SuppressLint(\"HandlerLeak\") @Override public void run() &#123; if (isConnectMessage) &#123; try &#123; out.write((\"connect..\").getBytes()); out.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; isConnectMessage = false; &#125; Looper.prepare(); writeHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; try &#123; if(isbyte)&#123; out.write((byte[])msg.obj); &#125;else &#123; out.write(((String) msg.obj).getBytes()); &#125; out.flush(); Message message = new Message(); message.what = 200; message.obj = msg.obj; mainHandler.sendMessage(message); &#125; catch (Exception e) &#123; e.printStackTrace(); isConnected = false; writeHandler.getLooper().quit(); try &#123; readFlag = false; &#125; catch (Exception e1) &#123; &#125; &#125; &#125; &#125;; Looper.loop(); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"App 구동시 시작화면을 나오게 하자","slug":"Android-App구동시-시작화면을-나오게-하자","date":"2019-08-30T08:00:00.000Z","updated":"2022-02-08T02:11:11.719Z","comments":true,"path":"2019/08/30/Android-App구동시-시작화면을-나오게-하자/","link":"","permalink":"http://jung-max.github.io/2019/08/30/Android-App구동시-시작화면을-나오게-하자/","excerpt":"","text":"MainActivity 이외의 Activity를 새로 만든다.(여기서는 가칭 IndexActivity) 12345678910111213141516171819202122public class IndexActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_index); //핸들러 객체 생성 //핸들러: 일정시간 뒤에 원하는 작업 수행하게 만들 수 있음 Handler handler = new Handler(); handler.postDelayed(new Runnable() &#123; //postDelayed 메서드를 사용하기 위해선 Runnable 객체를 인자로 자정해야함 @Override public void run() &#123; goMainActivity(); &#125; &#125;,1500); //여기서 1500의 단위는 ms(밀리 세컨드) &#125; public void goMainActivity() &#123; Intent intent = new Intent(this, MainActivity.class); startActivity(intent); finish(); &#125;&#125; IndexActivity에는 띄우고 싶은 초기화면을 레이아웃에 지정한다. AndroidManifest.xml에서 IndexActivity를 MAIN및 LAUNCHER로 지정해준다. 12345678&lt;activity android:name=\".IndexActivity\" android:theme=\"@style/Theme.AppCompat.NoActionBar\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"Bluetooth 디바이스 연결","slug":"Android-Bluetooth-디바이스-연결","date":"2019-08-30T08:00:00.000Z","updated":"2022-02-08T02:11:11.737Z","comments":true,"path":"2019/08/30/Android-Bluetooth-디바이스-연결/","link":"","permalink":"http://jung-max.github.io/2019/08/30/Android-Bluetooth-디바이스-연결/","excerpt":"","text":"Bluetooth 지원기기 체크bluetoothAdapter가 null 이면 기기가 블루투스를 지원하지 않는 것이다. 1234if (bluetoothAdapter == null) &#123; Toast.makeText(MainActivity.this, \"이 기기는 블루투스를 지원하지 않습니다.\", Toast.LENGTH_SHORT).show(); return false;&#125; 페어링 된 디바이스 목록 가져오기getBondedDevices()를 통해서 페어링된 기기 목록을 가져올 수 있다.목록의 이름을 deviceArray에 저장해서 UI에서 목록을 보여줄 때 사용한다. 12345678910final Set&lt;BluetoothDevice&gt; devices = bluetoothAdapter.getBondedDevices();if (devices.size() &gt; 0) &#123; final String[] deviceArray = new String[devices.size()]; Iterator&lt;BluetoothDevice&gt; iter = devices.iterator(); int i = 0; while (iter.hasNext()) &#123; BluetoothDevice d = iter.next(); deviceArray[i] = d.getName(); i++; &#125; AlertDialog에서 페어링된 디바이스 목록 보여주기.AlertDialog.Builder를 통해 AlertDialog를 생성한다. setTitle를 통해 Title을 설정한다. setItems에서 위에서 페어링된 디바이스 이름 목록을 설정하고 클릭시를 정의한다. 디바이스 목록을 클릭시 showProgressDialgo함수를 통해 ProgressDialgo를 보여준다. 123456789101112private void showProgressDialgo(String name) &#123; progressDialog = new ProgressDialog(this); progressDialog.setTitle(\"Waiting\"); progressDialog.setMessage(name + \"에 연결을 시도합니다.\"); progressDialog.setButton(\"취소\", new ProgressDialog.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; dialog.dismiss(); &#125; &#125;); progressDialog.show();&#125; 그 후 clientThread를 생성하고 bluetooth 연결을 시도한다. 123456789101112131415161718192021222324252627282930AlertDialog.Builder builder = new AlertDialog.Builder(this);builder.setTitle(\"device 선택\");builder.setItems(deviceArray, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; String selectDeivceStr = deviceArray[which]; for (BluetoothDevice device : devices) &#123; if (device.getName().equals(selectDeivceStr)) &#123; MainActivity.this.device = device; showProgressDialgo(device.getName()); if(socket != null)&#123; try &#123; if (writeThread != null) &#123; writeHandler.getLooper().quit(); &#125; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; ClientThread clientThread = new ClientThread(); clientThread.start(); &#125; &#125; &#125;&#125;);AlertDialog dialog = builder.create();dialog.show(); ClinetThreadcreateRfcommSocketToServiceRecord(MY_UUID)로 소켓을 취득 후 socket.connect()를 통해 블루투스 통신을 연결한다. 123456789101112131415161718192021222324252627282930class ClientThread extends Thread &#123; @Override public void run() &#123; try &#123; bluetoothAdapter.cancelDiscovery(); socket = device.createRfcommSocketToServiceRecord(MY_UUID); socket.connect(); if (readThread != null) &#123; readFlag = false; &#125; readThread = new ReadThread(socket); readThread.start(); if (writeThread != null) &#123; writeHandler.getLooper().quit(); &#125; writeThread = new WriteThread(socket); writeThread.start(); socketIsConnected = new SocketIsConnected(socket); socketIsConnected.start(); isConnected = true; //최초에 연결 되었다는 신호 보낸다. isConnectMessage = true; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; ActionBar의 버튼을 눌렀을때 동작 함수123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; if (item.getItemId() == R.id.menu_lab3_bluetooth) &#123; if (bluetoothAdapter == null) &#123; Toast.makeText(MainActivity.this, \"이 기기는 블루투스를 지원하지 않습니다.\", Toast.LENGTH_SHORT).show(); return false; &#125; final Set&lt;BluetoothDevice&gt; devices = bluetoothAdapter.getBondedDevices(); if (devices.size() &gt; 0) &#123; final String[] deviceArray = new String[devices.size()]; Iterator&lt;BluetoothDevice&gt; iter = devices.iterator(); int i = 0; while (iter.hasNext()) &#123; BluetoothDevice d = iter.next(); deviceArray[i] = d.getName(); i++; &#125; AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setTitle(\"device 선택\"); builder.setItems(deviceArray, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; String selectDeivceStr = deviceArray[which]; for (BluetoothDevice device : devices) &#123; if (device.getName().equals(selectDeivceStr)) &#123; MainActivity.this.device = device; showProgressDialgo(device.getName()); if(socket != null)&#123; try &#123; if (writeThread != null) &#123; writeHandler.getLooper().quit(); &#125; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; ClientThread clientThread = new ClientThread(); clientThread.start(); &#125; &#125; &#125; &#125;); AlertDialog dialog = builder.create(); dialog.show(); &#125; &#125; return super.onOptionsItemSelected(item);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"AlertDialog seekbar 사용 방법","slug":"Android-AlertDialog-seekbar-사용-방법","date":"2019-08-30T08:00:00.000Z","updated":"2022-02-08T02:11:11.715Z","comments":true,"path":"2019/08/30/Android-AlertDialog-seekbar-사용-방법/","link":"","permalink":"http://jung-max.github.io/2019/08/30/Android-AlertDialog-seekbar-사용-방법/","excerpt":"","text":"Fragment에서 AlertDialog+seekbar 사용seebar를 위한 코드는 MainActivity에 구현한다. 해당 함수의 파라미터로 Fragment의 값을 받는다. 파라미터로 받은 Fragment의 값에서 Context를 취득한다. 123public static void dlp_li_act(RemoconFragment a) &#123; //파라미터로 받은 Fragment에서 getContext()를 사용 Context를 취득한다. final AlertDialog.Builder alert = new AlertDialog.Builder(a.getContext()); 아래 소스와 같이 AlertDialog에 View를 설정하고 SeekBar의 setProgress()를 통해 초기값을 설정하고 setOnSeekBarChangeListener를 통해서 SeekBar의 값이 변할 때 정의를 내려준다. 12345678910111213141516171819202122232425262728293031323334public static void dlp_li_act(RemoconFragment a) &#123; final AlertDialog.Builder alert = new AlertDialog.Builder(a.getContext()); alert.setTitle(\"밝기 조정\"); final LayoutInflater inflater = (LayoutInflater) a.getContext().getSystemService(LAYOUT_INFLATER_SERVICE); final View Viewlayout = inflater.inflate(R.layout.light_dialog, (ViewGroup) a.getView().findViewById(R.id.layout_dialog)); alert.setView(Viewlayout); SeekBar seek1 = (SeekBar) Viewlayout.findViewById(R.id.seekBar1); seek1.setProgress(li); seek1.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() &#123; public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) &#123; Message msg = new Message(); msg.obj = \"Li:\" + progress; writeHandler.sendMessage(msg); li = progress; &#125; public void onStartTrackingTouch(SeekBar arg0) &#123; &#125; public void onStopTrackingTouch(SeekBar seekBar) &#123; &#125; &#125;); alert.setPositiveButton(\"확인\", new DialogInterface.OnClickListener() &#123; public void onClick(DialogInterface dialog, int which) &#123; &#125; &#125;); alert.show();&#125; Fragment에서 사용시Fragment에서 사용시 아래와 같이 파라미터를 넘겨 준다. 1MainActivity.dlp_li_act(RemoconFragment.this); 레이아웃 구성xml을 구성해 AlertDialog에서 seekbar의 레이아웃을 구현한다. 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/layout_dialog\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;LinearLayout android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"30px\" android:layout_marginRight=\"30px\" android:orientation=\"vertical\" &gt; &lt;SeekBar android:id=\"@+id/seekBar1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_alignParentLeft=\"true\" android:layout_below=\"@+id/txtItem1\" android:layout_marginTop=\"17dp\" android:max=\"8\" /&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; android:max에서 seekbar의 최대값을 지정한다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"ActionBar.TabListener Fragment에 대해서","slug":"Android-ActionBar.TabListener-Fragment에-대해서","date":"2019-08-30T08:00:00.000Z","updated":"2022-02-08T02:11:11.712Z","comments":true,"path":"2019/08/30/Android-ActionBar.TabListener-Fragment에-대해서/","link":"","permalink":"http://jung-max.github.io/2019/08/30/Android-ActionBar.TabListener-Fragment에-대해서/","excerpt":"","text":"개요ActionBar.TabListener는 ActionBar에 Tab의 기능을 추가하는 것이다.implements ActionBar.TabListener를 통해서 비교적 간단하게 구현 가능한 것이 특징이다. 위 예제를 보면 탭에 따라 화면이 달라지는 것을 볼 수 있다.Canon 프로젝터 리모콘 / 리모컨 / 마우스 부분 모두 ActionBar이다.달라지는 화면은 Fargment를 통해 구현할 수 있다. 사용방법가장 처음으로 클래스에 ActionBar.TabListener를 implements한다. 1public class MainActivity extends AppCompatActivity implements ActionBar.TabListener &#123; 그 후 메소드를 override를 한다.→ Android studio에서 ctrl+o를 하면 override method 메뉴가 뜬다. 거기서 ActionBar.TabListener 클래스를 찾아 onTabSelected를 override한다. tab 선택시 fragment 지정tab.getPosition()을 사용해서 ‘0’이면 첫번째탭, ‘1’이면 두번째 탭이 선택된 것이다.해당 탭을 선택 했을 때 Fragment에 대한 처리를 해주면 된다.생성된 Fragment가 없다면 Fragment생성한다.fragmentTransaction.replace를 통해서 해당 탭에 보여줄 Fragment를 파라미터로 지정해준다. 1234567891011121314151617181920212223242526272829303132333435//프레그먼트 사용하기MouseFragment mouseFragment = new MouseFragment();RemoconFragment remoconFragment = new RemoconFragment();@Overridepublic void onTabSelected(ActionBar.Tab tab, android.support.v4.app.FragmentTransaction fragmentTransaction) &#123; MouseFragment myMouserTab = null; RemoconFragment myRemoconTab = null; if (tab.getPosition() == 0) &#123; if (remoconFragment == null) &#123; myRemoconTab = new RemoconFragment(); Bundle data = new Bundle(); data.putString(\"tabName\", tab.getText().toString()); myRemoconTab.setArguments(data); remoconFragment = myRemoconTab; &#125; else &#123; myRemoconTab = remoconFragment; &#125; fragmentTransaction.replace(android.R.id.content, myRemoconTab); &#125; else if (tab.getPosition() == 1) &#123; if (mouseFragment == null) &#123; myMouserTab = new MouseFragment(); Bundle data = new Bundle(); data.putString(\"tabName\", tab.getText().toString()); myRemoconTab.setArguments(data); mouseFragment = myMouserTab; &#125; else &#123; myMouserTab = mouseFragment; &#125; fragmentTransaction.replace(android.R.id.content, myMouserTab); &#125;&#125; onCreate에서 ActionBar 생성getSupportActionBar()를 통해서 화면의 ActionBar를 얻어온다. 1ActionBar bar = getSupportActionBar(); ActionBar에 탭을 사용하기 위해 Mode를 설정한다. 1bar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS); 각각 탭을 newTab()으로 생성한다.그 후 Text, Icon등을 지정한다. newTab()으로 생성된 만큼 탭이 생성된다.탭의 배열 순서는 생성 순이다. 12345678910111213141516171819202122232425ActionBar.Tab tabRemocon, tabMouse;@Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //ActionBar ActionBar bar = getSupportActionBar(); bar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS); tabRemocon = bar.newTab(); tabRemocon.setText(\"리모컨\"); tabRemocon.setIcon(R.drawable.remocon); tabRemocon.setTabListener(MainActivity.this); bar.addTab(tabRemocon); tabMouse = bar.newTab(); tabMouse.setText(\"마우스\"); tabMouse.setIcon(R.drawable.mouse); tabMouse.setTabListener(MainActivity.this); bar.addTab(tabMouse); bar.setDisplayShowHomeEnabled(true); bar.setIcon(R.drawable.canon_logo); Fragmentjava폴더에서 우클릭을 통해 Fragment를 생성한다. onCreateView에 Activity의 내용을 구성한다.fragment_xxx.xml에 화면을 구성한다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"Mouse x,y축 이동을 패킷화 해서 bluetooth로 보내기","slug":"Android-Mouse-x,y축-이동을-패킷화해서-bluetooth로-보내기","date":"2019-08-30T08:00:00.000Z","updated":"2022-02-08T02:11:11.769Z","comments":true,"path":"2019/08/30/Android-Mouse-x,y축-이동을-패킷화해서-bluetooth로-보내기/","link":"","permalink":"http://jung-max.github.io/2019/08/30/Android-Mouse-x,y축-이동을-패킷화해서-bluetooth로-보내기/","excerpt":"","text":"Bluetooth 통신시 기본적으로 소켓에는 byte[]형식으로 데이터가 담긴다. mouse의 x,y 값을 보내기 위해서는 8byte가 필요하다(int *2) mouse의 이동값인 것을 나타내기 위한 1byte가 필요하다. int값을 byte화 하기 위해선 변환이 필요하다. 1234567891011public static byte[] intTobyte(int integer, ByteOrder order) &#123; ByteBuffer buff = ByteBuffer.allocate(Integer.SIZE/8); buff.order(order); // 인수로 넘어온 integer을 putInt로설정 buff.putInt(integer); System.out.println(\"intTobyte : \" + buff); return buff.array();&#125; order의 값은 ByteOrder.LITTLE_ENDIAN 또는 ByteOrder.BIG_ENDIAN을 지정한다. 최종적으로 mouse 이동에 따른 bluetooth 값을 보내는 코드는 아래와 같다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344//마우스 이동시 호출static public void Mouse_move(int x, int y) &#123; Message msg = new Message(); byte[] bytes = new byte[9]; byte[] xbytes; byte[] ybytes; bytes[0] = (byte)2; xbytes = intTobyte(x, ByteOrder.LITTLE_ENDIAN); ybytes = intTobyte(y, ByteOrder.LITTLE_ENDIAN); for(int i =0; i&lt;4; i++)&#123; bytes[1+i] = xbytes[i]; bytes[5+i] = ybytes[i]; &#125; msg.obj = bytes; isbyte = true; if (writeHandler != null) &#123; writeHandler.sendMessage(msg); &#125;&#125;//WriteThread에서 x,y값을 byte로 송신class WriteThread extends Thread &#123; BluetoothSocket socket = null; OutputStream out = null; public WriteThread(BluetoothSocket socket) &#123; this.socket = socket; try &#123; out = socket.getOutputStream(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; Looper.prepare(); writeHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; try &#123; if(isbyte)&#123; out.write((byte[])msg.obj); &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"bluetooth로 string 데이터 보내기","slug":"Android-bluetooth로-string데이터-보내기","date":"2019-08-30T08:00:00.000Z","updated":"2022-02-08T02:11:11.738Z","comments":true,"path":"2019/08/30/Android-bluetooth로-string데이터-보내기/","link":"","permalink":"http://jung-max.github.io/2019/08/30/Android-bluetooth로-string데이터-보내기/","excerpt":"","text":"Bluetooth에 string값을 보내기 위해서는 메세지에 스트링 값을 담아 보내고 받은 메세지의 string을 byte화 해서 송신을 하면 된다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//string값 메세지로 writeHandler에게 전달static public void Mouse_left() &#123; Message msg = new Message(); msg.obj = \"mouseLeft\"; isbyte = false; if (writeHandler != null) &#123; writeHandler.sendMessage(msg); &#125;&#125;class WriteThread extends Thread &#123; BluetoothSocket socket = null; OutputStream out = null; public WriteThread(BluetoothSocket socket) &#123; this.socket = socket; try &#123; out = socket.getOutputStream(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override public void run() &#123; Looper.prepare(); writeHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; try &#123; if(isbyte)&#123; out.write((byte[])msg.obj); &#125;else &#123; //string값을 byte화 해서 송신 out.write(((String) msg.obj).getBytes()); &#125; out.flush(); &#125; catch (Exception e) &#123; e.printStackTrace(); isConnected = false; writeHandler.getLooper().quit(); try &#123; readFlag = false; &#125; catch (Exception e1) &#123; &#125; &#125; &#125; &#125;; Looper.loop(); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"Github pages Hexo를 사용해서 만들기","slug":"Github-Pages-Hexo","date":"2019-08-29T02:17:13.000Z","updated":"2022-02-08T02:11:11.809Z","comments":true,"path":"2019/08/29/Github-Pages-Hexo/","link":"","permalink":"http://jung-max.github.io/2019/08/29/Github-Pages-Hexo/","excerpt":"","text":"Github Repository 생성하기 Github에 가입한다.https://github.com/ 아래와 같은 순서로 Repository 생성 New Repository, Repository 이름은 USERNAME.github.io USERNAME 은 Github의 가입시에 사용자의 username을 입력한다 Public / Private 중 Public 선택 Create Repository 버튼을 통해 Repository 생성 Hexo란? Hexo는 Jekyll와 함께 대표적으로 정적 페이지를 쉽게 만들 수 있도록 도와주는 서비스 두 서비스 역시 블로그 지향적인 서비스이며 Hexo의 경우에는 npm을 통해 쉽게 설치가 가능 한 줄의 Command Line을 통해 Github에 바로 배포 가능 Jekyll과 마찬가지로 다양한 플러그인과 테마를 지원 Hexo 설치Hexo를 이용하기 위해서는 먼저 아래의 구성 요소들이 사전에 설치가 되어 있어야 한다 Node.js Git Window10에서 Ubuntu 설치 검색 기능을 활용해서 Window 기능 켜기/끄기 메뉴에 들어간다. “Linux용 Windows 하위시스템” 버튼을 체크 Microsoft Store에 가서 ubuntu를 찾아 설치한다. cmd 창에서 bash 명령어로 linux 시스템에 접근 가능하다. Hexo CLI 설치123456$ sudo -s$ apt-get install npm$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install Hexo 설정_config.yml 파일 설정*hexo의 기본정보를 셋팅합니다.https://hexo.io/docs/configuration Site블로그의 이름과 간략한 소개등을 수정 할 수 있다. 12345678# Sitetitle: Max's Blogsubtitle: 개발시 정리사항 끄적끄적description: 개발시 정리했던 사항을 끄적이기 위한 블로그keywords: Android, java, 안드로이드, 자바author: Jung Maxlanguage: kotimezone: Asia/Seoul URL블로그 URL정보를 설정 할 수 있습니다. 123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://username.github.io/root: /permalink: :year/:month/:day/:title/permalink_defaults: Github 정보자신의 Git Page의 Repository 정보를 입력하면 이후에 손쉽게 배포가 가능 12345678## Plugins: https://hexo.io/plugins/Plugins:- hexo-deployer-git# Deploymentdeploy: type: git repo: https://username@github.com/username/username.github.io 로컬에서 테스트기본적인 설정이 완료가 되면 아래의 Command Line을 통해 로컬에서 서버를 구동 할 수 있다. 123# server 설치$ npm install hexo-server --save$ hexo server 서버가 구동이 되면 아래의 주소를 통해 브라우저에서 블로그에 접속 할 수 있다.http://localhost:4000 Git에 배포하기(Deploy)hexo-deployer-git은 _config.yml에 정의되어 있기 때문에, server를 구동하기 전에 먼저 설치되어야 한다. 1$ npm install hexo-deployer-git --save 아래 명령을 통해 간단하게 Github에 배포(Deploy)할 수 있다. 1$ hexo deploy --generate http://username.github.io 에 적용 완료. 새 개시물 추가하기hexo new post 기능을 쓰면 쉽게 추가가 가능하다. 1hexo new post post_name 위 명령어를 사용하면 source\\_posts폴더에 post_name.md 파일이 생성된다.해당 파일을 markdown 형식으로 post를 작성하면 된다.","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"GitHub Pages","slug":"기타/GitHub-Pages","permalink":"http://jung-max.github.io/categories/기타/GitHub-Pages/"}],"tags":[{"name":"Github Pages","slug":"Github-Pages","permalink":"http://jung-max.github.io/tags/Github-Pages/"},{"name":"Hexo","slug":"Hexo","permalink":"http://jung-max.github.io/tags/Hexo/"}]},{"title":"Github pages Hexo 테마 적용하기(hueman)","slug":"Github-Pages-Hexo-Theme","date":"2019-08-29T02:17:13.000Z","updated":"2022-02-08T02:11:11.790Z","comments":true,"path":"2019/08/29/Github-Pages-Hexo-Theme/","link":"","permalink":"http://jung-max.github.io/2019/08/29/Github-Pages-Hexo-Theme/","excerpt":"","text":"테마(Theme) 적용하기https://hexo.io/themes/ 에 접속해서 Hexo에서 사용할 수 있는 여러가지 Theme를 확인하고 선택할 수 있다.여기서는 hueman을 예로 든다. blog의 root 폴더에서 themes/hueman 폴더로 이동한다. 아래 명령을 통해 다운받는다. 1$ git clone https://github.com/ppoffice/hexo-theme-hueman.git themes/hueman _config.yml 파일에 theme 필드를 수정한다. 1theme: hueman theme폴더에 있는 _config.yml.example를 _config.yml로 이름을 수정한다. Serch 기능을 위해 아래 모듈을 설치한다. 1$ npm install -S hexo-generator-json-content 테마 설정themes/hueman 폴더에 있는 _config.yml에서 아래의 테마 설정을 바꿀 수 있다. Theme Menu Customize(Logo, Thema Color, Highlight, Sidebar, Thumbnail, Favicon, Social Links) Widgets : Recent Posts, Category, Archive, Tag, Tag Cloud, Links Search Comment : Disqus Share Plugins Miscellaneous menuAbout의 페이지는 현재 없는 페이지로 나온다.자신에게 맞는 프로필등의 사이트를 만든 후 링크를 걸어주면된다.참고로 Post로 hexo generate 명령어를 통해 html을 생성하고 그것을 링크해도 된다. customizelogo블로그의 로그를 링크한다. 이미지는 themes\\hueman\\source\\css\\images에 저장한다. 1234logo: width: 165 height: 60 url: images/logo-header.png theme_color오른쪽 사이드바의 Follow영역의 색을 바꾸게 해준다.아래 사이트를 이용하면 쉽게 원하는 색상을 찾을 수 있다.https://html-color-codes.info/ 링크 색 바꾸기themes/hueman/source/css/_partial 폴더의 article.styl 파일을 수정하면 된다. 12345.article-entry //... a //링크 color: \"원하는색상\" //... highlight코드 블락에서 문법에 따라 색을 바꿔 보여주는 것을 뜻함변경을 원하면 themes\\hueman\\source\\css\\_highlight 폴더에 있는 것중 하나를 골라 쓰면 된다. 1highlight: androidstudio sidebar사이드바의 위치를 조정 1sidebar: left # sidebar position, options: left, right thumbnail포스트의 썸네일을 표시를 끄고 켤 수 있습니다. 썸네일 ON 썸네일 OFF 1thumbnail: true # enable posts thumbnail, options: true, false 이 썸네일은 포스트 앞에 자동으로 삽입되는 front-matter 부분에 경로를 추가하면 된다.경로 지정이 없다면 포스트에 있는 가장 처음 그림을 사용한다. 그림이 없는 포스트라면 기본 화면이 출력된다. 123title: Hello Worlddate: 2013/7/13 20:46:25thumbnail: https://example.com/image.jpg favicon파비콘은 URL앞에 붙는 작은 아이콘을 뜻함png 파일을 추천 1favicon: favicon.png social_links내가 사용하는 여러가지 SNS 주소를 표시할 수 있다. 아이콘은 FontAwesome에서 골라서 이름을 적고 링크될 url을 적으면 된다. 12345social_links: # for more icons, please see http://fontawesome.io/icons/#brand #twitter: / #facebook: / #google-plus: / github: https://github.com/Jung-Max widgets사이드바에 추가되는 여러가지 위젯을 제공.사용하지 않는 것은 지우면된다. 12345678# Widgetswidgets: - recent_posts # 최근 포스트 - category # 카테고리 - archive # 어카이브 - tag # 태그 - tagcloud # 태그클라우드. 사용된 태그들을 빈도수에 따라 구름처럼 표시 - links # 링크 그 중에 링크는 _config.yml 하단에서 다음과 같이 추가 가능. 1234# Miscellaneousmiscellaneous: links: Hexo: http://hexo.io search블로그의 내의 검색 기능.기본적으로 제공하는 Insight Search를 사용.기본적으로 hexo-generator-json-content를 설치해야 한다.(위에서 설명함.) 1$ npm install -S hexo-generator-json-content","categories":[{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"GitHub Pages","slug":"기타/GitHub-Pages","permalink":"http://jung-max.github.io/categories/기타/GitHub-Pages/"}],"tags":[{"name":"Github Pages","slug":"Github-Pages","permalink":"http://jung-max.github.io/tags/Github-Pages/"},{"name":"Hexo","slug":"Hexo","permalink":"http://jung-max.github.io/tags/Hexo/"}]},{"title":"Android Kernel compile","slug":"Android-Kernel-compile","date":"2019-08-29T01:54:13.000Z","updated":"2022-02-08T02:11:11.750Z","comments":true,"path":"2019/08/29/Android-Kernel-compile/","link":"","permalink":"http://jung-max.github.io/2019/08/29/Android-Kernel-compile/","excerpt":"","text":"make 아래 설명될 이미지를 모두 만든다. make image compress되지 않은 Kernel 이미지 arch/arm/boot/image에서 찾을 수 있음 make zImage compress된 kernel 이미지 arch/arm/boot/zImage에 존재 make clean object 파일을 지우기 위한 명령어 make module module로 지정된 파일을 컴파일 make *_defconfig *_defconfig에 설정된 내용을 가져와서 적용한다. .config파일에 지정된다. *_defconfig가 .config로 복사되는 개념 make ARCH=arm64 arm64를 지정하고 컴파일을 한다. ARCH=arm64 뒤에 위에서 설명한 컴파일 옵션이 지정 가능하다 make -j4 -j 뒤에 숫자에 따라 쓰레드를 생성해 컴파일 속도를 높인다. 병렬 작업이기 때문에 예기치 못한 컴파일 에러가 발생 가능하다.(이럴땐 j 옵션 제거후 다시 컴파일)","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Kernel","slug":"Android/Platform-Kernel","permalink":"http://jung-max.github.io/categories/Android/Platform-Kernel/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"}]},{"title":"Android Kernel Moduel","slug":"Android-Kernel_Module","date":"2019-08-29T01:54:13.000Z","updated":"2022-02-08T02:11:11.754Z","comments":true,"path":"2019/08/29/Android-Kernel_Module/","link":"","permalink":"http://jung-max.github.io/2019/08/29/Android-Kernel_Module/","excerpt":"","text":"Kconfig Tree 구조로 된 configuration option들의 집합이며 모든 menu entry들은 자신만의 종속성을 가지고 있다. child entry는 parent entry가 보기 가능할 때만 보여진다. → 종속성 Menu entry들은 config option을 정의하고 있다. Menu attribute 모든 config option은 type을 가져야함 두가지 기본 타입이 존재 tristate : &lt;*&gt; &lt;M&gt;(모듈, 동적할당) &lt; &gt; bool : [*] [ ] 다른 타입은 위의 두 가지 타입에 기반함 사용자에 의해서 새로운 값이 설정되지 않으면 default value가 config option에 설정된다. 3가지 선택 선택, 모듈, 선택하지 않음 사용하지 않는 기능을 ‘Y’로 선택하면 이미지 크기가 너무 커짐 필요한 기능을 ‘N’으로 선택하면 kernel이 정상동작 하지 않음 새로운 module 추가 새로운 module을 추가하기 위해서는 Makefile, Kconfig를 수정해야 한다. Makefile 수정 Makefile에서는 Kconfig에 정의된 이름으로 obj-$(CONFIG_**) += 오브젝트파일.o 형식으로 추가한다. Kconfig 수정 Kconfig 파일에서는 config 모듈이름 형식으로 추가한다. 최소 조건은 bool 또는 tristate 인지 정의하는 것이다. 그외 설명, 종속성, dafault 값등을 설정한다.(옵션) 해당 파일에 추가되면 make menuconfig 메뉴에서 해당 메뉴가 보이게 된다. 모듈을 추가, 제거등 설장하고 싶으면 make menuconfig에 가서 설정한다. 동적 module 실행 중에 동적으로 코드를 삽입, 제거하는 module(*.ko)기능을 지원 기본 기능은 kernel image(zImage)에 담고 선택하는 것 드라비어는 별도의 module로 작성하여 필요할 때 마다 사용하는 것이 가능 모듈 사용 명령 insmod 모듈명.ko 시스템에 모듈을 추가 rmmod 모듈명 시스템에서 모듈을 제거 lsmod 현재 등록된 모듈을 확인Enable loadable module support make menuconfig에 아래와 같은 설정이 존재 Enable loadable module support 메뉴 안에을 들어가면 아래와 같은 메뉴 존재 Enable loadable module support Kernel의 module 기능을 쓸 수 있게 한다. Module unloading Kernel에 로딩된 module을 삭제할 수 있도록 한다. Forced module unloading Kernel이 module에 포함된 기능을 쓰고 있더라도 강제로 module을 지울 수 있도록 한다. module versioning support 다른 버전의 kernel에서 만들어진 module이나 kernel과 함께 배포되지 않은 특별한 module을 사용할 수 있게 한다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Kernel","slug":"Android/Platform-Kernel","permalink":"http://jung-max.github.io/categories/Android/Platform-Kernel/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"}]},{"title":"Android Kernel 빌드 옵션","slug":"Android-Kernel-빌드-옵션","date":"2019-08-29T01:54:13.000Z","updated":"2022-02-08T02:11:11.752Z","comments":true,"path":"2019/08/29/Android-Kernel-빌드-옵션/","link":"","permalink":"http://jung-max.github.io/2019/08/29/Android-Kernel-빌드-옵션/","excerpt":"","text":"make config 텍스트 기반 설정 방식 모든 옵션을 하나씩 보여주고 yes, no, module 중에 하나의 옵션을 선택 → 많이 불편함 make menuconfig 텍스트 메뉴 방식 ncurses에 기한반 GUI툴 화살표와 스페이스 바를 이용하여 옵션 설정 편리하고 가장 많이 사용 → 실제로 거의 이 모드를 사용한다. 설정 이후 저장하게 되면 .config파일 생성 cp .cofig arch/arm/config/test_defconfig make test_defconfg → 해당 옵션을 다시 적용하는게 가능 make *_defconfig Architecture 별로 기본 설정 옵션을 적용 arch//configs/_defconfig 파일 설정 완료 후 커널 소스 루트 디렉터리에 .config 파일 생성 make oldconfig kernel 옵션을 바로 이전 상태로 복구 kernel 옵션 설정 후에는 .config파일과 .config.old(백업)파일이 생성됨. 복구 시 .config.old파일 사용 가능 그외 Kernel 설정 QT기반 : make xconfig GTK기반 : make gconfig","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Kernel","slug":"Android/Platform-Kernel","permalink":"http://jung-max.github.io/categories/Android/Platform-Kernel/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"}]},{"title":"Android Platform 개발환경 구축","slug":"Android-Platform-개발환경","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.777Z","comments":true,"path":"2019/08/27/Android-Platform-개발환경/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-Platform-개발환경/","excerpt":"","text":"기본 Image 구성 Android 개발 툴SDK(Software Development Kit) Android Application을 만들기 위한 개발 환경 및 Tool을 제공 JAVA 기반의 Application 개발 시 사용 Windows, Linux, MAC등에 구성가능 Android studio에 연결 가능PDK(Platform Development Kit) BSP(Board Support Package: Android full source, Kernel, Bootloader)를 Build하는게 가능 Android System Porting 및 기능 추가 수정 보통 Ubuntu Linux에 직접 구성 NDK(Native Development Kit) Java 기반의 App 개발시 C/C++ 기반의 JNI(Java Native Interface) Method를 직접 호출할 때 사용 Application에서 특정 부분을 Nativer로 구축할 수 있는 방법이다. PDK에 비해 제약조건이 많다. fastbootfastboot란? Android Tool중 하나이며 Flash Memory(NAND, SDcard, eMMC, UFS등) 파티션을 flash하거나 삭제 가능. 사용하기 위해서는 Bootloader로 진입해야 함 사전에 Android fastboot Interface 장치 연결(USB Driver 설치 필요) Bootloader 진입(fastboot 사용 가능) Power 버튼과 Down 버튼을 동시에 계속 누름 adb reboot bootloader 커맨드로 진입 가능 Fastboot 사용을 위해 OEM unlock이 필요하다. Bootloader에 진입하여 Unlock 수행 1# fastboot oem unlock 반대는 fastboot oem lock으로 설정 가능 Android Source Build를 통해 Device를 위한 image를 준비 Bootloader에 진입 상태에서 fastboot tool 사용 가능 123456# source build/envsetup.sh# lunch &lt;product_name&gt;&lt;build_variant&gt;→ 풀소스 빌드# fastboot -w flashall→ 디바이스에 flash","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform 개발 환경","slug":"Android/Platform-개발-환경","permalink":"http://jung-max.github.io/categories/Android/Platform-개발-환경/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"개발환경","slug":"개발환경","permalink":"http://jung-max.github.io/tags/개발환경/"}]},{"title":"Android Kernel Message","slug":"Android-Kernel-Message","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.750Z","comments":true,"path":"2019/08/27/Android-Kernel-Message/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-Kernel-Message/","excerpt":"","text":"printk() 메시지 기록 관리를 위한 로그 레벨의 지정이 가능하다. kernel뿐만 아니라 응용프로그램의 init process도 printk()를 사용한다. logcat은 init가 구동하기 때문에 init는 printk()를 사용. 원형 큐 구조의 관리, 출력 디바이스의 다중 지정이 가능하다. 콘솔에서 확인하거나 dmesg 명령을 사용해서 로그파일 확인 가능 cat /proc/kmsg 끌때는 ps로 do_syslog를 찾아 그 번호로 kill 번호 실행 로그 레벨 지정 로그 레벨은 printk() 함수에 전달되는 문자열의 선두 문자에 &quot;&lt;1&gt;&quot;과 같이 숫자로 등급을 표현 linux/kernel.h에 정의된 선언문 사용을 권장 레벨에 대한 표시를 하지 않으면 KERN_WARNING과 같은 레벨 아래의 사용 예는 모두 같은 결과가 나온다. printk(KERN_WARNING “log test\\n”); printk(“&lt;4&gt;” “log test\\n”); printk(“&lt;4&gt;” log test\\n); printk(“log test\\n”); 상수 선언문 의미 KERN_EMERG “&lt;0&gt;” 시스템이 동작하지 않는다. KERN_ALERT “&lt;1&gt;” 항상 출력된다. KERN_CRIT “&lt;2&gt;” 치명적인 정보 KERN_ERR “&lt;3&gt;” 오류 정보 KERN_WARNING “&lt;4&gt;” 경고 정보, default 값 KERN_NOTICE “&lt;5&gt;” 정상적인 정보 KERN_INFO “&lt;6&gt;” 시스템 정보 KERN_DEBUG “&lt;7&gt;” 디버깅 정보","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Kernel","slug":"Android/Platform-Kernel","permalink":"http://jung-max.github.io/categories/Android/Platform-Kernel/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"}]},{"title":"Android 수정된 어플 탑재방법","slug":"Android-수정된어플탑재","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.788Z","comments":true,"path":"2019/08/27/Android-수정된어플탑재/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-수정된어플탑재/","excerpt":"","text":"1. 아래 검색 결과처럼 packages/apps/Setting/의 어플을 수정하면 설정 어플이 수정되어 탑재된다.12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364Searching 525515 files for &quot;ScreenshotSetting&quot; /home/ywjung/Projects/android/fireprime/out/target/common/obj/APPS/Settings_intermediates/proguard_options: 351 352 # view AndroidManifest.xml #generated:2214 353: -keep class com.android.settings.Settings$ScreenshotSettingsActivity &#123; &lt;init&gt;(...); &#125; 354 355 # view AndroidManifest.xml #generated:954 /home/ywjung/Projects/android/fireprime/packages/apps/Settings/AndroidManifest.xml: 2212 2213 &lt;!-- SCREENSHOT --&gt; 2214: &lt;activity android:name=&quot;Settings$ScreenshotSettingsActivity&quot; 2215 android:label=&quot;@string/screenshot_manager&quot; 2216 android:taskAffinity=&quot;&quot;&gt; .... 2222 &lt;/intent-filter&gt; 2223 &lt;meta-data android:name=&quot;com.android.settings.FRAGMENT_CLASS&quot; 2224: android:value=&quot;com.android.settings.ScreenshotSetting&quot; /&gt; 2225 &lt;meta-data android:name=&quot;com.android.settings.TOP_LEVEL_HEADER_ID&quot; 2226 android:resource=&quot;@id/screenshot_settings&quot; /&gt; /home/ywjung/Projects/android/fireprime/packages/apps/Settings/res/values/strings.xml: 6074 &lt;!--screenshot setting --&gt; 6075 &lt;string name=&quot;app_name&quot;&gt;ScreenshotManager&lt;/string&gt; 6076: &lt;string name=&quot;screenshot_manager&quot;&gt;ScreenshotSetting&lt;/string&gt; 6077 &lt;string name=&quot;screenshot_delay_title&quot;&gt;Select delay time to capture the screen &lt;/string&gt; 6078 &lt;string name=&quot;screenshot_show&quot;&gt;Show the screenshot button in the statusbar&lt;/string&gt; /home/ywjung/Projects/android/fireprime/packages/apps/Settings/res/xml/dashboard_categories.xml: 179 android:id=&quot;@+id/screenshot_settings&quot; 180 android:title=&quot;@string/screenshot_manager&quot; 181: android:fragment=&quot;com.android.settings.ScreenshotSetting&quot; 182 android:icon=&quot;@drawable/capture&quot; /&gt; 183 &lt;/dashboard-category&gt; /home/ywjung/Projects/android/fireprime/packages/apps/Settings/src/com/android/settings/ScreenshotSetting.java: 30 import android.os.SystemProperties; 31 import android.content.res.Resources; 32: public class ScreenshotSetting extends SettingsPreferenceFragment implements OnPreferenceChangeListener&#123; 33 /** Called when the activity is first created. */ 34 private static final String KEY_SCREENSHOT_DELAY=&quot;screenshot_delay&quot;; /home/ywjung/Projects/android/fireprime/packages/apps/Settings/src/com/android/settings/Settings.java: 103 public static class ApnSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; 104 public static class HdmiSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; 105: public static class ScreenshotSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; 106 public static class UsbConnectSettingsActivity extends SettingsActivity &#123; /* empty */ &#125; 107 &#125; /home/ywjung/Projects/android/fireprime/packages/apps/Settings/src/com/android/settings/SettingsActivity.java: 114 import com.android.settings.wifi.p2p.WifiP2pSettings; 115 import com.android.settings.HdmiSettings; 116: import com.android.settings.ScreenshotSetting; 117 import com.android.settings.UsbSetting; 118 ... 312 ApnSettings.class.getName(), 313 HdmiSettings.class.getName(), 314: ScreenshotSetting.class.getName(), 315 UsbSetting.class.getName() 316 &#125;; 25 matches across 13 files 2. vendor/rockchip/common/apps 에 추가해준다.내가 포함하고자하는 어플을 폴더로 추가하고 MakeFile을 형식에 맞춘다.그 다음 apps.mk를 수정하여 패키지 목록에 추가함으로써, 원하는 어플을 펌웨어에 추가할 수 있다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform boot","slug":"Android/Platform-boot","permalink":"http://jung-max.github.io/categories/Android/Platform-boot/"}],"tags":[{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"}]},{"title":"Android Kernel System Memory Model","slug":"Android-Kernel-System-Memory-Model","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.750Z","comments":true,"path":"2019/08/27/Android-Kernel-System-Memory-Model/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-Kernel-System-Memory-Model/","excerpt":"","text":"Android System Memory Model Linux/Android에서는 가상 메모리를 각 Process 마다 4GB씩 할당 받는다.(32bit 기준) Process의 각 유저 영역은 물리 메모리에 독립적으로 지정된다. Kernel 영역은 물리 메모리에서 공유된다. 공유 가능 영역 공유 가능 영역은 Kernel 공간이기 때문에 Android에서는 Binder, Ashmem등을 사용한다. 프로세스간 통신(IPC)는 메모리에서 Kernel만이 공유 가능하기 때문에 Kernel을 경유하여 통신을 한다.(Binder driver등) IPC(Inter-Process Communication) 사용 예 Binder 사용 예 : Binder란 IPC 기법 중 하나이며 RPC(Remote Procedure Call)를 지원","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Kernel","slug":"Android/Platform-Kernel","permalink":"http://jung-max.github.io/categories/Android/Platform-Kernel/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"}]},{"title":"Android에서 GPIO제어(ROCK64 보드)","slug":"Android-GIPO-제어-ROCK64","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.760Z","comments":true,"path":"2019/08/27/Android-GIPO-제어-ROCK64/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-GIPO-제어-ROCK64/","excerpt":"","text":"GPIO indexROCK64의 핀은 아래와 같이 구성되어있습니다.GPIO의 이름은 bank, pad, number로 이루어져 있습니다. GPIO(bank)_(pad)(number) 예를 들어 Pi-2 Bus의 16번 핀의 이름은 GPIO3_A5입니다. 이 핀의 bank는 ‘3’ / pad는 ‘A’ / number는 ‘5’입니다. 여기서 index를 구하는 공식은 아래와 같습니다. 123456789index = bank * 32 + pad * 8 + numberGPIO3_A5 ^ ^^ | |\\_number | \\__pad: A=0, B=1, C=2, D=3 \\____bank3*32+0*8+5 = 96+0+5 = 101 이기때문에 이 gpio의 index는 gpio-101입니다. Rock64의 핀의 index 정보는 아래와 같습니다. adb로 GPIO 컨트롤ROCK64에서 GPIO 컨트롤은 파일을 write해서 제어할 수 있습니다.기본적으로 adb에서 컨르롤 하기 위해서는 root권한이 필요합니다.adb root위 명령어로 root의 권한을 획득합니다.그 후 shell로 접근하면 root의 권한을 획득한 것을 볼 수 있습니다. serial로 접근시 root 권한은 su로 획득할 수 있습니다. 처음엔 gpio export가 필요합니다. 여기서 GPIO3_A5(index 101)를 export시킬려면 다음과 같습니다. 1roc_rk3328_cc_box:/ # echo 101 &gt; /sys/class/gpio/export export를 하면 /sys/class/gpio/gpio101폴더가 생성됩니다. 그 후 in/out을 설정합니다. 1roc_rk3328_cc_box:/ # echo out &gt; /sys/class/gpio/gpio101/direction 그 후 value의 값을 조정하여 gpio를 제어한다. 12roc_rk3328_cc_box:/ # echo 1 &gt; /sys/class/gpio/gpio101/valueroc_rk3328_cc_box:/ # echo 0 &gt; /sys/class/gpio/gpio101/value adroid App을 통한 제어 app에서 shell 명령어 실행을 실행하려면 아래와 같이 동작한다. 1Runtime.getRuntime().exec(\"명령문\"); 파일 쓰기 권한을 얻기 위해선 아래와 같이 한다. 123456789101112131415161718192021Process process = null;DataOutputStream dataOutputStream = null;try &#123; process = Runtime.getRuntime().exec(\"su\"); dataOutputStream = new DataOutputStream(process.getOutputStream()); dataOutputStream.writeBytes(\"chmod 777 /sys/class/gpio/export\\n\"); dataOutputStream.writeBytes(\"exit\\n\"); dataOutputStream.flush(); process.waitFor();&#125; catch (Exception e) &#123;&#125; finally &#123; try &#123; if (dataOutputStream != null) &#123; dataOutputStream.close(); &#125; process.destroy(); &#125; catch (Exception e) &#123; &#125;&#125; 앞서 말한것과 같이 gpio를 제어하기 위해서는 value값을 수정해야 한다.App에서 수정은 NDK를 이용해 수정을 한다. 1234567891011121314151617181920JNIEXPORT void JNICALL Java_ckbs_ywjung_gpiotest_MainActivity_gpiorelay (JNIEnv *env, jobject thiz,jint out)&#123; int fd, len; char buf[60]; len = snprintf(buf, sizeof(buf), \"/sys/class/gpio/gpio101/value\"); fd = open(buf, O_WRONLY); if (fd &lt; 0) &#123; return ; &#125; if (out)&#123; write(fd, \"1\", 1); &#125; else &#123; write(fd, \"0\", 1); &#125; close(fd); LOGD(\"GPIO_1 %d \",out);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"GPIO","slug":"GPIO","permalink":"http://jung-max.github.io/tags/GPIO/"}]},{"title":"Android Kernel 주요 디렉토리","slug":"Android-Kernel-주요-디렉토리","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.753Z","comments":true,"path":"2019/08/27/Android-Kernel-주요-디렉토리/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-Kernel-주요-디렉토리/","excerpt":"","text":"Kernel 주요 디렉토리Top Kernel의 Top디렉토리는 kernel을 빌드하기 위한 Makefile을 가지고 있으며 모든 빌드 동작은 이 디렉토리에서 시작된다. arch Architecture 즉 프로세서(CPU), Soc(AP) 및 타깃 보드 관련된 소스가 구현된 디렉토리이다. 각 CPU별 디렉토리를 가지고 있으며, ARM프로세스 관련 소스는 arm 디렉토리에 구현 arm 디렉토리는 kernel의 로우 레벨 처리를 위한 kernel 데릭토리, 로우 레벨 메모리 관리를 위한 mm 디렉토리, 그리고 어셈블리어로 kernel 라이브러리를 구현한 lib 디렉토리가 있다. 칩셋, 타겟 보드 소스를 구현한 platform 및 머신 디렉토리를 포함한다. Kernel 초기화는 압축 해제 이후 kernel 디렉토리의 head.S 어셈블리 소스에서 시작된다. crypto 암호화 API Documentation 리눅스 커널 및 디바이스 드라이버에 대한 많은 자료를 가지고 있다. drivers 리눅스의 디바이스 드라이버를 구현 각 드라이버는 별도의 디렉토리와 소스로 구성되어 있다. fs VFS와 그밖의 파일 시스템 fat, ext2, ext3, ext4 등 다양한 파일시스템을 구현한 디렉토리로 구성 include 리눅스 커널에서 사용되는 일반적인 헤더를 정의한 디렉토리 타깃 CPU 및 보드에 대한 헤더 파일은 arch 디렉토리의 include 디렉토리에 구현 init kernel의 초기화 절차를 관리하는 main.c 파일을 가지는 디렉토리 main.c 파일의 start_kernel() 함수에서 kernel의 초기화 절차를 일괄적으로 관리 디바이스 드라이버 초기화 이후 루트 파일 시스템을 mount하고 init 프로세스(응용 프로그램 시작)를 실행 start_kernel() 함수는 arch/arm/kernel 디벡토리의 어셈블 소스 head.S 및 head-commons.S에서 kernel 초기화를 위한 시스템 설정 후 호출 ipc 시스템 V IPC 세마포어, 메시지 큐, 공유메모리 기능을 구현한 디렉토리 Android의 driver/binder 및 ashem 폴더에 구현 kernel 스케쥴러, 프로세스 등 kernel의 주요기능 구현 예외처리 및 인터럽트 처리, 주기적인 타이머 인터럽트를 처리하기 위한 소스 등이 구현 이 디렉토리에 구현된 소스는 모두 프로세서와 무관하게 kernel에서 동작하는 소스 프로세스 관련 로우레벨 소스는 arch/arm/kernel 디렉토리에 구현 lib kernel에서 사용되는 라이브러리를 구현한 디렉토리 이 디렉토리에 구현된 라이브러리는 c언어로 구현 라이브러리 중에서 고속 처리를 위한 어셈블 언어로 구현된 라이브러리는 arch/arm/lib 디렉토리에 있음 mm 가상 주소 관리, 페이지 관리, 프로세스의 모미르 관리 등의 소스가 구현 이 디렉토리는 프로세스와 무관한 메모리 관리 루틴이 구현 프로세스의 메모리 시스템과 MMU나 캐시등 로우레벨 제어 동작은 arch/arm/mm 디렉토리에 구현 block 블록 디바이스의 관리를 위한 소스가 구현 블록 디바이스 드라이버는 drivers/block 디렉토리에 구현 net 네트워크 시스템을 구현하고 있는 디렉토리 소켓 관리에서 부터 시작하여 TCP/IP등 다양한 네트워크 프로토콜을 구현 script kernel 빌드에 사용되는 다양한 스크립트를 가지는 디렉토리이다. 주로 Host에서 Kernel 빌드에 사용되며 Kernel 소스는 아니다. security Kernel에서 필요한 보안기능을 구현 응용 프로그램의 보안정책(Sercurity Policy)을 관리 보안정책 수정은 /system/sepolicy, 벤더측은 /device/제조사/sepolicy ps -z, ls -z로 옵션을 볼 수 있음 sound 사운드 드라이버를 구현하고 있는 디렉토리 사운드 드라이버는 ALSA드라이버를 기반으로 한다. 칩의 사운드 인터페이스 및 코덱 드라이버가 구현","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Kernel","slug":"Android/Platform-Kernel","permalink":"http://jung-max.github.io/categories/Android/Platform-Kernel/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"}]},{"title":"Android Platform Architecture","slug":"Android-Platform-Architecture","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.770Z","comments":true,"path":"2019/08/27/Android-Platform-Architecture/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-Platform-Architecture/","excerpt":"","text":"개요 Open Source기반 Embedded System 대표적인 Open Source기반 Emebedded System인 Embedded Linux와 Android 비교시 Kernel은 동일하고 응용프로그램 영역이 다름 OpenSource 기반이기 때문에 Framework source가 공개되어 있어 수정/추가가 가능하나 제조사에서 제공되는 S/W(Binary/Library등)의 경우 대부분 Source가 공개되지 않음 Apache v2 License 사용으로 소스코드 수정시 공개의무가 없다(Kernel과는 License가 구분됨) Application은 각자가 프로세스임. 서로 통신은 IPC(Binder)를 통함. Application Framework는 전체가 단일 프로세스임. 각자는 쓰레드 개념으로 동작. Application과는 IPC를 통해 통신함. Application과 Application Framework는 JAVA. Application Framework와 Libraries는 JNI을 통해 연결. Libraries와 HAL모듈은 표준화된 방법을 통해 연결됨. HAL 모듈과 Kernel은 System Call을 통해서 통신. Android에서 Service Android의 Client(Application)의 요청을 처리하고 특정 기능을 제공하는 모듈을 의미. Binder을 통해 요청된다. Android Framework에서 구현된 많은 기능들이 Service 형태로 존재한다. Process위에 여러개의 Service가 동작 가능하다. Application Service Service class를 확장하여 구현가능. 라이프 사이클에 영향을 받는다. (Kill될 수도 있다.) 추가하기가 상대적으로 쉽다. System Service : 관리를 받지 않는다. 하지만 단 JAVA System Service : 관리를 받지 않는다. 하지만 단일 프로세스를 수정해야 한다. Native System Service Applications 휴대 단말이 가져야 할 기본 기능을 수행하는 Application을 제공한다. Android Framework와 연동하며 여러가지 기능을 제공한다. SDK를 제공받아 Application을 개발하며 재사용, 확장, 교체등이 용이하다. Android Components로는 다음과 같은 요소들을 제공한다. Activity : forground(눈에 보이는 요소) Service : background Intent, Broadcast Receivers, Widget등 프로세스 생성 APP의 생성 A App에서 Binder를 통해 Activity manager에게 요청(Binder) Activity manager는 zygote(버추얼머신을 가지고 있는 모듈)에게 요청(socket) zygote는 fork를 통해 복제해 B APP을 생성 Application Framework(System server) Application을 보조 및 지원하는 구조로 하드웨어, 리소스 서비스등을 지원하며 매니저 및 시스템 서비스들로 구성 Activity Manager : Android Application 실행 요청 및 Life Cycle을 관리 Window Manager : 윈도우의 모양이나 크기 등을 관리 Content Manager : Application이 서로 정보나 메시지를 공유, 작업 등을 요청하는 기능을 담당 View System : 리스트, 텍스트 박스, 버튼 및 다이얼로그 등의 UI set 제공 Notification Manager : 콜 수신, 메시지수신, 배터리부족, 시스템 상태변화, 네트워크 시그널 등 이벤트 발생에 따라 상태 바 같은 알림을 디스플레이 Telephone Manager : 음성 및 영상통화, MMS/SMS, SIM/USIM 관리 Resource Manager : 애플리케이션에게 파일, 그래픽 등의 자원 할당/해제 Location Manager : 위치 정보 제공 기능 Libraries Android Runtime 환경을 통해 Application이 사용할 기능 제공 JNI을 통해 연결된다. HAL을 통해 Android Runtime환경에서 Device Driver와 연결 되기도 함. Nativer System Service는 C/C++로 작성이 되어 있다. 그래픽 지원(2D, 3D, SGL, OpenGL ES) OMX등 지원 Data base(SQLite) Web browser을 위한 WebKit지원 보안 네트워킹을 위한 SSL지원 OpenCore 기반의 Media Framwork, 오디오 및 비디오와 이미지 코덱을 지원 System.loadLibrary()가 실행되면 ART는 해당 이름의 공유 라이브러리를 로딩한 후 함수 심볼을 검색 로딩한 라이브러리에서 심볼을 검색한 후 JNI_OnLoad()함수가 구현되어있는지 확인하고 해당 함수가 포함되어 있으면 자동으로 호출함 RegisterNative() 함수를 사용하면 ART에서 자동으로 라이브러리 내에 JNI Native 함수 심볼을 비교하여 연결해주는 작업 대신에 프로그래머가 직접 연결 작업을 처리하기 때문에 로딩속도를 향상시킬 수 있다. JNI_OnLoad()함수가 구현시 연결 방법① Application or Application Framwork 12Syatme.loadLibrary(\"android_servers\")nativeInit(); ② libandroid_servers.so → JNI_OnLoad() 실행 → RegisterNatives() 매핑 수행 1234static JNINativeMethod gMethods[] = &#123;/* name(자바함수), signature(리턴타입), funcPtr(c/c++함수) */&#123; \"nativeInit\", \"()V\", (void*)android_server_SystemServer_nativeInit&#125;,&#125;; JNI_OnLoad()함수가 없다면 ART는 자동으로 라이브러리 내에 JNI Native 함수 심볼을 비교하여 매핑 작업을 수행한다. 성능 저하의 원인이 될 수 있다. JNI_OnLoad()함수가 없을때 연결 방법 JNIEXPORT &lt;리턴타임&gt; JNICALL java_&lt;패키지명&gt;_&lt;클래스명&gt;_&lt;네이티브함수명&gt; HAL(Hardware Abstraction Layer) Android가 Kernel에 접근하기 위한 인터페이스 제공 커널 디바이스 드라이버와 시스템 콜을 통해 연결된다. 커널 버전이나 CPU가 바뀌어도 이식성에 문제를 최소한으로 줄이기 위한 계층이다. 대부분 Chip vendor에서 Library(HAL module)형태로 제공 Android HAL은 동적 라이브러리를 로딩하는 표준화된 방법을 제공한다. hw_get_module(), hw_get_module_by_class를 통해 동적 라이브러리를 로딩하는 표준화된 방법을 제공 123/* id : 동적 로딩이 필요한 모듈의 ID. ID값에 따라 로딩해야 할 동적 라이브러리를 결정 module : 동적 로딩된 라이브러리의 HMI(Hardware Module Information)심볼의 hw_module_t 포인터를 반환 */int hw_get_module(const char *id, const struct hw_module_t **module) 반환된 hw_module_t의 멤버 변수 중 methods를 이용하여 로딩된 HAL module을 사용 가능한 상태로 초기화 시킬 수 있다. HAL module의 기본위치는 다음과 같음 1234/* 우선운위는 3→2→1 순 */#define HAL_LIBRARY_PATH1 \"/system/lib/hw\"#define HAL_LIBRARY_PATH2 \"/vendor/lib/hw\"#define HAL_LIBRARY_PATH3 \"/odm/lib/hw\" Android Kernel Android에 맞게 추가, 수정된 리눅스 커널 프로세스 관리(Binder, Low Memory Killer) 메모리 관리(Ashmem) 디바이스 드라이버 관리(Power Management) 파일 시스템(FS)등","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Architecture","slug":"Android/Platform-Architecture","permalink":"http://jung-max.github.io/categories/Android/Platform-Architecture/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"Architecture","slug":"Architecture","permalink":"http://jung-max.github.io/tags/Architecture/"}]},{"title":"Android NDK 개발환경 구축","slug":"Android-NDK","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.768Z","comments":true,"path":"2019/08/27/Android-NDK/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-NDK/","excerpt":"","text":"Android NDK 개발 환경 구축Android 앱에서 C나 C++코드를 사용하기 위하여 Android NDK를 써야 한다.아래는 Android NDK의 개발 환경 구성 방법을 설명한다. 크게 아래의 세가지를 설치할 것이며, Linux 64bit에서 진행했다. IDE 다운로드 : Android StudioSDK 다운로드 : Android Studio에 포함NDK 설치 : SDK Tools [IDE 설치] 알맞은 Java를 설치한다. Oracle JDK 8이 현재 제일 좋은 버전임 1234$ sudo apt-get install python-software-properties$ sudo add-apt-repository ppa:webupd8team/java$ sudo apt-get update$ sudo apt-get install oracle-java8-installer Ubuntu 64bit에 32bit 라이브러리가 누락되어 있으므로 추가 설치해준다. 1$ sudo apt-get install lib32z1 lib32ncurses5 lib32stdc++6 아래 경로에서 Android Studio를 다운로드하고 설치한다. (현재 최신은 2.3.3임)https://developer.android.com/studio/index.html?hl=ko (/images/Android-NDK/01.png) 다운로드한 후에 적당한 경로에 압축을 풀어둔다. (아래 예제에선 ~/Android/ 에 해제함) 1$ unzip ./android-studio-ide-*.zip -d /opt/ 아래 명령어로 실행한다. 1$ sh /opt/android-studio/bin/studio.sh 최초 실행 완료 뒤 창에서, 오른쪽 하단의 Configure-&gt;Create Desktop Entry를 선택하면 바로가기가 생성된다. [NDK 설치] Android Studio를 실행하고, 아래 창과 같이 SDK Manager를 실행한다. Android SDK에서 “CMake”와 “NDK”를 설치한다 JNI 샘플 프로젝트를 다운로드하고, 연다. 프로젝트가 열리면, 플러그인 업데이트와 설치를 진행한다.Gradle 에러로 필요한 것을 설치하라고 표시될 것인데, 클릭 하여 쉽게 설치할 수 있을 것이다. *) CAP에서 실행하기 위해서는, build.gradle에서 minSdkVersion 을 22로 변경한 후에, 프로젝트를 Sync한다. NDK를 이용하여 JNI 샘플 앱이 빌드되는 것을 확인할 수 있다.[신규 NDK 프로젝트 생성] 아래와 같이 새 프로젝트를 생성한다. 앱 이름 등을 알맞게 입력하고, “Include C++ support”를 체크 한다. 원하는 대로 설정한다. “Add No Activity”를 선택한다.(참고로 Activity를 선택해서 프로젝트를 만들면, 샘플 코드까지 자동으로 생성 해준다) 생성되어 있는 native-lib.cpp 파일에 아래와 같이 입력한다. 123456789101112#include &lt;jni.h&gt;#include &lt;string&gt; extern \"C\"JNIEXPORT jstring JNICALLJava_com_example_MainActivity_stringFromJNI( JNIEnv *env, jobject /* this */) &#123; std::string hello = \"Hello from C++\"; return env-&gt;NewStringUTF(hello.c_str());&#125; JNIEXPORT 매크로로 jni에 visibility를 지정하고, jstring으로 리턴하는 것을 써주며, 함수의 이름은, 순서대로 “Java_” 접두사를 붙이고 패키지명을 붙이고, 클래스의 이름을 포함해야 한다.따라서 아래를 풀이하자면 다음과 같다.-&gt; 접두사 Java_ + 패키지명 com.example.wjshin.myndktest + 클래스명 MainActivity + 함수명 stringFromJNI 12JNIEXPORT jstring JNICALLJava_com_example_MainActivity_stringFromJNI 왼쪽의 패키지 명에 오른쪽 클릭해서 File-&gt;New-&gt;Activity-&gt;Empty Activity를 선택하면 Activity 생성 창이 나오는데, “Launcher Activity”를 체크해서 생성한다.(위 사진에서는 com.example.wjshin.myndktest) 생성된 Activity의 Java 코드에 아래와 같이 입력해준다. 12345678910111213141516171819202122package com.example; import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.util.Log; public class MainActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Log.d(\"MyNDKTest\", stringFromJNI()); &#125; static &#123; System.loadLibrary(\"native-lib\"); &#125; private native String stringFromJNI();&#125; 아래 코드로 native-lib라는 이름의 라이브러리를 로드하고 123static &#123; System.loadLibrary(\"native-lib\");&#125; 아래 코드로 stringFromJNI를 native 함수로 선언한다. 1private native String stringFromJNI(); Run ‘app’ 으로 앱을 실행하면, 안드로이드 로그가 정상적으로 출력되는 것을 확인할 수 있다. [기존 프로젝트에 NDK 추가] 일반적인 안드로이드 앱 프로젝트를 생성한다. 일반 프로젝트의 왼쪽의 Project 탭에서, 드롭박스 중 Project를 선택한다. app/main 폴더에 오른쪽 클릭 후 New-&gt;Directory 를 선택하여 cpp 폴더를 만든다.(폴더 명은 중요하지 않음) 생성한 폴더에 오른쪽 클릭한 후, New-&gt;C/C++ Source File 을 선택하여 cpp 파일을 만든다.(파일 명은 중요하지 않음) 생성된 cpp파일에 테스트용 코드를 입력 app 폴더에 오른쪽 클릭한 후, New-&gt;File 을 선택하여 CMakeLists.txt 파일을 생성(app 폴더 외 다른 폴더도 가능) 아래와 같이 “native-lib”라는 이름의 라이브러리를 상대 경로의 파일 src/main/cpp/native-lib.cpp로 추가 프로젝트 좌측의 Project 탭에서 Android를 다시 선택한다.CPP 라이브러리와 연결하고자 하는 클래스를 오른쪽 클릭한 후, “Link C++ Project with Gradle”를 선택하여, CMakeLists.txt 파일을 선택하면 앱 모듈과 라이브러리가 연결된다. 연결 전)연결 후) Java Activity에 아래와 같이 코드를 추가하여 잘 동작하는 것을 확인한다. ![image](/images/Android-NDK/42.png) 참고https://developer.android.com/ndk/index.html https://developer.android.com/studio/projects/add-native-code.html https://code.tutsplus.com/ko/tutorials/how-to-get-started-with-androids-native-development-kit–cms-27605 Android에 Native Library를 내장https://source.android.com/devices/tech/config/namespaces_libraries.html","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"개발환경","slug":"Android/개발환경","permalink":"http://jung-max.github.io/categories/Android/개발환경/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"개발환경","slug":"개발환경","permalink":"http://jung-max.github.io/tags/개발환경/"},{"name":"NDK","slug":"NDK","permalink":"http://jung-max.github.io/tags/NDK/"}]},{"title":"Android Platform 부분 빌드 방법","slug":"Android-Platform-부분빌드방법","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.771Z","comments":true,"path":"2019/08/27/Android-Platform-부분빌드방법/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-Platform-부분빌드방법/","excerpt":"","text":"안드로이드 빌드의 시작은 source build/envsetup.sh의 명령어로 안드로이드 환경을 구성하는 것이다.현재 rk3328의 환경설정을 보면FFTools\\build.sh에 다음과 같이 되어있다. 12345export JAVA_HOME=/usr/lib/jvm/java-8-openjdk-amd64export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jarsource build/envsetup.sh 다음은 lunch명령어를 통해 타겟별 환경을 구성하는 것이다. 현재 FFTools\\make.sh를 살펴보면 다음과 같이 구성하고 있다. lunch roc_rk3328_cc_box-userdebug 여기서 roc_rk3328_cc_box는 디바이스 타겟 명칭을 가리킨다. -&gt;device\\rockchip\\rk3328\\roc_rk3328_cc_box -userdebug는 컴파일 수준을 나타낸다.Android.mk의 makefile을 보면 다음과 같은 항목이 있다. LOCAL_MODULE_TAGS := xxx xxx가 컴파일 수준을 나타낸다. user &lt; userdebug &lt; eng 오른쪽으로 갈수록 수준이 높아지며 eng는 user / userdebug 모두를 포함한다.userdebug는 user를 포함하며 user는 오직 user가 명칭되어 있을때만 컴파일 된다. optional은 deviceconfig에 해달 모듈이 명명되어 있을때 컴파일 된다. 부분 빌드시에는 LOCAL_MODULE_TAGS 수준에 상관없이 무조건 컴파일 된다. source build/envsetup.sh를 실행하면 안드로이드 환경의 명령어를 사용할 수 있다.hmm을 사용하면 아래와 같이 뜬다. lunch: lunch - tapas: tapas [ …] [arm|x86|mips|armv5|arm64|x86_64|mips64] [eng|userdebug|user] croot: Changes directory to the top of the tree. m: Makes from the top of the tree. mm: Builds all of the modules in the current directory, but not their dependencies. mmm: Builds all of the modules in the supplied directories, but not their dependencies.To limit the modules being built use the syntax: mmm dir/:target1,target2. mma: Builds all of the modules in the current directory, and their dependencies. mmma: Builds all of the modules in the supplied directories, and their dependencies. provision: Flash device with all required partitions. Options will be passed on to fastboot. cgrep: Greps on all local C/C++ files. ggrep: Greps on all local Gradle files. jgrep: Greps on all local Java files. resgrep: Greps on all local res/*.xml files. mangrep: Greps on all local AndroidManifest.xml files. mgrep: Greps on all local Makefiles files. sepgrep: Greps on all local sepolicy files. sgrep: Greps on all local source files. godir: Go to the directory containing a file. 여기서 눈여겨 볼 명령어는 m : 전체 빌드 mm : 현재 디렉토리 부분빌드 mma : 현재디렉토리 부분빌드. 연관성 있는것 까지 다 빌드함. croot: 안드로이드 최상위 디렉토리로 감 mm 명령어를 사용해서 부분 빌드가 가능하다. 빌드를 끝나면 어떤 파일이 어디에 생성했는지 표시해 준다. 예&gt; 1Install: out/target/product/roc_rk3328_cc_box/data/app/TouchLatencyJankTestWear/TouchLatencyJankTestWear.apk out/target/product/roc_rk3328_cc_box/까지는 공통이다.그후의 폴더는 안드로이드 시스템의 폴더와 연동된다. 예를들어 out/target/product/roc_rk3328_cc_box/data/app폴더면 안드로이드의 data/app폴더와 연동된다.out/target/product/roc_rk3328_cc_box/system/xxx폴더는 안드로이드의 system/xxx 폴더와 연동된다. 위와 같은 경로를 알면 adb push를 사용해 바로 안드로이드에 적용 가능하다. 1234adb remountadb push out/target/product/roc_rk3328_cc_box/data/app/TouchLatencyJankTestWear/TouchLatencyJankTestWear.apk data/app/TouchLatencyJankTestWear 와 같은 명령어로 해당 파일을 적용 가능하다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform 개발 환경","slug":"Android/Platform-개발-환경","permalink":"http://jung-max.github.io/categories/Android/Platform-개발-환경/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"부분빌드","slug":"부분빌드","permalink":"http://jung-max.github.io/tags/부분빌드/"}]},{"title":"Android Platform 커스터마이즈","slug":"Android-커스터마이즈","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.787Z","comments":true,"path":"2019/08/27/Android-커스터마이즈/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-커스터마이즈/","excerpt":"","text":"안드로이드의 기본 설정값 및 기본 동작은 아래에서 설명할 파일들을 수정하여 변경할 수 있다. 1. 안드로이드 기본 설정값1frameworks/base/packages/SettingsProvider/res/values/defaults.xml 안드로이드 시스템 설정의 초기 값을 정할 수 있다. 이 중에는 기기 사용자가 설정에서 변경할 수 없는 것도 있다.시스템 초기의 WiFi의 On 여부나 Bluetooth의 On 여부, 기본 값 등 2. 안드로이드 시스템 설정1frameworks/base/core/res/res/values/config.xml 시스템 전반의 동작 유형에 대한 변경을 할 수 있다.MasterVolume, NativationBar 표시 여부, 전원 버튼 동작 등 3. 기본 바탕 화면 이미지를 변경1frameworks/base/core/res/res/drawable-nodpi/default_wallpaper.jpg 위 파일을 변경하여 기본 배경 화면을 바꿀 수 있다. 4. device 폴더의 overlay폴더를 이용하여 원본 수정 없이, 각 기기 별 설정을 적용할 수 있다.1device/&lt;company-name&gt;/&lt;product-name&gt;/overlay/frameworks/base/core/res/res/values/config.xml overlay 폴더 밑에는 AOSP 프로젝트를 root로 보고, 그 하위에 절대 경로로 폴더 및 파일을 배치하면, 원본을 override하게 된다. 이를 이용하여, AOSP 원본을 건드리지 않고도 각 기기에 맞춘 수정이 가능하다. 5. 또한, vendor 폴더를 이용하여, vendor의 미리 빌드된 앱, 펌웨어 등을 탑재/이용할 수 있다.1vendor/ 보통 SoC 등 하드웨어와 관련된 라이브러리, 펌웨어와 Vendor 사의 앱이 들어있다. 참고)How to set default properties in AOSP (http://stackoverflow.com/questions/16770639/how-to-set-default-properties-in-aosp) 안드로이드 SDK에서 Android System Config defaults 1frameworks/base/packages/SettingsProvider/res/values/defaults.xml Android System Configs 1frameworks/base/core/res/res/values/config.xml The device directory overrides the original files 1device/&lt;company-name&gt;/&lt;product-name&gt;/overlay/frameworks/base/core/res/res/values/config.xml Default wallpaper 1frameworks/base/core/res/res/drawable-nodpi/default_wallpaper.jpg","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform boot","slug":"Android/Platform-boot","permalink":"http://jung-max.github.io/categories/Android/Platform-boot/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"}]},{"title":"Android System App","slug":"Android-SystemApp","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.779Z","comments":true,"path":"2019/08/27/Android-SystemApp/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-SystemApp/","excerpt":"","text":"System app 권한 추가.AndroidManifest.xml에 sharedUserId 추가. 123&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"ckbs.ywjung.btremocon\" android:sharedUserId=\"android.uid.system\"&gt; build/target/product/security에 있는 platform.pk8파일을 이용해 key파일 생성1234$ openssl pkcs8 -inform DER -nocrypt -in platform.pk8 -out platform.pem$ openssl pkcs12 -export -in platform.x509.pem -inkey platform.pem -out platform.p12 -password pass:android -name androiddebugkey$ keytool -importkeystore -deststorepass android -destkeystore platform.jks -srcstoretype PKCS12 -srcstorepass android -srckeystore platform.p12 app build.gradle 수정android {} 맨 앞에 아래 내용 추가. 12345678signingConfigs &#123; config &#123; keyAlias 'androiddebugkey' keyPassword 'android' storeFile file('D:\\\\Android_Project\\\\BtRemoCon\\\\Keystore\\\\platform.jks') storePassword 'android' &#125;&#125; android {} buildTypes 수정 123456789 buildTypes &#123;// release &#123;// minifyEnabled false// proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'// &#125; debug &#123; signingConfig signingConfigs.config &#125; &#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"Android 기반 커널","slug":"Android-기반-Kernel","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.779Z","comments":true,"path":"2019/08/27/Android-기반-Kernel/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-기반-Kernel/","excerpt":"","text":"개요 Hardware System을 관리할 뿐 아니라 응용 소프트웨어를 실행하기 위한 기능과 서비스를 제공하는 System Software이다. 실행되는 응용 프로그램들이 Memory, CPU, I/O장치 등의 자원들을 사용할 수 있도록 만들어 주고 공통적으로 사용할 수 있는 Service를 제공한다. Process 관리 Process 생성, 제거, Process간 통신(IPC)를 관리 스케쥴링에 의한 승인 여부 및 CPU Time 할등 등을 제어 메모리 관리 모든 Process에 대한 가상 주소(Virtual Address)영역을 구축하며 System Call을 통해 메모리 관리 하위 시스템(Memory Subsystem)과 통신 메모리 할당 및 보호 네트워크 관리 입력되는 패킷은 모두 비동기식 이벤트이므로 Process가 처리할 수 있게 Packet을 모아서 식별한 후 Process로 전달해 주어야 함. File System 관리 FS는 File을 관리하는 방법(파일의 생성, 접근 제어, 디렉토리 관리)을 의미 제품별로 FS의 종류가 다를 수 있음 FS는 Kernel 내부에 포함되어 있으며 응용프로그램에서 사용할 FS를 선택 가능(mount등) UNIX 계역은 FS 구조에 크게 의존하며 응용프로그램의 거의 모든 요소를 파일로 취급 Device(장치) 제어 Device를 제어하기 위한 Software는 OS에 포함되어 있으며 이를 Device Driver라 한다. Process 응용프로그램을 실행하고 있는 동안, Kernel은 실행되는 모든 Processor들을 스케쥴링 하며 마치 그들이 동시에 수행되는 것 처럼 보이는 효과를 낸다.→ 한 Process당 4GB(32bit 기준)의 가상 메모리를 할당 받는다. Device Driver Android에서 사용되는 Kernel의 경우 추가적인 Device Driver가 필요하다. Binder, Ashmem, Low Memory Killer, Logcat Utility, early suspend, late resume등 Module 구동 방식 Kernel이 동작중인 상태에서 Device Driver를 동적으로 추가하거나 제거할 수 있는 개념 Kernel 버전이 동일해야 하는 문제(컴파일 시)가 있으며 Resource를 적게 사용할 수 있는 장점이 있다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Kernel","slug":"Android/Platform-Kernel","permalink":"http://jung-max.github.io/categories/Android/Platform-Kernel/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"}]},{"title":"Android Apk 분해 방법","slug":"Android-앱분해","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.785Z","comments":true,"path":"2019/08/27/Android-앱분해/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-앱분해/","excerpt":"","text":"Android 앱 분해 방법 APK를 다운받는다. https://apkpure.com/ 앱 추출 프로그램 하기 사이트를 접속한다. http://www.javadecompilers.com/apk 아래 메뉴에서 apk를 업로드 하고 apk 분해된 것을 다운받는다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"Android Platform Architecture overview","slug":"Android-Platform-Architecture-overview","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.770Z","comments":true,"path":"2019/08/27/Android-Platform-Architecture-overview/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-Platform-Architecture-overview/","excerpt":"","text":"Android platform architecture overview1. 개요이번 시간은 안드로이드의 구조에 대해서 알아보고 애플리케이션이 어떻게 구동되는지 추론해보는 시간을 가져보겠습니다. 제목은 안드로이드 플랫폼 아키텍쳐라고 정했습니다. 여기서 플랫폼은 컴퓨터 시스템의 기본이 되는 특정 프로세서 모델과 하나의 컴퓨터 시스템을 바탕으로 하는 운영체제를 뜻하며 아키텍쳐란 소프트웨어의 구성요소 사이의 관계, 시스템에 대한 구조의 집합이라고 보시면 되겠습니다. 안드로이드 플랫폼 아키텍쳐를 크게 나누어 보면, 리눅스 커널/ 하드웨어 추상화계층 / 네이티브 라이브러리 / 안드로이드 런타임 / 안드로이드 프레임워크/ 애플리케이션으로 나누어져 있습니다. 이들이 어떠한 역할을 하는지 한번 살펴보겠습니다. 2. Linux Kernel안드로이드는 리눅스 커널을 기반으로 하고 있는 리눅스 계열 OS 입니다. 요기서 커널이란 하드웨어와 우리가 사용하고 있는 OS를 연결시켜주는 다리와 같은 존재로 운영체제에 있어서 핵심이기도 합니다. 커널이 담당하고 있는 것으로는 크게 5가지가 있습니다. * 첫번째는 보안으로 하드웨어와 프로세서의 보안을 담당합니다.* 두번째는 자원관리로서 한정된 시스템 자원을 효율적으로 관리, 프로그램의 실행을 원만하게 합니다.프로세스 처리를 관리하는 스케쥴링을 관리하고 오랫동안 사용되지 않았고 우선순위가 높지 않은 컴포넌트를 구동하는 프로세스들을 제거하는 로우 메모리 킬러를 실행합니다. * 세번째는 추상화입니다. 이는 뒤에서 하드웨어 추상화때 더 자세히 이야기 하겠습니다.간단히 설명하자면 같은 종류의 부품으로 수 많은 종류의 하드웨어를 설계할 수 있기 때문에 하드웨어에 직접 접근하는 것은 다소 복잡하게 될 수 있습니다. 일반적으로 커널은 운영체제의 복잡한 내부를 감추고 일관성 있는 인터페이스를 하드웨어에 제공하기 위해 같은 종류의 하드웨어에 대한 공통 명령어 집합인 추상화들로 이루어집니다. * 네번째는 하드웨어 드라이버입니다.카메라, 블루투스등 각종 하드웨어를 제어하는데 필요로하는 명령어 모음인 드라이버들을 포한하고 있습니다. * 마지막으로 전원 관리입니다. 전력을 끄거나 비활성화 하는 등 wifi / Bluetooth / cpu / gpu등 하드웨어에 공급되는 전력에 대해서 관리합니다. 기본적으로 리눅스의 전원 관리가 많이 사용되는 곳은 노트북입니다. 노트북에서의 절전 모드는 시스템의 상태는 램에 보존 되지만 다른 하드웨어 부품들은 모두 정지됩니다. 이런 전원 관리는 노트북에는 어울리지만 스마트폰등 모바일 기계에서는 어울리지 않습니다. 그래서 안드로이드는 변형된 전원 관리를 사용해 사용자가 명령해야 절전 모드로 가는 대신 안드로이드화된 커널은 가능한 자주 그리고 빨리 절전 모드로 전환합니다. 만약 앱이 중요한 작업중이거나 사용자의 입력을 기다리고 있으면 절전모드로 전환되지 않게 하려고 웨어크락이 시스템을 계속 깨웁니다. (앱에서 명시적으로 사용 가능) * 안드로이드화된 리눅스 커널에서 중요한 개념중 하나는 바인더 입니다. 바인더의 핵심 컨셉은 모든 프로세스가 공유할 수 있는 영역에 요청 내용과 응답 내용을 쓰고, 각 프로세스가 그 메모리 주소를 참조하게 하자입니다. IPC(inter Process Communication) 도구이지만 안드로이드에서는 다른 프로세스에 있는 함수를 마치 현재 프로세스에 존재하는 함수 처럼 사용할 수 있게 해주는 RPC(Remote Procedure Call)을 지원하는데 주로 이용합니다. 3. 하드웨어 추상화 계층하드웨어 추상화는 커널에서 잠시 설명했던 것 처럼, 같은 종류의 부품으로 다양하게 많은 종류의 하드웨어를 설계 할 수 있어 직접 하드웨어에 접근하는 형태는 다소 복잡하게 될 수 있습니다. 이점을 해결하고 복잡한 내부 구조를 감추고 일관성 있는 인터페이스를 제공하기 위해, 같은 종류의 하드웨어에 대한 공통 명령어 집합으로 묶어 둡니다. 이를 하드웨어 추상화라 하며, 프로그래머가 여러 장비에서 개발하는 것을 도와줍니다. 하드웨어 추상화 계층은 장비 제조사의 장비 규격에 대한 특정한 명령어를 제공하는 소프트웨어 드라이버에 의존합니다. HAL(하드웨어 추상화 계층)은 상위 수준의 Java API 프레임워크에 기기 하드웨어 기능을 노출하는 표준 인터페이스를 제공합니다. HAL은 여러 라이브러리 모듈로 구성되어 있으며, 카메라 또는 블루투스 모듈과 같은 특정 유형의 하드웨어 구성 요소를 위한 인터페이스를 구현합니다. 프레임워크 API가 기기 하드웨어에 액세스하기 위해 호출을 수행하면 Android 시스템이 해당 하드웨어 구성 요소에 대한 라이브러리 모듈을 로드합니다. AOSP(Android open source project) 4. 안드로이드 런타임안드로이드 런타임은 흔히 ART로도 이야기하며, ART의 주요 기능은 화면과 같습니다.안드로이드 런타임에 대해서 세부적으로 알아보기 위해서는 기본적으로 자바라는 언어의 구동환경에 대해서 이야기 할 필요성이 있습니다. 일반적으로 컴파일러 언어는 CPU와 플랫폼 환경에 맞추어 기계어로 컴파일 됩니다. 즉 간단하게 말하자면 우리가 이야기 하는 것을 하드웨어가 알아들을 수 있도록 번역하여 저장한다는 뜻입니다. 하지만 자바는 한종류의 CPU와 플랫폼 환경에 맞추어 저장되는 것이 아니라 바이트 코드로 저장되며, 이를 실행하기 위해서는 자바가상머신(JVM, Java Virture Machine)이 필요로 합니다. 이는 자바의 목표가 하나의 바이트 코드로 여러가지 CPU와 플랫폼 환경에서 구동되기 위해서 입니다. 즉 CPU와 플랫폼 환경에 맞는 가상머신이 있다면 하나의 실행파일을가지고 여러가지 환경에서 사용할 수 있다는 뜻입니다. 안드로이드도 기본언어를 JAVA를 사용하기 때문에 VM은 필수적입니다. 이에 자바가상머신을 사용할 수 있지만 오라클과의 라이선스 문제 해결과 JVM이 안드로이드의 구조에 맞추어서 구동할 수 있도록 만들어진 것이 달빅VM과 ART입니다. 이 둘의 차이는 JIT 컴파일러(달빅)을 사용하느냐 AOT컴파일러(ART)를 사용하는가로 나누어 집니다. 둘의 차이는 간단히 말해서 실시간으로 CPU에 맞추어 자바코드로 변환하느냐(달빅) / 앱설치와 최초 앱 실행시 자바코드가 일정부분 한꺼번에 변환, RAM상에 올려두고 작업을 하게 되는가 입니다. JIT는 컴파일러가 돌아가는 동안 하드웨어 부하가 크게 발생하여 배터리 소모가 심한 단점이 있었습니다. AOT는 애플리케이션 설치 공간이 달빅에 비해 1.5~2배 이상 더필요하고 애플리케이션 설치 시간이 더 느린 단점이 있습니다. 현재는 AOT를 사용하기 때문에 애플리케이션 설치시 오래 걸리는 애플리케이션이 있다면 ART 컴파일 과정 중 부하가 많이 걸리는 애플리케이션으로 볼 수 있습니다. 5. 네이티브 라이브러리ART 및 HAL 등의 많은 핵심 Android 시스템 구성 요소와 서비스가 C 및 C++로 작성된 네이티브 라이브러리를 필요로 하는 네이티브 코드를 기반으로 빌드되었습니다. Android 플랫폼은 Java 프레임워크 API를 제공하여 이러한 일부 네이티브 라이브러리의 기능을 앱에 노출합니다. 예를 들어, Android 프레임워크의 Java OpenGL API를 통해 OpenGL ES에 액세스하여 앱에서 2D 및 3D 그래픽을 그리고 조작할 수 있는 지원 기능을 추가할 수 있습니다.(OpenGL ES (임베디드 시스템을 위한 OpenGL)는 크로노스 그룹이 정의한 3차원 컴퓨터 그래픽스 API인 OpenGL의 서브셋으로, 휴대전화, PDA 등과 같은 임베디드 시스템을 위한 API이다.) C 또는 C++ 코드가 필요한 앱을 개발하는 경우에는 Android NDK(Native Development Kit)를 사용하여 네이티브 코드에서 직접 이러한 몇몇 네이티브 플랫폼 라이브러리에 액세스할 수 있습니다. 6. 안드로이드 프레임 워크안드로이드 프레임 워크는 JAVA API 프레임 워크를 말합니다. 안드로이드 OS의 전체기능은 JAVA로 작성된 API를 통해서 접근이 가능합니다. 이 API의 핵심 시스템 구성요소 모듈과 서비스 재사용을 단순화하여 안드로이드 애플리케이션을 제작하는데 필요로 하는 빌딩 블록을 구성합니다. 뷰 시스템 - 목록, 그리드, 텍스트 상자, 버튼 및 삽입 가능한 웹 브라우저를 포함하여 앱의 UI를 빌드하는 데 사용 가능 Resource Manager - 현지화된 문자열, 그래픽 및 레이아웃 파일과 같은 코드가 아닌 리소스에 대한 액세스 제공 Notification Manager - 모든 앱이 상태 표시줄에 사용자 지정 알림을 표시할 수 있도록 지원 Activity Manager - 앱의 수명 주기를 관리하고 공통 탐색 백 스택 제공 콘텐츠 제공자 - 앱이 주소록 앱과 같은 다른 앱의 데이터에 액세스하거나 자신의 데이터를 공유할 수 있도록 지원 7. 애플리케이션여기서 말하는 애플리케이션은 시스템 애플리케이션을 말합니다. 안드로이드는 이메일 / SMS 메시지 / 캘린더 / 인터넷 브라우저 / 주소록등 주요 애플리케이션 세트와 함께 제공됩니다. 플랫폼에 기본적으로 포함된 앱은 사용자가 선택하여 설치하는 애플리케이션과 특별한 구분이 없기 때문에 설정등 일부 애플리케이션을 제외하면 사용자가 설치한 다른 애플리케이션이 기본 애플리케이션으로 지정 가능합니다. 시스템 애플리케이션은 사용자가 직접 사용하는 앱으로도 동작하기도 하지만, 개발자가 자신의 앱에서 접근할 수 있는 주요 기능을 제공하기 위한 용도로도 사용됩니다. 예를 들어서 SMS메세지 애플리케이션 같은 경우 개발자가 해당 기능을 직접 만들 필요 없이, 시스템 앱에 내장된 SMS 메시지 애플리케이션을 호출, 데이터를 주고 받아 지정한 사람에게 메시지를 전달할 수 있습니다. 8. 애플리케이션의 구동이번에는 공부한 아키텍쳐 구조를 토대로 카메라가 어떻게 구현되는지 추론해 보겠습니다. 사용자가 애플리 케이션을 실행시키면 안드로이드 런타임 위에서 컴파일 된 코드들이 동작할 것입니다. JAVA API와 네이티브 라이브러리는 이에 포함되어 있습니다. 그리고 HAL과 커널안의 드라이버를 이용하여 카메라 하드웨어 모듈이 동작할 것이고사용자가 촬영하고 있는 내용을 이미지 센서를 통해서 받아올 것입니다. 이를 다시 JAVA API와 네이티브 라이브러리를 이용해서 사용자에게 결과값을 보내줄 것입니다. 그리고 사용자가 이미지를 저장한다면 다시 해당 이미지의 데이터를 메모리에 저장하는 작업을 진행하게 될 것입니다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform Architecture","slug":"Android/Platform-Architecture","permalink":"http://jung-max.github.io/categories/Android/Platform-Architecture/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Architecture","slug":"Architecture","permalink":"http://jung-max.github.io/tags/Architecture/"}]},{"title":"Android 홈 런쳐 App 작성 방법","slug":"Android-홈런쳐App","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.786Z","comments":true,"path":"2019/08/27/Android-홈런쳐App/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-홈런쳐App/","excerpt":"","text":"속성 설정 방법-&gt;앱의 AndroidManifest.xml을 열어서 intent-filter에 아래와 같이 추가해주면,안드로이드의 홈 버튼을 눌렀을 때 호출될, 런쳐 중 하나로 선택할 수 있다. -&gt;Launcher App의 외관 style 코드인 styles.xml를 아래와 같이 수정하여, 상태바를 투명하게 만들 수 있다. -&gt;MainActivity에 onKeyDown 이벤트 핸들러를 Override하고, false를 반환하게 하면,안드로이드의 뒤로가기 버튼을 눌렀을 때, 앱이 종료되지 않게 할 수 있다. 다른 App 실행 방법-&gt;아래 Launcher Activity에서 유저가 아이콘을 누르게되면, -&gt;등록된 이벤트 핸들러에서 어떤 아이콘이 눌렸는지 확인하여 -&gt;그 아이콘에 해당하는 앱의 패키지명을 이용하여, Intent를 가져오고, 그 Intent를 startActivity()로 실행할 수 있다. App List 가져오는 방법-&gt;PackageManager를 getPackageManager()로 불러오고, 불러온 PackageManager로 각 앱의 intent에 Action MAIN을 지정한 Activity를 전부 찾아서 List로 얻을 수 있다.이렇게 가져온 패키지 리스트를 아래와 같이 Adapter와 GridView를 이용하여 유저에게 보여준다.-&gt;유저가 GridView 목록에서 앱을 눌렀을 때, 눌린 아이콘을 확인하여, 해당하는 패키지를 startActivity()로 실행한다.","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"}]},{"title":"Android 부트로그 수정","slug":"Android-부트로그","date":"2019-08-27T08:29:24.000Z","updated":"2022-02-08T02:11:11.780Z","comments":true,"path":"2019/08/27/Android-부트로그/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-부트로그/","excerpt":"","text":"Linux 커널 부트 로고 변경 이미지를 교체하는 방법kernel/arch/arm/Makefile에 보면 12345LOGO := $(notdir $(wildcard $(srctree)/logo.bmp))LOGO_KERNEL := $(notdir $(wildcard $(srctree)/logo_kernel.bmp))%.img: %.dtb kernel.img $(LOGO) $(LOGO_KERNEL) $(Q)$(srctree)/resource_tool $(objtree)/arch/arm/boot/dts/$*.dtb $(LOGO) $(LOGO_KERNEL) @echo ' Image: resource.img (with $*.dtb $(LOGO) $(LOGO_KERNEL)) is ready' 여기에 보면 kernel/logo.bmp 또는 kernel/kernel_logo.bmp 를 부트로고로 쓰는 것이 보인다. 이미지 변환 명령어 (canon.png는 입력 파일, canon_out.bmp는 출력 파일) 1$ convert canon.png -gravity center -background black -extent 500x501 canon_out.bmp 만일 이미지가 500x501보다 작다면 다음과 같이 -resize 옵션을 추가해준다 (500x 비워두면 가로 500으로 비율 유지) 1$ convert canon.png -gravity center -background black -resize 500x -extent 500x501 canon_out.bmp Android Boot Logo 변경1. 이미지 교체 방법/frameworks/base/cmds/bootanimation/BootAnimation.cpp에 보면 12345bool BootAnimation::android()&#123; initTexture(&amp;mAndroid[0], mAssets, \"images/android-logo-mask.png\"); // texture_object_mask initTexture(&amp;mAndroid[1], mAssets, \"images/android-logo-shine.png\"); mBMPWidth = mTexWidth = mBMPHeight = mTexHeight = 1; frameworks/base/core/res/assets/images/android-logo-mask.png를 배경 사진으로, frameworks/base/core/res/assets/images/android-logo-shine.png를 움직이는 효과로 쓰고 있다. (배경 사진의 투명 부위에 효과가 슬라이드되어, 움직이는 것으로 보임) 2. 애니메이션 수정(출처: http://dplex.egloos.com/v/4267974)(참고: http://w51014.tistory.com/5)FirePrime은 기본형 이미지 방식이기 때문에, 새로 작성하여야 한다. (bootanimation.zip을 제작) /frameworks/base/cmds/bootanimation/bootanimation.cpp에 보면 아래와 같이 정의 돼 있다. 123#define USER_BOOTANIMATION_FILE \"/data/local/bootanimation.zip\"#define SYSTEM_BOOTANIMATION_FILE \"/system/media/bootanimation.zip\"#define SYSTEM_ENCRYPTED_BOOTANIMATION_FILE \"/system/media/bootanimation-encrypted.zip\" 동일 파일의 함수 readyToRun()를 보면, 부트 애니메이션 파일 확인 순서를 알 수 있다. bootanimation.zip 파일을 /out/target/product/rk312x/system/media/에 복사 [bootanimation.zip 설명](참고: https://forum.xda-developers.com/showthread.php?t=2756198)desc.txt 파일과 이미지 파일이 들어있는 part0 폴더를 크기 압축 없이(옵션) 압축 [desc.txt 파일 설명]800 480 23 –&gt; &lt;가로&gt; &lt;세로&gt; &lt;초당 프레임 수&gt;p 10 10 part0 –&gt; &lt;재생횟수&gt; &lt;재생 후 딜레이&gt; &lt;재생할 폴더명&gt; HDPI = 480x800XHDPI = 720x1280XXHDPI = 1080x1920 딜레이: 50은 0.5초 [샘플](출처: https://forum.xda-developers.com/google-nexus-5/themes-apps/android-l-bootanimation-60fps-t2898727)bootanimation60fps1080p.zipbootanimation60fps1080pbig.zip [샘플2](출처: https://forum.xda-developers.com/nexus-6/themes-apps/bootanimation-nexus-6-boot-animation-t3111805)","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"Platform boot","slug":"Android/Platform-boot","permalink":"http://jung-max.github.io/categories/Android/Platform-boot/"}],"tags":[{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"boot","slug":"boot","permalink":"http://jung-max.github.io/tags/boot/"}]},{"title":"Android-Bluetooth","slug":"Android-Bluetooth","date":"2019-08-27T07:59:12.000Z","updated":"2022-02-08T02:11:11.747Z","comments":true,"path":"2019/08/27/Android-Bluetooth/","link":"","permalink":"http://jung-max.github.io/2019/08/27/Android-Bluetooth/","excerpt":"","text":"블루투스 개요 10m 정도의 가까운 거리에 있는 컴퓨터와 휴대폰, 가전제품등을 무선으로 연결하는 기술 블루투스 장점 비교적 저렴한 저전력 근거리 무선 솔루션 다른 무선 기술들에 비해 전자파 간섭 현상에 강함 여러 대의 블루투스 디바이스들과 동시에 접속 가능 무선랜과 달리 데이터와 음성 채널을 모두 가지고 있음 크기가 작아 이동 통신용 단말기 등에 탑재가 용이 블루투스의 특징 데이터 전송 속도 : 25Mbps(블루투스 4.0 버전) 부품의 크기 : 1.2cm²의 크기 저렴한 가격 : 5~10$ 작은 전력 소모 : 100mV 미만 무선 주파수 : 2.4GHz 주파수 대역 블루투스 4.0 버전 부터 나누어진 기능 클래식 블루투스 : 기존 블루투스 3.0 이하와 같은 기능 지원 블루투스 하이 스피드 : 와이파이와 블루투스의 혼합칩을 사용, 와이파이의 속도로 수미터~수백미터의 원거리 통신이 가능 블루투스 저전력 : 비교적 낮은 전력으로 블루투스 기능 지원 안드로이드 History안드로이드 2.0 android.bluetooth 패키지 제공안드로이드 3.0 BluetoothProfile 인터페이스와 함께 BluetoothA2dp 클래스와 BluetoothHeadset 클래스 추가안드로이드 4.0 BluetoothHealth 클래스 추가안드로이드 4.3 블루투스의 저전력 기능 지원을 위한 BluetoothGatt, BluetoothGattCallback, BluetoothGattCharacteristic, BluetoothGattService 클래스를 제공 저전력 기능은 색다른 기능이 아닌 블루투스 검색시 비교적 저전력으로 수행할 수 있도록 만들어 준다. 블루투스 프로파일(Profile)프로파일이란 블루투스 디바이스사이의 통신 규약(또는 프로토콜)을 말한다.예를 들어 헤드셋이나 핸즈 프리 프로파일은 휴대전화에 연결된 헤드셋으로 통화할 수 있는 규약을 이야기함 중요 프로파일의 종류 A2DP(Advanced Audio Distribution Profile) : 스테레오 음질 수준의 오디오가 스트리밍될 수있는 방법을 설명합니다. AVRCP(Audio/Video Remote Control Profile) : 텔레비전, 스테레오 오디오 장비 (Stereo Audio Equipment) 또는 다른 A/V 기기를 제어하기 위한 표준 인터페이스 (Standard Interface)를 제공하기 위해 설계되었습니다. 이 프로파일은 하나의 리모컨 (또는 다른 장치)로 사용자가 액세스할 수 있는 모든 A/V 기기를 제어 가능하게 합니다. BPP (Basic Printing Profile) : 장치가 인쇄 작업에 따라 프린터에 텍스트, 이메일, V-카드, 이미지 또는 기타 정보를 보낼 수 있게 해줍니다 FTP (File Transfer Profile) : 서버 장치의 폴더 및 파일을 클라이언트 장치에 의해 탐색될 수 있는 방법을 정의합니다 GAP(Generic Access Profile) : 모든 블루투스 프로파일에 있어 기본적으로 적용되는 프로파일이다. GAP 프로파일은 블루투스 검색이나 디바이스간의 연결 처리를 정의하고 있다. GATT(Generic Attribute Profile)블루투스 저전력 사용을 위한 프로파일이다. 저전력은 별도 속성 프로토콜(ATT)를 사용하기 때문에 경우에 따라 GATT/ATT라고 표현하기도 한다. HFP(Hands-Free-Profile) : 휴대 전화의 음성 통신을 송수신 및 제어하는 프로파일이다. HID(Human Interface Device Profile) : 키보드, 마우스, 멀티미디어, 조이스틱을 지원하는 프로파일이다. HSP(Headset Profile) : 오디오를 지원하는 프로파일이다. SPP(Serial Port Profile) : 시리얼 통신으로 데이터를 송수신하는 프로파일이다. SDAP(Service Discovery Application Profile) : 블루투스 장치가 제공하는 서비스 정보를 파악할 때 사용하는 프로파일이다. HDP(Health Device Profile) : 건강과 관련된 장치를 지원하는 프로파일이다. 위 프로파일 가운데 반드시 존재해야 하는 블루투스의 프로파일은 GAP와 SDAP이다. GAP 프로파일안드로이드를 포함하여 모든 블루투스 단말기는 GAP 프로파일을 지원하기 위해서 4가지 주요 작업들을 순차적으로 수행한다. 블루투스 디바이스의 활성화 작업 블루투스 디바이스를 검색하는 작업(옵션) 블루투스 디바이스들간에 연결하는 작업 블루투스 디바이스가 지원하는 서비스 정보의 전송과 수신 작업 안드로이드의 블루투스 권한개발자가 안드로이드의 블루투스 기능을 사용하려면 AndroidManifest.xml파일에 다음과 같이 권한을 주어야 한다. 12&lt;uses-permission android:name=\"android.permission.BLUETOOTH\"/&gt;&lt;uses-permission android:name=\"android.permission.BLUETOOTH_ADMIN\" /&gt; BLUETOOTH 권한은 블루투스간의 연결 요구, 연결 승인, 데이터 전송등의 블루투스 통신을 하기 위해 필요한 권한이다. BLUETOOTH_ADMIN 권한은 디바이스 검색을 시작하거나, 블루투스 설정 작업을 할 때 필요한 권한이다. 저전력 블루투스를 사용하려면 다음과 같은 사용 권한 역시 추가시켜 주어야 한다. 123&lt;uses-feature android:name=\"android.hardware.bluetooth_le\" android:required=\"true\"/&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\" /&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/&gt; 블루투스 활성화블루투스를 사용하여 통신하려면 블루투스가 기기에서 지원되는지 확인하고, 지원되는 경우 활성화해야 합니다. 1. BluetoothAdapter 가져오기 모든 블루투스 액티비티를 위해 BluetoothAdapter가 필요. BluetoothAdapter를 가져오려면 정적 getDefaultAdapter() 메서드를 호출. getDefaultAdapter()가 null을 반환하는 경우 기기는 블루투스를 지원하지 않음. 1234BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter();if (mBluetoothAdapter == null) &#123; // Device does not support Bluetooth&#125; BluetoothAdapter 로컬 블루투스 어댑터(블루투스 송수신 장치) BluetoothAdapter는 블루투스 상호작용에 대한 진입점 이를 사용하여 다른 블루투스 기기를 검색하고 연결된(페어링된) 기기 목록을 쿼리할 수 있음 또한 알려진 MAC 주소로 BluetoothDevice를 인스턴스화하고, 다른 기기로부터 통신을 수신 대기하는 BluetoothServerSocket을 만들 수 있음 2. 블루투스 활성화 isEnabled()를 호출하여 블루투스가 현재 활성화되었는지 확인. 이 메서드가 false를 반환하는 경우 블루투스는 비활성화를 뜻함. 블루투스 활성화를 요청하려면 ACTION_REQUEST_ENABLE 작업 인텐트를 사용하여 startActivityForResult()를 호출. 123456789if (!mBluetoothAdapter.isEnabled()) &#123; Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);&#125;//orif (!mBluetoothAdapter.isEnabled()) &#123; mBluetoothAdapter.enable(); //강제 활성화&#125; 블루투스 상태변화 브로드캐스트 수신12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); /* ... */ // Register for broadcasts on BluetoothAdapter state change IntentFilter filter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED); registerReceiver(mReceiver, filter);&#125;@Overridepublic void onDestroy() &#123; super.onDestroy(); /* ... */ // Unregister broadcast listeners unregisterReceiver(mReceiver);&#125;private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; final String action = intent.getAction(); if (action.equals(BluetoothAdapter.ACTION_STATE_CHANGED)) &#123; final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.ERROR); // EXTRA_STATE가 존재하지 않는다면 ERROR를 반환 switch (state) &#123; case BluetoothAdapter.STATE_OFF: //블루투스 비활성화 setButtonText(\"Bluetooth off\"); break; case BluetoothAdapter.STATE_TURNING_OFF: //비활성화 되어가고있음 setButtonText(\"Turning Bluetooth off...\"); break; case BluetoothAdapter.STATE_ON: //활성화 setButtonText(\"Bluetooth on\"); break; case BluetoothAdapter.STATE_TURNING_ON: //활성화 중 setButtonText(\"Turning Bluetooth on...\"); break; &#125; &#125; &#125;&#125;; 블루투스 검색과 페어링 BluetoothAdapter를 사용하면 기기 검색을 통해 또는 페어링된(연결된) 기기의 목록을 쿼리하여 원격 블루투스 기기를 찾을 수 있다. 기기 검색은 블루투스 사용 기기에 대해 로컬 영역을 검색하고 각각에 대한 정보를 요청하는 검색 절차 로컬 영역 내의 블루투스 기기는 검색 가능하도록 현재 활성화된 경우에만 검색 요청에 응답 기기는 검색 가능한 경우 기기 이름, 클래스 및 고유 MAC 주소와 같은 정보를 공유 페어링 원격 기기와 처음으로 연결되면 페어링 요청이 자동으로 사용자에게 제공 기기가 페어링되면 해당 기기에 대한 기본 정보(예: 기기 이름, 클래스 및 MAC 주소)는 저장되고 Bluetooth API를 사용하여 읽을 수 있다. 원격 기기에 대해 알려진 MAC 주소를 사용하면 (기기가 범위 내에 있다고 가정하여) 검색을 수행하지 않고 언제든지 연결을 시작할 수 있다. 페어링은 두 기기가 서로의 존재를 알고 있고 인증에 사용할 수 있는 공유 링크 키를 가지고 있으며 서로 암호화된 연결을 설정할 수 있음을 의미 연결은 기기가 현재 RFCOMM 채널을 공유하고 있고 데이터를 서로 전송할 수 있음을 의미 Android에서 페어링 현재 Android Bluetooth API는 RFCOMM 연결을 설정할 수 있기 전에 기기를 페어링하도록 요청 Bluetooth API와 암호화된 연결을 시작하면 페어링이 자동으로 수행 페어링된 기기 쿼리123456789Set&lt;BluetoothDevice&gt; pairedDevices = mBluetoothAdapter.getBondedDevices(); //페어링된 기기를 나타내는 BluetoothDevice 집합// If there are paired devicesif (pairedDevices.size() &gt; 0) &#123; // Loop through paired devices for (BluetoothDevice device : pairedDevices) &#123; // Add the name and address to an array adapter to show in a ListView mArrayAdapter.add(device.getName() + \"\\n\" + device.getAddress()); //ArrayAdapter를 사용하여 각 기기의 이름을 사용자에게 표시 &#125;&#125; 페어링 요청 123456789101112public void pairDevice(BluetoothDevice device) &#123; String ACTION_PAIRING_REQUEST = \"android.bluetooth.device.action.PAIRING_REQUEST\"; Intent intent = new Intent(ACTION_PAIRING_REQUEST); intent.putExtra(BluetoothDevice.EXTRA_DEVICE, device); String EXTRA_PAIRING_VARIANT = \"android.bluetooth.device.extra.PAIRING_VARIANT\"; int PAIRING_VARIANT_PIN = 0; //핀코드를 0으로 함 intent.putExtra(EXTRA_PAIRING_VARIANT, PAIRING_VARIANT_PIN); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); &#125; 기기 검색 기기 검색을 시작하려면 startDiscovery()를 호출 이는 비동기 프로세스이며 해당 메서드는 검색이 성공적으로 시작했는지 여부를 나타내는 bool을 즉시 반환 검색 프로세스는 일반적으로 12초 정도의 조회 스캔과, 블루투스 이름을 가져오는 검색된 각 기기의 페이지 스캔을 포함 1234567// 현재 검색 진행중이면 검색을 취소시킴if(mBluetoothAdapter.isDiscovering())&#123; mBluetoothAdapter.cancelDiscovery();&#125;//BluetoothAdapter를 사용하여 검색 작업을 수행mBluetoothAdapter.startDiscovery(); 기기 검색에 따른 브로드캐스트ACTION_DISCOVERY_STARTED &amp; ACTION_DISCOVERY_FINISHED ACTION_DISCOVERY_FINISHED : 장치 검색 시작 ACTION_DISCOVERY_FINISHED : 장치 검색 완료 12345678910111213BroadcastReceiver discoveryMonitor = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; if (intent.getAction() == BluetoothAdapter.ACTION_DISCOVERY_STARTED ) &#123; ... // 장치 검색 시작 &#125; else if (intent.getAction() == BluetoothAdapter.ACTION_DISCOVERY_FINISHED ) &#123; ... // 장치 검색 완료 &#125; &#125;&#125;;registerReceiver(discoveryMonitor, new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_STARTED));registerReceiver(discoveryMonitor, new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED)); ACTION_FIOUND 검색된 각 기기에 대한 정보를 수신 getName() : 블루투스 디바이스의 이름을 얻는다. getAddress() : 블루투스 디바이스의 MAC 주소를 얻는다. 12345678910111213141516// Create a BroadcastReceiver for ACTION_FOUNDprivate final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); // When discovery finds a device if (BluetoothDevice.ACTION_FOUND.equals(action)) &#123; // Get the BluetoothDevice object from the Intent BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); // Add the name and address to an array adapter to show in a ListView mArrayAdapter.add(device.getName() + \"\\n\" + device.getAddress()); &#125; &#125;&#125;;// Register the BroadcastReceiverIntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);registerReceiver(mReceiver, filter); // Don't forget to unregister during onDestroy 기기 검색기능 활성화 로컬 기기를 다른 기기가 검색할 수 있게 하려면 ACTION_REQUEST_DISCOVERABLE 작업 인텐트를 사용하여 startActivityForResult(Intent, int)을 호출 기본적으로 기기가 120초 동안 검색 가능 EXTRA_DISCOVERABLE_DURATION 인텐트 엑스트라를 추가하여 다른 기간을 정의할 수 있다. 앱이 설정할 수 있는 최대 기간은 3600초이며 값이 0인 경우 기기가 항상 검색 가능. 0 미만 또는 3600 초과 값은 120초로 자동 설정 1234Intent discoverableIntent = newIntent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);discoverableIntent.putExtra(BluetoothAdapter.EXTRA_DISCOVERABLE_DURATION, 300); //300초 의미startActivity(discoverableIntent); 블루투스 데이터 통신 두 기기에서 애플리케이션 간 연결을 생성하려면 서버측 메커니즘과 클라이언트측 메커니즘을 모두 구현해야 한 기기는 서버 소켓을 열고 다른 기기는 (서버 기기의 MAC 주소를 사용하여) 연결을 시작해야 하기 때문 서버와 클라이언트는 각각 동일한 RFCOMM(프로토콜) 채널에 연결된 BluetoothSocket이 있는 경우 서로 연결된 것으로 간주 서버는 들어오는 연결을 수락할 때 BluetoothSocket를 수신. 클라이언트는 서버에 대한 RFCOMM 채널을 열 때 BluetoothSocket를 수신 블루투스 데이터 통신 서버 두 기기를 연결하려면 한 기기는 열린 BluetoothServerSocket을 제공하여 서버로 작동해야 서버 소켓의 목적은 들어오는 연결 요청을 수신 대기하고 수락 시 연결된 BluetoothSocket을 제공하는 것 BluetoothServerSocket 생성 listenUsingRfcommWithServiceRecord(String, UUID)를 호출하여 BluetoothServerSocket을 가져옴 클라이언트는 이 기기와 연결을 시도할 때 연결할 서비스를 고유하게 식별하는 UUID를 제공 UUID는 클라이언트와 서버가 서로 일치해야함 UUID TCP/UDP 프로토콜의 포트 번호처럼 블루투스가 제공하는 서비스를 식별하는 하나의 아이디로 사용 UUID 목록 사용법은 BASE_UUID의 앞자리를 프로토콜 식별자에 맞게 바꾸어 준다.ex&gt; 핸즈프리 0x111E 핸즈프리 프로파일(HFP)→ 0000111E-0000-1000-8000-00805F9B34FB 연결 요청에 대한 응답 accept()를 호출하여 연결 요청에 대한 수신 대기를 시작 이는 호출 차단이며, 연결이 수락되거나 예외가 발생한 경우 반환 원격 기기가 이 수신 대기 서버 소켓에 등록된 것과 일치하는 UUID를 사용하여 연결 요청을 보내는 경우에만 연결이 수락 성공적으로 수행된 경우 accept()는 연결된 BluetoothSocket을 반환 서버 소켓 close 추가 연결을 수락하지 않으려면 close()를 호출 그러면 서버 소켓과 모든 리소스가 해제되지만 accept()가 반환한 연결된 BluetoothSocket이 닫히지 않음 대부분의 경우에 연결된 소켓을 수락한 직후에 BluetoothServerSocket에서 close()를 호출하는 것이 합당 연결을 수락하는 서버 구성 요소에 대한 간단한 스레드12345678910111213141516171819202122232425262728293031323334353637383940private class AcceptThread extends Thread &#123; private final BluetoothServerSocket mmServerSocket; public AcceptThread() &#123; // Use a temporary object that is later assigned to mmServerSocket, // because mmServerSocket is final BluetoothServerSocket tmp = null; try &#123; // MY_UUID is the app's UUID string, also used by the client code tmp = mBluetoothAdapter.listenUsingRfcommWithServiceRecord(NAME, MY_UUID); &#125; catch (IOException e) &#123; &#125; mmServerSocket = tmp; &#125; public void run() &#123; BluetoothSocket socket = null; // Keep listening until exception occurs or a socket is returned while (true) &#123; try &#123; socket = mmServerSocket.accept(); &#125; catch (IOException e) &#123; break; &#125; // If a connection was accepted if (socket != null) &#123; // Do work to manage the connection (in a separate thread) manageConnectedSocket(socket); mmServerSocket.close(); break; &#125; &#125; &#125; /** Will cancel the listening socket, and cause the thread to finish */ public void cancel() &#123; try &#123; mmServerSocket.close(); &#125; catch (IOException e) &#123; &#125; &#125;&#125; 클라이언트로 연결 원격 기기(열린 서버 소켓을 제공하는 기기)와의 연결을 시작하려면 먼저 원격 기기를 나타내는 BluetoothDevice 객체를 가져와함 그리고 나서 BluetoothDevice를 사용하여 BluetoothSocket을 가져오고 연결을 시작 BluetoothSocket 객체 얻기 BluetoothDevice를 통해 createRfcommSocketToServiceRecord(UUID)를 호출하여 BluetoothSocket을 가져온다. connect()를 호출하여 연결을 시작 connect()를 호출할 때 기기 검색을 수행하지 않도록 해야 한다. 클라이언트로 예123456789101112131415161718192021222324252627282930313233343536373839404142434445private class ConnectThread extends Thread &#123; private final BluetoothSocket mmSocket; private final BluetoothDevice mmDevice; public ConnectThread(BluetoothDevice device) &#123; // Use a temporary object that is later assigned to mmSocket, // because mmSocket is final BluetoothSocket tmp = null; mmDevice = device; // Get a BluetoothSocket to connect with the given BluetoothDevice try &#123; // MY_UUID is the app's UUID string, also used by the server code tmp = device.createRfcommSocketToServiceRecord(MY_UUID); &#125; catch (IOException e) &#123; &#125; mmSocket = tmp; &#125; public void run() &#123; // Cancel discovery because it will slow down the connection mBluetoothAdapter.cancelDiscovery(); try &#123; // Connect the device through the socket. This will block // until it succeeds or throws an exception mmSocket.connect(); &#125; catch (IOException connectException) &#123; // Unable to connect; close the socket and get out try &#123; mmSocket.close(); &#125; catch (IOException closeException) &#123; &#125; return; &#125; // Do work to manage the connection (in a separate thread) manageConnectedSocket(mmSocket); &#125; /** Will cancel an in-progress connection, and close the socket */ public void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException e) &#123; &#125; &#125;&#125; 블루투스 서비스 검색안드로이드 4.0.3 버전 이상부터 UUID를 취득하기 위해 아래와 같은 함수들을 제공한다. public boolean fetchUuidsWithSdp() 위 메소드 호출시 안드로이드 프레임워크는 BluetoothDevice 객체가 가리키는 외부 블루투스의 SDP(Service Discovery Protocol) 내 데이터베이스로 저장하고 있는 서비스 이름과 UUID의 제공을 요청 검색된 UUID는 ACTION_UUID라는 액션과 BluetoothDevice.EXTRA_UUID라는 엑스트라와 함께 브로드캐스트 인텐트를 통해 제공123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100@Overridepublic void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); Toolbar myToolbar = (Toolbar) findViewById(R.id.my_toolbar); setSupportActionBar(myToolbar); btnScanDevice = (Button)findViewById(R.id.scandevice); out = (TextView) findViewById(R.id.out); IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND); filter.addAction(BluetoothDevice.ACTION_UUID); filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_STARTED); filter.addAction(BluetoothAdapter.ACTION_DISCOVERY_FINISHED); registerReceiver(ActionFoundReceiver, filter); bluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); if(bluetoothAdapter==null) &#123; out.append(\"Bluetooth NOT supported. Aborting.\\n\"); return; &#125; out.append(\"Adapter: \" + bluetoothAdapter); if (bluetoothAdapter.isEnabled())&#123; if(bluetoothAdapter.isDiscovering())&#123; out.append(\"블루투스는 현재 검색 진행중이다.\"); &#125;else&#123; out.append(\"블루투스는 이미 활성화되어 있습니다.\"); btnScanDevice.setEnabled(true); &#125; &#125;else&#123; out.append(\"블루투스를 활성화시킵니다.!\"); Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT); &#125; btnScanDevice.setOnClickListener(ScanDevice);&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); if (bluetoothAdapter != null &amp;&amp; bluetoothAdapter.isDiscovering()) &#123; bluetoothAdapter.cancelDiscovery(); &#125; unregisterReceiver(ActionFoundReceiver);&#125;private final BroadcastReceiver ActionFoundReceiver = new BroadcastReceiver()&#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); if (BluetoothDevice.ACTION_FOUND.equals(action)) &#123; BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); out.append(\"\\n Device: \" + device.getName() + \", \" + device); btDeviceList.add(device); return; &#125; if (BluetoothDevice.ACTION_UUID.equals(action)) &#123; BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE); Parcelable[] uuidExtra = intent.getParcelableArrayExtra(BluetoothDevice.EXTRA_UUID); for (int i=0; i&lt;uuidExtra.length; i++) &#123; out.append(\"\\n Device: \" + device.getName() + \", \" + device + \", Service: \" + uuidExtra[i].toString()); &#125; return; &#125; if(BluetoothAdapter.ACTION_DISCOVERY_STARTED.equals(action)) &#123; out.append(\"\\nDiscovery Started...\"); mProgressItem.setVisible(true); return; &#125; if(BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) &#123; out.append(\"\\nDiscovery Finished\"); Iterator&lt;BluetoothDevice&gt; itr = btDeviceList.iterator(); while (itr.hasNext()) &#123; // Get Services for paired devices BluetoothDevice device = itr.next(); out.append(\"\\nGetting Services for \" + device.getName() + \", \" + device); if(!device.fetchUuidsWithSdp()) &#123; out.append(\"\\nSDP Failed for \" + device.getName()); &#125; &#125; out.append(\"\\n페이링 디바이스로부터 UUID를 얻습니다.\"); Set&lt;BluetoothDevice&gt; pairedDevices = bluetoothAdapter.getBondedDevices(); for(BluetoothDevice device : pairedDevices) &#123; out.append(\"\\nGetting Services for \" + device.getName() + \", \" + device); if(!device.fetchUuidsWithSdp()) &#123; out.append(\"\\nSDP Failed for \" + device.getName()); &#125; &#125; mProgressItem.setVisible(false); &#125; &#125;&#125;; public ParcelUuid[] getUUids() getUUID() 메소드를 사용하여 다음과 같은 방법으로 블루투스 디바이스로부터 UUID를 얻을 수 있다.12BluetoothDevice phoneDevice = bluetoothAdapter.getRemoteDevice(phoneAddress);ParcelUuid[] phoneUuids = phoneDevice.getUuids(); 연결 관리 두 대 이상의 기기를 성공적으로 연결한 경우 각 기기는 연결된 BluetoothSocket을 갖는다. BluetoothSocket을 사용하여 임의의 데이터를 전송하는 일반적인 절차는 다음과 같다. getInputStream() 및 getOutputStream()을 각각 사용하여 소켓을 통한 전송을 처리하는 InputStream 및 OutputStream을 가져온다. read(byte[]) 및 write(byte[])을 사용하여 스트림에 데이터를 읽고 쓴다. 모든 스트림 읽기 및 쓰기를 위한 전용 스레드를 사용해야 한다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253private class ConnectedThread extends Thread &#123; private final BluetoothSocket mmSocket; private final InputStream mmInStream; private final OutputStream mmOutStream; public ConnectedThread(BluetoothSocket socket) &#123; mmSocket = socket; InputStream tmpIn = null; OutputStream tmpOut = null; // Get the input and output streams, using temp objects because // member streams are final try &#123; tmpIn = socket.getInputStream(); tmpOut = socket.getOutputStream(); &#125; catch (IOException e) &#123; &#125; mmInStream = tmpIn; mmOutStream = tmpOut; &#125; public void run() &#123; byte[] buffer = new byte[1024]; // buffer store for the stream int bytes; // bytes returned from read() // Keep listening to the InputStream until an exception occurs while (true) &#123; try &#123; // Read from the InputStream bytes = mmInStream.read(buffer); // Send the obtained bytes to the UI activity mHandler.obtainMessage(MESSAGE_READ, bytes, -1, buffer) .sendToTarget(); &#125; catch (IOException e) &#123; break; &#125; &#125; &#125; /* Call this from the main activity to send data to the remote device */ public void write(byte[] bytes) &#123; try &#123; mmOutStream.write(bytes); &#125; catch (IOException e) &#123; &#125; &#125; /* Call this from the main activity to shutdown the connection */ public void cancel() &#123; try &#123; mmSocket.close(); &#125; catch (IOException e) &#123; &#125; &#125;&#125; 블루투스 프로필 Bluetooth 프로필은 기기 간 블루투스 기반 통신에 대한 무선 인터페이스 사양 예로 Hands-Free 프로필이 있음. 휴대폰이 무선 헤드셋에 연결하려면 두 기기가 Hands-Free 프로필을 지원해야 한다. 인터페이스 BluetoothProfile을 구현하여 특정 Bluetooth 프로필을 지원하는 자신만의 클래스를 작성할 수 있다. Android Bluetooth API는 다음 Bluetooth 프로필에 대한 구현을 제공 Android는 프로세스 간 통신(IPC)을 통해 블루투스 헤드셋 서비스를 제어하는 프록시인 BluetoothHeadset 클래스를 제공 Android는 IPC를 통해 블루투스 A2DP(Advanced Audio Distribution Profile) 서비스를 제어하는 프록시인 BluetoothA2dp 클래스를 제공(고품질 오디오가 기기 간 스트리밍) 의료 기기 프로필 Bluetooth Health API는 BluetoothHealth, BluetoothHealthCallback 및 BluetoothHealthAppConfiguration 클래스를 포함 이를 사용하면 블루투스를 사용하여 블루투스를 지원하는 의료 기기(예: 심박측정기, 혈압계, 체온계, 체중계)와 통신하는 애플리케이션을 만들 수 있음. 기본적인 프로필 작업 단계 블루투스 설정에서 설명한 기본 어댑터를 가져온다. getProfileProxy()를 사용하여 프로필에 연결된 프로필 프록시 객체에 대한 연결을 설정. BluetoothProfile.ServiceListener를 설정. 이 리스너는 서비스에 연결되었거나 연결이 끊어진 경우 BluetoothProfile IPC 클라이언트에 알린다. onServiceConnected()에서 프로필 프록시 객체에 대한 핸들을 가져온다. 프로필 프록시 객체가 있는 경우 해당 객체를 사용하여 연결 상태를 모니터링하고 해당 프로필과 관련된 다른 작업을 수행. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266package com.android.btprofiles;import android.app.Activity;import android.bluetooth.BluetoothA2dp;import android.bluetooth.BluetoothAdapter;import android.bluetooth.BluetoothDevice;import android.bluetooth.BluetoothHeadset;import android.bluetooth.BluetoothHealth;import android.bluetooth.BluetoothProfile;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.os.Bundle;import android.util.Log;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.AdapterView;import android.widget.ArrayAdapter;import android.widget.ListView;import android.widget.TextView;import android.widget.Toast;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedList;import java.util.List;public class BluetoothProfiles extends Activity implements AdapterView.OnItemClickListener &#123; private final String TAG = getClass().getSimpleName(); private static final int REQUEST_ENABLE_BT = 1; private ArrayAdapter&lt;String&gt; mConnectedDevices; private ListView mList; private BluetoothHeadset mBluetoothHeadset; private BluetoothA2dp mBluetoothA2dp; private BluetoothHealth mBluetoothHealth; private final BluetoothAdapter mBluetoothAdapter = BluetoothAdapter.getDefaultAdapter(); private final List&lt;BluetoothDevice&gt; mVoicerecognizing = Collections.synchronizedList(new ArrayList&lt;BluetoothDevice&gt;()); private final BroadcastReceiver mReceiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; String action = intent.getAction(); Bundle extras = intent.getExtras(); int state = extras.getInt(BluetoothProfile.EXTRA_STATE); int prevState = extras.getInt(BluetoothProfile.EXTRA_PREVIOUS_STATE); BluetoothDevice device = extras.getParcelable(BluetoothDevice.EXTRA_DEVICE); if (action.equals(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED)) &#123; String stateStr = state == BluetoothProfile.STATE_CONNECTED ? \"CONNECTED\" : state == BluetoothProfile.STATE_CONNECTING ? \"CONNECTING\" : state == BluetoothProfile.STATE_DISCONNECTED ? \"DISCONNECTED\" : state == BluetoothProfile.STATE_DISCONNECTING ? \"DISCONNECTING\" : \"Unknown\"; String prevStateStr = prevState == BluetoothProfile.STATE_CONNECTED ? \"CONNECTED\" : prevState == BluetoothProfile.STATE_CONNECTING ? \"CONNECTING\" : prevState == BluetoothProfile.STATE_DISCONNECTED ? \"DISCONNECTED\" : prevState == BluetoothProfile.STATE_DISCONNECTING ? \"DISCONNECTING\" : \"Unknown\"; Log.d(TAG, \"BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED: EXTRA_DEVICE=\" + device.getName() + \" EXTRA_STATE=\" + stateStr + \" EXTRA_PREVIOUS_STATE=\" + prevStateStr); &#125; else if (action.equals(BluetoothA2dp.ACTION_PLAYING_STATE_CHANGED)) &#123; String stateStr = state == BluetoothA2dp.STATE_NOT_PLAYING ? \"NOT_PLAYING\" : state == BluetoothA2dp.STATE_PLAYING ? \"PLAYING\" : \"Unknown\"; String prevStateStr = prevState == BluetoothA2dp.STATE_NOT_PLAYING ? \"NOT_PLAYING\" : prevState == BluetoothA2dp.STATE_PLAYING ? \"PLAYING\" : \"Unknown\"; Log.d(TAG, \"BluetoothA2dp.ACTION_PLAYING_STATE_CHANGED: EXTRA_DEVICE=\" + device.getName() + \" EXTRA_STATE=\" + stateStr + \" EXTRA_PREVIOUS_STATE=\" + prevStateStr); &#125; else if (action.equals(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED)) &#123; String stateStr = state == BluetoothHeadset.STATE_AUDIO_CONNECTED ? \"AUDIO_CONNECTED\" : state == BluetoothHeadset.STATE_AUDIO_CONNECTING ? \"AUDIO_CONNECTING\" : state == BluetoothHeadset.STATE_AUDIO_DISCONNECTED ? \"AUDIO_DISCONNECTED\" : \"Unknown\"; String prevStateStr = prevState == BluetoothHeadset.STATE_AUDIO_CONNECTED ? \"AUDIO_CONNECTED\" : prevState == BluetoothHeadset.STATE_AUDIO_CONNECTING ? \"AUDIO_CONNECTING\" : prevState == BluetoothHeadset.STATE_AUDIO_DISCONNECTED ? \"AUDIO_DISCONNECTED\" : \"Unknown\"; Log.d(TAG, \"BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED: EXTRA_DEVICE=\" + device.getName() + \" EXTRA_STATE=\" + stateStr + \" EXTRA_PREVIOUS_STATE=\" + prevStateStr); &#125; else if (action.equals(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED)) &#123; String stateStr = state == BluetoothHeadset.STATE_CONNECTED ? \"CONNECTED\" : state == BluetoothHeadset.STATE_CONNECTING ? \"CONNECTING\" : state == BluetoothHeadset.STATE_DISCONNECTED ? \"DISCONNECTED\" : state == BluetoothHeadset.STATE_DISCONNECTING ? \"DISCONNECTING\" : \"Unknown\"; String prevStateStr = prevState == BluetoothHeadset.STATE_CONNECTED ? \"CONNECTED\" : prevState == BluetoothHeadset.STATE_CONNECTING ? \"CONNECTING\" : prevState == BluetoothHeadset.STATE_DISCONNECTED ? \"DISCONNECTED\" : prevState == BluetoothHeadset.STATE_DISCONNECTING ? \"DISCONNECTING\" : \"Unknown\"; Log.d(TAG, \"BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED: EXTRA_DEVICE=\" + device.getName() + \" EXTRA_STATE=\" + stateStr + \" EXTRA_PREVIOUS_STATE=\" + prevStateStr); &#125; else if (action.equals(BluetoothHeadset.ACTION_VENDOR_SPECIFIC_HEADSET_EVENT)) &#123; String cmd = extras.getString(BluetoothHeadset.EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD); int type = extras.getInt(BluetoothHeadset.EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_CMD_TYPE); String[] args = extras.getStringArray(BluetoothHeadset.EXTRA_VENDOR_SPECIFIC_HEADSET_EVENT_ARGS); String typeStr = type == BluetoothHeadset.AT_CMD_TYPE_READ ? \"AT_CMD_TYPE_READ\" : type == BluetoothHeadset.AT_CMD_TYPE_TEST ? \"AT_CMD_TYPE_TEST\" : type == BluetoothHeadset.AT_CMD_TYPE_SET ? \"AT_CMD_TYPE_SET\" : type == BluetoothHeadset.AT_CMD_TYPE_BASIC ? \"AT_CMD_TYPE_BASIC\" : type == BluetoothHeadset.AT_CMD_TYPE_ACTION ? \"AT_CMD_TYPE_ACTION\" : \"Unknown\"; String log = \"BluetoothHeadset.ACTION_VENDOR_SPECIFIC_HEADSET_EVENT:\"; log += \" CMD=\" + cmd; log += \" type=\" + typeStr; log += \" args=\"; for (int i = 0; i &lt; args.length; i++) &#123; log += args[i]; if (i != args.length - 1) &#123; log += \",\"; &#125; &#125; Log.d(TAG, log); &#125; &#125; &#125;; private final BluetoothProfile.ServiceListener mProfileListener = new BluetoothProfile.ServiceListener() &#123; @Override public void onServiceConnected(int profile, BluetoothProfile proxy) &#123; String kind = null; if (profile == BluetoothProfile.HEADSET) &#123; mBluetoothHeadset = (BluetoothHeadset) proxy; kind = \"Headset\"; &#125; else if (profile == BluetoothProfile.A2DP) &#123; mBluetoothA2dp = (BluetoothA2dp) proxy; kind = \"A2DP\"; &#125; else if (profile == BluetoothProfile.HEALTH) &#123; mBluetoothHealth= (BluetoothHealth) proxy; kind = \"Health\"; &#125; List&lt;BluetoothDevice&gt; devices = proxy.getConnectedDevices(); String[] names = new String[devices.size()]; for (int i = 0; i &lt; names.length; i++) &#123; BluetoothDevice device = devices.get(i); names[i] = kind + \"\\n\" + device.getName() + \"\\n\" + device.getAddress(); &#125; mConnectedDevices.addAll(names); &#125; @Override public void onServiceDisconnected(int profile) &#123; List&lt;String&gt; names = new LinkedList&lt;String&gt;(); for (int i = 0; i &lt; mConnectedDevices.getCount(); i++) &#123; String name = mConnectedDevices.getItem(i); if (profile == BluetoothProfile.HEADSET &amp;&amp; name.startsWith(\"Headset\")) &#123; names.add(name); &#125; else if (profile == BluetoothProfile.A2DP &amp;&amp; name.startsWith(\"A2DP\")) &#123; names.add(name); &#125; else if (profile == BluetoothProfile.HEALTH &amp;&amp; name.startsWith(\"Health\")) &#123; names.add(name); &#125; &#125; for (String name : names) &#123; mConnectedDevices.remove(name); &#125; if (profile == BluetoothProfile.HEADSET) &#123; mBluetoothHeadset = null; &#125; else if (profile == BluetoothProfile.A2DP) &#123; mBluetoothA2dp = null; &#125; else if (profile == BluetoothProfile.HEALTH) &#123; mBluetoothHealth = null; &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.main); mConnectedDevices = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1); mList = (ListView) findViewById(R.id.connected); mList.setAdapter(mConnectedDevices); mList.setOnItemClickListener(this); &#125; @Override protected void onResume() &#123; super.onResume(); if (!mBluetoothAdapter.isEnabled()) &#123; Intent intent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE); startActivityForResult(intent, REQUEST_ENABLE_BT); &#125; IntentFilter filter = new IntentFilter(); filter.addAction(BluetoothA2dp.ACTION_CONNECTION_STATE_CHANGED); filter.addAction(BluetoothA2dp.ACTION_PLAYING_STATE_CHANGED); filter.addAction(BluetoothHeadset.ACTION_AUDIO_STATE_CHANGED); filter.addAction(BluetoothHeadset.ACTION_CONNECTION_STATE_CHANGED); filter.addAction(BluetoothHeadset.ACTION_VENDOR_SPECIFIC_HEADSET_EVENT); registerReceiver(mReceiver, filter); &#125; @Override protected void onPause() &#123; super.onPause(); unregisterReceiver(mReceiver); closeProfiles(); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.activity_main, menu); return true; &#125; @Override public boolean onMenuItemSelected(int featureId, MenuItem item) &#123; int itemId = item.getItemId(); if (itemId == R.id.menu_get_profiles) &#123; getProfiles(); &#125; else if (itemId == R.id.menu_close_profiles) &#123; closeProfiles(); &#125; return true; &#125; @Override public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) &#123; String text = ((TextView) view).getText().toString(); String kind= text.substring(0, text.indexOf(\"\\n\")); String addr = text.substring(text.lastIndexOf(\"\\n\") + 1); BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(addr); if (kind.equals(\"Headset\")) &#123; boolean isAudioConnected = mBluetoothHeadset.isAudioConnected(device); if (mVoicerecognizing.contains(device)) &#123; mVoicerecognizing.remove(device); boolean result = mBluetoothHeadset.stopVoiceRecognition(device); Toast.makeText(this, \"isAudioConnected:\" + isAudioConnected + \" stopVoiceRecognition:\" + result, Toast.LENGTH_LONG).show(); &#125; else &#123; boolean result = mBluetoothHeadset.startVoiceRecognition(device); if (result) &#123; mVoicerecognizing.add(device); &#125; Toast.makeText(this, \"isAudioConnected:\" + isAudioConnected + \" startVoiceRecognition:\" + result, Toast.LENGTH_LONG).show(); &#125; &#125; else if (kind.equals(\"A2DP\")) &#123; Toast.makeText(this, \"isA2dpPlaying:\" + mBluetoothA2dp.isA2dpPlaying(device), Toast.LENGTH_LONG).show(); &#125; else if (kind.equals(\"Health\")) &#123; Toast.makeText(this, \"Unsupported on this application\", Toast.LENGTH_LONG).show(); &#125; &#125; private void getProfiles() &#123; mBluetoothAdapter.getProfileProxy(this, mProfileListener, BluetoothProfile.HEADSET); mBluetoothAdapter.getProfileProxy(this, mProfileListener, BluetoothProfile.A2DP); mBluetoothAdapter.getProfileProxy(this, mProfileListener, BluetoothProfile.HEALTH); &#125; private void closeProfiles() &#123; if (mBluetoothHeadset != null) &#123; mBluetoothAdapter.closeProfileProxy(BluetoothProfile.HEADSET, mBluetoothHeadset); mBluetoothHeadset = null; &#125; if (mBluetoothA2dp != null) &#123; mBluetoothAdapter.closeProfileProxy(BluetoothProfile.A2DP, mBluetoothA2dp); mBluetoothA2dp = null; &#125; if (mBluetoothHealth != null) &#123; mBluetoothAdapter.closeProfileProxy(BluetoothProfile.HEALTH, mBluetoothHealth); mBluetoothHealth = null; &#125; mConnectedDevices.clear(); &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"지식","slug":"Android/지식","permalink":"http://jung-max.github.io/categories/Android/지식/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"Bluetooth","slug":"Bluetooth","permalink":"http://jung-max.github.io/tags/Bluetooth/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/categories/Linux/"},{"name":"http","slug":"Linux/http","permalink":"http://jung-max.github.io/categories/Linux/http/"},{"name":"buildroot","slug":"Linux/buildroot","permalink":"http://jung-max.github.io/categories/Linux/buildroot/"},{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/categories/Android/"},{"name":"지식","slug":"Android/지식","permalink":"http://jung-max.github.io/categories/Android/지식/"},{"name":"기타","slug":"기타","permalink":"http://jung-max.github.io/categories/기타/"},{"name":"라즈베리파이","slug":"기타/라즈베리파이","permalink":"http://jung-max.github.io/categories/기타/라즈베리파이/"},{"name":"기타","slug":"기타/기타","permalink":"http://jung-max.github.io/categories/기타/기타/"},{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/categories/Web/"},{"name":"SpringBoot","slug":"Web/SpringBoot","permalink":"http://jung-max.github.io/categories/Web/SpringBoot/"},{"name":"python","slug":"python","permalink":"http://jung-max.github.io/categories/python/"},{"name":"GUI","slug":"python/GUI","permalink":"http://jung-max.github.io/categories/python/GUI/"},{"name":"setting","slug":"python/setting","permalink":"http://jung-max.github.io/categories/python/setting/"},{"name":"통신","slug":"python/통신","permalink":"http://jung-max.github.io/categories/python/통신/"},{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/categories/openCV/"},{"name":"pageDewarp","slug":"openCV/pageDewarp","permalink":"http://jung-max.github.io/categories/openCV/pageDewarp/"},{"name":"지식","slug":"openCV/지식","permalink":"http://jung-max.github.io/categories/openCV/지식/"},{"name":"Platform SurfaceFlinger","slug":"Android/Platform-SurfaceFlinger","permalink":"http://jung-max.github.io/categories/Android/Platform-SurfaceFlinger/"},{"name":"App","slug":"Android/App","permalink":"http://jung-max.github.io/categories/Android/App/"},{"name":"Platform Kernel","slug":"Android/Platform-Kernel","permalink":"http://jung-max.github.io/categories/Android/Platform-Kernel/"},{"name":"Git","slug":"기타/Git","permalink":"http://jung-max.github.io/categories/기타/Git/"},{"name":"Platform U-Boot","slug":"Android/Platform-U-Boot","permalink":"http://jung-max.github.io/categories/Android/Platform-U-Boot/"},{"name":"Platform 개발 환경","slug":"Android/Platform-개발-환경","permalink":"http://jung-max.github.io/categories/Android/Platform-개발-환경/"},{"name":"Platform DTS","slug":"Android/Platform-DTS","permalink":"http://jung-max.github.io/categories/Android/Platform-DTS/"},{"name":"Javascript","slug":"Web/Javascript","permalink":"http://jung-max.github.io/categories/Web/Javascript/"},{"name":"MediaPlayer","slug":"Android/MediaPlayer","permalink":"http://jung-max.github.io/categories/Android/MediaPlayer/"},{"name":"Markdown","slug":"기타/Markdown","permalink":"http://jung-max.github.io/categories/기타/Markdown/"},{"name":"GitHub Pages","slug":"기타/GitHub-Pages","permalink":"http://jung-max.github.io/categories/기타/GitHub-Pages/"},{"name":"Platform SEAndroid","slug":"Android/Platform-SEAndroid","permalink":"http://jung-max.github.io/categories/Android/Platform-SEAndroid/"},{"name":"Platform JNI","slug":"Android/Platform-JNI","permalink":"http://jung-max.github.io/categories/Android/Platform-JNI/"},{"name":"HID","slug":"Android/HID","permalink":"http://jung-max.github.io/categories/Android/HID/"},{"name":"BLE","slug":"Android/BLE","permalink":"http://jung-max.github.io/categories/Android/BLE/"},{"name":"Platform boot","slug":"Android/Platform-boot","permalink":"http://jung-max.github.io/categories/Android/Platform-boot/"},{"name":"Platform Architecture","slug":"Android/Platform-Architecture","permalink":"http://jung-max.github.io/categories/Android/Platform-Architecture/"},{"name":"개발환경","slug":"Android/개발환경","permalink":"http://jung-max.github.io/categories/Android/개발환경/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://jung-max.github.io/tags/Linux/"},{"name":"buildroot","slug":"buildroot","permalink":"http://jung-max.github.io/tags/buildroot/"},{"name":"http","slug":"http","permalink":"http://jung-max.github.io/tags/http/"},{"name":"cURL","slug":"cURL","permalink":"http://jung-max.github.io/tags/cURL/"},{"name":"Android Platform","slug":"Android-Platform","permalink":"http://jung-max.github.io/tags/Android-Platform/"},{"name":"Android raspberry pi","slug":"Android-raspberry-pi","permalink":"http://jung-max.github.io/tags/Android-raspberry-pi/"},{"name":"raspberry pi","slug":"raspberry-pi","permalink":"http://jung-max.github.io/tags/raspberry-pi/"},{"name":"raspberryPi","slug":"raspberryPi","permalink":"http://jung-max.github.io/tags/raspberryPi/"},{"name":"setting","slug":"setting","permalink":"http://jung-max.github.io/tags/setting/"},{"name":"VScode","slug":"VScode","permalink":"http://jung-max.github.io/tags/VScode/"},{"name":"개발환경","slug":"개발환경","permalink":"http://jung-max.github.io/tags/개발환경/"},{"name":"Web","slug":"Web","permalink":"http://jung-max.github.io/tags/Web/"},{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://jung-max.github.io/tags/SpringBoot/"},{"name":"MariaDB","slug":"MariaDB","permalink":"http://jung-max.github.io/tags/MariaDB/"},{"name":"python","slug":"python","permalink":"http://jung-max.github.io/tags/python/"},{"name":"pyqt5","slug":"pyqt5","permalink":"http://jung-max.github.io/tags/pyqt5/"},{"name":"gui","slug":"gui","permalink":"http://jung-max.github.io/tags/gui/"},{"name":"serial","slug":"serial","permalink":"http://jung-max.github.io/tags/serial/"},{"name":"openCV","slug":"openCV","permalink":"http://jung-max.github.io/tags/openCV/"},{"name":"pageDewarp","slug":"pageDewarp","permalink":"http://jung-max.github.io/tags/pageDewarp/"},{"name":"Contours","slug":"Contours","permalink":"http://jung-max.github.io/tags/Contours/"},{"name":"SurfaceFlinger","slug":"SurfaceFlinger","permalink":"http://jung-max.github.io/tags/SurfaceFlinger/"},{"name":"Android","slug":"Android","permalink":"http://jung-max.github.io/tags/Android/"},{"name":"App","slug":"App","permalink":"http://jung-max.github.io/tags/App/"},{"name":"TabLayout","slug":"TabLayout","permalink":"http://jung-max.github.io/tags/TabLayout/"},{"name":"Thread","slug":"Thread","permalink":"http://jung-max.github.io/tags/Thread/"},{"name":"Toast","slug":"Toast","permalink":"http://jung-max.github.io/tags/Toast/"},{"name":"Kernel","slug":"Kernel","permalink":"http://jung-max.github.io/tags/Kernel/"},{"name":"Git","slug":"Git","permalink":"http://jung-max.github.io/tags/Git/"},{"name":"submodule","slug":"submodule","permalink":"http://jung-max.github.io/tags/submodule/"},{"name":"Service","slug":"Service","permalink":"http://jung-max.github.io/tags/Service/"},{"name":"Booting","slug":"Booting","permalink":"http://jung-max.github.io/tags/Booting/"},{"name":"U-Boot","slug":"U-Boot","permalink":"http://jung-max.github.io/tags/U-Boot/"},{"name":"DTS","slug":"DTS","permalink":"http://jung-max.github.io/tags/DTS/"},{"name":"Device Tree","slug":"Device-Tree","permalink":"http://jung-max.github.io/tags/Device-Tree/"},{"name":"opensource","slug":"opensource","permalink":"http://jung-max.github.io/tags/opensource/"},{"name":"licence","slug":"licence","permalink":"http://jung-max.github.io/tags/licence/"},{"name":"Battery","slug":"Battery","permalink":"http://jung-max.github.io/tags/Battery/"},{"name":"Java Script","slug":"Java-Script","permalink":"http://jung-max.github.io/tags/Java-Script/"},{"name":"MediaPlayer","slug":"MediaPlayer","permalink":"http://jung-max.github.io/tags/MediaPlayer/"},{"name":"Github Pages","slug":"Github-Pages","permalink":"http://jung-max.github.io/tags/Github-Pages/"},{"name":"Markdown","slug":"Markdown","permalink":"http://jung-max.github.io/tags/Markdown/"},{"name":"마크다운","slug":"마크다운","permalink":"http://jung-max.github.io/tags/마크다운/"},{"name":"마크다운 문법","slug":"마크다운-문법","permalink":"http://jung-max.github.io/tags/마크다운-문법/"},{"name":"Hexo","slug":"Hexo","permalink":"http://jung-max.github.io/tags/Hexo/"},{"name":"SEAndroid","slug":"SEAndroid","permalink":"http://jung-max.github.io/tags/SEAndroid/"},{"name":"JNI","slug":"JNI","permalink":"http://jung-max.github.io/tags/JNI/"},{"name":"Bluetooth","slug":"Bluetooth","permalink":"http://jung-max.github.io/tags/Bluetooth/"},{"name":"HID","slug":"HID","permalink":"http://jung-max.github.io/tags/HID/"},{"name":"BLE","slug":"BLE","permalink":"http://jung-max.github.io/tags/BLE/"},{"name":"GPIO","slug":"GPIO","permalink":"http://jung-max.github.io/tags/GPIO/"},{"name":"Architecture","slug":"Architecture","permalink":"http://jung-max.github.io/tags/Architecture/"},{"name":"NDK","slug":"NDK","permalink":"http://jung-max.github.io/tags/NDK/"},{"name":"부분빌드","slug":"부분빌드","permalink":"http://jung-max.github.io/tags/부분빌드/"},{"name":"boot","slug":"boot","permalink":"http://jung-max.github.io/tags/boot/"}]}