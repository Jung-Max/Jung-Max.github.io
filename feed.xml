<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Max&#39;s Blog</title>
    <link>http://jung-max.github.io/</link>
    
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>개발시 정리했던 사항을 끄적이기 위한 블로그</description>
    <pubDate>Wed, 09 Feb 2022 08:47:55 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>libcurl example</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20example/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20example/</guid>
      <pubDate>Wed, 09 Feb 2022 07:31:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;libcurl-example&quot;&gt;&lt;a href=&quot;#libcurl-example&quot; class=&quot;headerlink&quot; title=&quot;libcurl example&quot;&gt;&lt;/a&gt;libcurl example&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://c
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="libcurl-example"><a href="#libcurl-example" class="headerlink" title="libcurl example"></a>libcurl example</h1><p><a href="https://curl.se/libcurl/c/example.html" rel="external nofollow noopener noreferrer" target="_blank">https://curl.se/libcurl/c/example.html</a>도 참고하세요.</p><p>libcurl용 기본 API는 C로 되어 있으므로 이 장은 C로 작성된 예제에 초점을 맞춥니다. 그러나 libcurl용 언어 바인딩이 얇기 때문에 일반적으로 거의 동일한 기능을 노출하므로 여전히 흥미롭고 교육적일 수 있습니다. 다른 언어도 마찬가지입니다.</p><h2 id="간단한-HTTP-페이지-가져오기"><a href="#간단한-HTTP-페이지-가져오기" class="headerlink" title="간단한 HTTP 페이지 가져오기"></a>간단한 HTTP 페이지 가져오기</h2><p>이 예제는 주어진 URL에서 HTML을 가져와서 stdout으로 보냅니다. 아마도 가장 간단한 libcurl 프로그램을 작성할 수 있습니다.</p><p>URL을 교체하면 물론 지원되는 다른 프로토콜을 통해서도 콘텐츠를 가져올 수 있습니다.</p><p>출력을 stdout으로 보내는 것은 기본 동작이며 일반적으로 실제로 원하는 것이 아닙니다. 대부분의 애플리케이션은 도착하는 데이터를 수신하기 위해 <a href="https://jung-max.github.io/2022/02/08/Linux-libcurl%20callback">쓰기 콜백</a>을 대신 설치합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  <span class="keyword">if</span>(curl) &#123;</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, <span class="string">"http://example.com/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Perform the request, res will get the return code */</span></span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line">    <span class="comment">/* Check for errors */</span></span><br><span class="line">    <span class="keyword">if</span>(res != CURLE_OK)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"curl_easy_perform() failed: %s\n"</span>,</span><br><span class="line">              curl_easy_strerror(res));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* always cleanup */</span></span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="메모리에-페이지-가져오기"><a href="#메모리에-페이지-가져오기" class="headerlink" title="메모리에 페이지 가져오기"></a>메모리에 페이지 가져오기</h2><p>이 예는 수신된 데이터를 stdout(종종 원하는 것이 아님)으로 보내는 대신 수신 데이터가 증가함에 따라 확장되는 메모리 버퍼에 수신 데이터를 저장하는 전자의 변형입니다.</p><p><a href="https://jung-max.github.io/2022/02/08/Linux-libcurl%20callback">쓰기 콜백</a>을 사용하여 데이터를 수신하여 이를 수행합니다.</p><p>이 예에서는 설정된 URL 체계와 함께 고정 URL 문자열을 사용하지만 물론 지원되는 다른 프로토콜을 사용하도록 이를 변경한 다음 대신 해당 프로토콜에서 리소스를 가져올 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryStruct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *memory;</span><br><span class="line">  <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">WriteMemoryCallback(<span class="keyword">void</span> *contents, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nmemb, <span class="keyword">void</span> *userp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> realsize = <span class="built_in">size</span> * nmemb;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">MemoryStruct</span> *<span class="title">mem</span> = (<span class="title">struct</span> <span class="title">MemoryStruct</span> *)<span class="title">userp</span>;</span></span><br><span class="line"></span><br><span class="line">  mem-&gt;memory = <span class="built_in">realloc</span>(mem-&gt;memory, mem-&gt;<span class="built_in">size</span> + realsize + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(mem-&gt;memory == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* out of memory */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"not enough memory (realloc returned NULL)\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;(mem-&gt;memory[mem-&gt;<span class="built_in">size</span>]), contents, realsize);</span><br><span class="line">  mem-&gt;<span class="built_in">size</span> += realsize;</span><br><span class="line">  mem-&gt;memory[mem-&gt;<span class="built_in">size</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> realsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURL *curl_handle;</span><br><span class="line">  CURLcode res;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">MemoryStruct</span> <span class="title">chunk</span>;</span></span><br><span class="line"></span><br><span class="line">  chunk.memory = <span class="built_in">malloc</span>(<span class="number">1</span>);  <span class="comment">/* will be grown as needed by the realloc above */</span></span><br><span class="line">  chunk.<span class="built_in">size</span> = <span class="number">0</span>;    <span class="comment">/* no data at this point */</span></span><br><span class="line"></span><br><span class="line">  curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* init the curl session */</span></span><br><span class="line">  curl_handle = curl_easy_init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* specify URL to get */</span></span><br><span class="line">  curl_easy_setopt(curl_handle, CURLOPT_URL, <span class="string">"https://www.example.com/"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* send all data to this function  */</span></span><br><span class="line">  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* we pass our 'chunk' struct to the callback function */</span></span><br><span class="line">  curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (<span class="keyword">void</span> *)&amp;chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* some servers do not like requests that are made without a user-agent</span></span><br><span class="line"><span class="comment">     field, so we provide one */</span></span><br><span class="line">  curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, <span class="string">"libcurl-agent/1.0"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get it! */</span></span><br><span class="line">  res = curl_easy_perform(curl_handle);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check for errors */</span></span><br><span class="line">  <span class="keyword">if</span>(res != CURLE_OK) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"curl_easy_perform() failed: %s\n"</span>,</span><br><span class="line">            curl_easy_strerror(res));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now, our chunk.memory points to a memory block that is chunk.size</span></span><br><span class="line"><span class="comment">     * bytes big and contains the remote file.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Do something nice with it!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu bytes retrieved\n"</span>, (<span class="keyword">long</span>)chunk.<span class="built_in">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* cleanup curl stuff */</span></span><br><span class="line">  curl_easy_cleanup(curl_handle);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(chunk.memory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* we are done with libcurl, so clean it up */</span></span><br><span class="line">  curl_global_cleanup();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP를-통해-로그인-양식-제출"><a href="#HTTP를-통해-로그인-양식-제출" class="headerlink" title="HTTP를 통해 로그인 양식 제출"></a>HTTP를 통해 로그인 양식 제출</h2><p>HTTP를 통한 로그인 제출은 일반적으로 POST에서 제출할 데이터와 전송할 대상 URL을 정확히 파악하는 문제입니다.</p><p>로그인한 후 적절한 쿠키를 사용하면 대상 URL을 가져올 수 있습니다. 많은 로그인 시스템이 HTTP 리디렉션과 함께 작동하므로 libcurl이 이러한 리디렉션이 도착하면 이를 따르도록 요청합니다.</p><p>일부 로그인 양식은 이를 더 복잡하게 만들고 로그인 양식 등을 보여주는 페이지에서 쿠키를 얻어야 하므로 필요한 경우 이 코드를 약간 확장할 수 있습니다.</p><p>존재하지 않는 쿠키 파일을 전달함으로써 이 예제는 쿠키 파서를 활성화하여 로그인 응답의 응답이 도착할 때 들어오는 쿠키가 저장되고 리소스에 대한 후속 요청이 쿠키를 사용하고 우리가 실제로 올바르게 로그인했습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *postthis = <span class="string">"user=daniel&amp;password=monkey123"</span>;</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  <span class="keyword">if</span>(curl) &#123;</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, <span class="string">"https://example.com/login.cgi"</span>);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postthis);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, <span class="number">1L</span>); <span class="comment">/* redirects! */</span></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_COOKIEFILE, <span class="string">""</span>); <span class="comment">/* no file */</span></span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line">    <span class="comment">/* Check for errors */</span></span><br><span class="line">    <span class="keyword">if</span>(res != CURLE_OK)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"curl_easy_perform() failed: %s\n"</span>,</span><br><span class="line">              curl_easy_strerror(res));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * After the login POST, we have received the new cookies. Switch</span></span><br><span class="line"><span class="comment">       * over to a GET and ask for the login-protected URL.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      curl_easy_setopt(curl, CURLOPT_URL, <span class="string">"https://example.com/file"</span>);</span><br><span class="line">      curl_easy_setopt(curl, CURLOPT_HTTPGET, <span class="number">1L</span>); <span class="comment">/* no more POST */</span></span><br><span class="line">      res = curl_easy_perform(curl);</span><br><span class="line">      <span class="comment">/* Check for errors */</span></span><br><span class="line">      <span class="keyword">if</span>(res != CURLE_OK)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"second curl_easy_perform() failed: %s\n"</span>,</span><br><span class="line">                curl_easy_strerror(res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* always cleanup */</span></span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FTP-디렉토리-목록-가져오기"><a href="#FTP-디렉토리-목록-가져오기" class="headerlink" title="FTP 디렉토리 목록 가져오기"></a>FTP 디렉토리 목록 가져오기</h2><p>이 예제는 주어진 URL에서 FTP 디렉토리 출력을 가져와서 stdout으로 보냅니다. URL의 후행 슬래시는 libcurl이 이를 디렉토리로 처리하도록 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line"></span><br><span class="line">  curl_global_init(CURL_GLOBAL_DEFAULT);</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  <span class="keyword">if</span>(curl) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Make the URL end with a trailing slash!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, <span class="string">"ftp://ftp.example.com/"</span>);</span><br><span class="line"></span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* always cleanup */</span></span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(CURLE_OK != res) &#123;</span><br><span class="line">      <span class="comment">/* we failed */</span></span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"curl told us %d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  curl_global_cleanup();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Non-blocking-HTTP-form-post"><a href="#Non-blocking-HTTP-form-post" class="headerlink" title="Non-blocking HTTP form-post"></a>Non-blocking HTTP form-post</h2><p>이 예제는 다중 인터페이스를 사용하여 다중 파트 form-post를 만듭니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line"></span><br><span class="line">  CURLM *multi_handle;</span><br><span class="line">  <span class="keyword">int</span> still_running = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  curl_mime *form = <span class="literal">NULL</span>;</span><br><span class="line">  curl_mimepart *field = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">curl_slist</span> *<span class="title">headerlist</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> buf[] = <span class="string">"Expect:"</span>;</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  multi_handle = curl_multi_init();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(curl &amp;&amp; multi_handle) &#123;</span><br><span class="line">    <span class="comment">/* Create the form */</span></span><br><span class="line">    form = curl_mime_init(curl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill in the file upload field */</span></span><br><span class="line">    field = curl_mime_addpart(form);</span><br><span class="line">    curl_mime_name(field, <span class="string">"sendfile"</span>);</span><br><span class="line">    curl_mime_filedata(field, <span class="string">"multi-post.c"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill in the filename field */</span></span><br><span class="line">    field = curl_mime_addpart(form);</span><br><span class="line">    curl_mime_name(field, <span class="string">"filename"</span>);</span><br><span class="line">    curl_mime_data(field, <span class="string">"multi-post.c"</span>, CURL_ZERO_TERMINATED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill in the submit field too, even if this is rarely needed */</span></span><br><span class="line">    field = curl_mime_addpart(form);</span><br><span class="line">    curl_mime_name(field, <span class="string">"submit"</span>);</span><br><span class="line">    curl_mime_data(field, <span class="string">"send"</span>, CURL_ZERO_TERMINATED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize custom header list (stating that Expect: 100-continue is not</span></span><br><span class="line"><span class="comment">       wanted */</span></span><br><span class="line">    headerlist = curl_slist_append(headerlist, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* what URL that receives this POST */</span></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, <span class="string">"https://www.example.com/upload.cgi"</span>);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_VERBOSE, <span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerlist);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_MIMEPOST, form);</span><br><span class="line"></span><br><span class="line">    curl_multi_add_handle(multi_handle, curl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      CURLMcode mc = curl_multi_perform(multi_handle, &amp;still_running);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(still_running)</span><br><span class="line">        <span class="comment">/* wait for activity, timeout or "nothing" */</span></span><br><span class="line">        mc = curl_multi_poll(multi_handle, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1000</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(mc)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(still_running);</span><br><span class="line"></span><br><span class="line">    curl_multi_cleanup(multi_handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* always cleanup */</span></span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* then cleanup the form */</span></span><br><span class="line">    curl_mime_free(form);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free slist */</span></span><br><span class="line">    curl_slist_free_all(headerlist);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20example/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl URL API</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20URL%20API/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20URL%20API/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;URL-API&quot;&gt;&lt;a href=&quot;#URL-API&quot; class=&quot;headerlink&quot; title=&quot;URL API&quot;&gt;&lt;/a&gt;URL API&lt;/h1&gt;&lt;p&gt;libcurl은 URL을 구문 분석, 업데이트 및 생성하기 위한 API를 제공합니다. 이를
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="URL-API"><a href="#URL-API" class="headerlink" title="URL API"></a>URL API</h1><p>libcurl은 URL을 구문 분석, 업데이트 및 생성하기 위한 API를 제공합니다. 이를 사용하여 응용 프로그램은 자체 목적을 위해 libcurl의 URL 파서를 사용할 수 있습니다. 동일한 파서를 사용함으로써 다른 해석으로 인한 보안 문제를 피할 수 있습니다.</p><h2 id="Include-files"><a href="#Include-files" class="headerlink" title="Include files"></a>Include files</h2><p>URL API를 사용하려는 경우 코드에 <code>&lt;curl/curl.h&gt;</code>를 포함합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">CURLU *h = curl_url();</span><br><span class="line">rc = curl_url_set(h, CURLUPART_URL, <span class="string">"ftp://example.com/no/where"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="Create-cleanup-duplicate"><a href="#Create-cleanup-duplicate" class="headerlink" title="Create, cleanup, duplicate"></a>Create, cleanup, duplicate</h2><p>이 API를 사용하는 첫 번째 단계는 URL 정보와 리소스를 보유하는 <code>CURLU *</code> 핸들을 만드는 것입니다. 핸들은 단일 URL 및 모든 다른 구성 요소에 대한 정보를 보유하는 연결된 데이터 개체에 대한 참조입니다.</p><p>API를 사용하면 각 URL 구성 요소를 개별적으로 또는 전체 URL로 설정하거나 가져올 수 있습니다.</p><p>다음과 같이 URL 핸들을 만듭니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURLU *h = curl_url();</span><br></pre></td></tr></table></figure><p>완료되면 정리하십시오.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_url_cleanup(h);</span><br></pre></td></tr></table></figure><p>핸들 사본이 필요하면 복사하십시오.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURLU *nh = curl_url_dup(h);</span><br></pre></td></tr></table></figure><h2 id="Parse-a-URL"><a href="#Parse-a-URL" class="headerlink" title="Parse a URL"></a>Parse a URL</h2><p>핸들에서 <code>CURLUPART_URL</code> 부분을 설정하여 전체 URL을 구문 분석합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CURLU *h = curl_url();</span><br><span class="line">rc = curl_url_set(h, CURLUPART_URL,</span><br><span class="line">                  <span class="string">"https://example.com:449/foo/bar?name=moo"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>성공하면 rc에 CURLUE_OK가 포함되고 다른 URL 구성 요소가 핸들에 유지됩니다. libcurl에 관한 한 URL이 유효했음을 의미합니다.</p><p>함수 호출의 네 번째 인수는 특정 기능을 변경하기 위한 비트마스크입니다. 파서의 동작을 변경하기 위해 비트를 하나만 더 설정할 수 있습니다.</p><h3 id="CURLU-NON-SUPPORT-SCHEME"><a href="#CURLU-NON-SUPPORT-SCHEME" class="headerlink" title="CURLU_NON_SUPPORT_SCHEME"></a>CURLU_NON_SUPPORT_SCHEME</h3><p><code>curl_url_set()</code>이 지원되지 않는 체계를 허용하도록 합니다. 설정하지 않으면 libcurl이 알고 있고 지원하는 내장 프로토콜에 대한 유일한 구성표가 허용됩니다.</p><h3 id="CURLU-URLENCODE"><a href="#CURLU-URLENCODE" class="headerlink" title="CURLU_URLENCODE"></a>CURLU_URLENCODE</h3><p>공백 또는 “제어 문자”와 같은 이점이 있는 바이트가 있는 경우 함수 URL이 경로 부분을 인코딩하도록 합니다.</p><h3 id="CURLU-DEFAULT-SCHEME"><a href="#CURLU-DEFAULT-SCHEME" class="headerlink" title="CURLU_DEFAULT_SCHEME"></a>CURLU_DEFAULT_SCHEME</h3><p>전달된 문자열이 체계를 사용하지 않는 경우 기본 체계를 의도한 것으로 가정합니다. 기본 체계는 HTTPS입니다. 이것이 설정되지 않으면 스킴 부분이 없는 URL은 유효한 것으로 승인되지 않습니다. 둘 다 설정된 경우 <code>CURLU_GUESS_SCHEME</code> 옵션을 재정의합니다.</p><h3 id="CURLU-GUESS-SCHEME"><a href="#CURLU-GUESS-SCHEME" class="headerlink" title="CURLU_GUESS_SCHEME"></a>CURLU_GUESS_SCHEME</h3><p>libcurl이 URL이 스키마 없이 설정되도록 하고 대신 호스트 이름을 기반으로 의도한 스키마를 “추측”합니다. 가장 바깥쪽 하위 도메인 이름이 DICT, FTP, IMAP, LDAP, POP3 또는 SMTP와 일치하면 해당 체계가 사용되며, 그렇지 않으면 HTTP를 선택합니다. 둘 다 설정된 경우 우선적으로 적용되는 <code>CURLU_DEFAULT_SCHEME</code> 옵션과 충돌합니다.</p><h3 id="CURLU-NO-AUTHORITY"><a href="#CURLU-NO-AUTHORITY" class="headerlink" title="CURLU_NO_AUTHORITY"></a>CURLU_NO_AUTHORITY</h3><p>권한 검사를 건너뜁니다. RFC는 개별 체계가 호스트 부분(일반적으로 권한의 유일한 필수 부분)을 생략하도록 허용하지만 libcurl은 이것이 사용자 지정 체계에 허용되는지 여부를 알 수 없습니다. 플래그를 지정하면 파일 구성표가 처리되는 방식과 유사한 빈 권한 섹션이 허용됩니다. <code>CURLU_NON_SUPPORT_SCHEME</code>와 조합해서만 사용할 수 있습니다.</p><h3 id="CURLU-PATH-AS-IS"><a href="#CURLU-PATH-AS-IS" class="headerlink" title="CURLU_PATH_AS_IS"></a>CURLU_PATH_AS_IS</h3><p>libcurl이 경로의 정규화를 건너뛰게 합니다. 이것은 curl이 점-슬래시 및 점-점 등의 시퀀스를 제거하는 절차입니다. 전송에 사용되는 동일한 옵션을 <code>CURLOPT_PATH_AS_IS</code>라고 합니다.</p><h3 id="CURLU-ALLOW-SPACE"><a href="#CURLU-ALLOW-SPACE" class="headerlink" title="CURLU_ALLOW_SPACE"></a>CURLU_ALLOW_SPACE</h3><p>URL 파서가 가능한 경우 공간(ASCII 32)을 허용하도록 합니다. URL 구문은 일반적으로 공백을 허용하지 않지만 <code>%20</code> 또는 <code>+</code>로 인코딩해야 합니다. 공백이 허용되면 스키마에서 여전히 허용되지 않습니다. URL에서 공간이 사용되고 허용되면 <code>CURLU_URLENCODE</code>도 설정되지 않는 한 그대로 저장됩니다. 그러면 libcurl이 저장하기 전에 공간을 URL로 인코딩합니다. 이는 전체 URL 또는 개별 부분을 추출하기 위해 <code>curl_url_get()</code>을 사용할 때 URL이 구성되는 방식에 영향을 줍니다.</p><h2 id="상대-URL로-리디렉션"><a href="#상대-URL로-리디렉션" class="headerlink" title="상대 URL로 리디렉션"></a>상대 URL로 리디렉션</h2><p>핸들이 이미 URL을 구문 분석한 경우 두 번째 상대 URL을 설정하면 이에 맞게 “리디렉션”됩니다.</p><p>예를 들어, 먼저 원래 URL을 설정한 다음 “리디렉션”할 URL을 다음으로 설정합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CURLU *h = curl_url();</span><br><span class="line">rc = curl_url_set(h, CURLUPART_URL,</span><br><span class="line">                  <span class="string">"https://example.com/foo/bar?name=moo"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">rc = curl_url_set(h, CURLUPART_URL, <span class="string">"../test?another"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="Get-a-URL"><a href="#Get-a-URL" class="headerlink" title="Get a URL"></a>Get a URL</h2><p><code>CURLU *</code> 핸들은 URL 또는 URL의 일부를 나타내며 언제든지 해당 URL을 쉽게 추출할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *url;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_URL, &amp;url, CURLU_NO_DEFAULT_PORT);</span><br><span class="line">curl_free(url);</span><br></pre></td></tr></table></figure><p>핸들에 전체 URL을 추가하기에 충분한 정보가 없으면 오류를 반환합니다.<br>반환된 문자열은 작업을 마친 후 <code>curl_free()</code>로 해제해야 합니다.<br>함수 호출의 네 번째 인수에서 0은 특정 기능을 변경하기 위한 플래그 비트마스크입니다.</p><h3 id="CURLU-DEFAULT-PORT"><a href="#CURLU-DEFAULT-PORT" class="headerlink" title="CURLU_DEFAULT_PORT"></a>CURLU_DEFAULT_PORT</h3><p>URL 핸들에 저장된 포트 번호가 없는 경우 이 옵션은 <code>curl_url_get()</code>이 사용된 체계에 대한 기본 포트를 반환하도록 합니다.</p><h3 id="CURLU-DEFAULT-SCHEME-1"><a href="#CURLU-DEFAULT-SCHEME-1" class="headerlink" title="CURLU_DEFAULT_SCHEME"></a>CURLU_DEFAULT_SCHEME</h3><p>핸들에 저장된 체계가 없는 경우 이 옵션은 <code>curl_url_get()</code>이 오류 대신 기본 체계를 반환하도록 합니다.</p><h3 id="CURLU-NO-DEFAULT-PORT"><a href="#CURLU-NO-DEFAULT-PORT" class="headerlink" title="CURLU_NO_DEFAULT_PORT"></a>CURLU_NO_DEFAULT_PORT</h3><p>포트 번호가 스키마에 사용된 기본 포트와 일치하는 경우 생성된 URL에서 포트 번호를 사용하지 않도록 <code>curl_url_get()</code>에 지시합니다. 예를 들어 포트 번호 443이 설정되고 스키마가 https인 경우 추출된 URL에는 포트 번호가 포함되지 않습니다.</p><h3 id="CURLU-URLENCODE-1"><a href="#CURLU-URLENCODE-1" class="headerlink" title="CURLU_URLENCODE"></a>CURLU_URLENCODE</h3><p>설정하면 전체 URL이 검색될 때 <code>curl_url_get()</code> URL이 호스트 이름 부분을 인코딩하도록 합니다. 설정되지 않은 경우(기본값) libcurl은 IDN 이름이 있는 그대로 표시되도록 지원하기 위해 호스트 이름이 “raw”인 URL을 반환합니다. IDN 호스트 이름은 일반적으로 비ASCII 바이트를 사용하며 그렇지 않으면 백분율로 인코딩됩니다.</p><p>URL 인코딩을 요청하지 않는 경우에도 <code>%</code>(바이트 37)는 호스트 이름이 유효한지 확인하기 위해 호스트 이름에서 URL로 인코딩됩니다.</p><h2 id="개별-URL-부분-가져오기"><a href="#개별-URL-부분-가져오기" class="headerlink" title="개별 URL 부분 가져오기"></a>개별 URL 부분 가져오기</h2><p>URL이 구문 분석되었거나 개별 부분이 <code>CURLU</code> 핸들에 설정된 경우 언제든지 핸들에서 해당 부분을 다시 추출할 수 있습니다.</p><p><code>curl_url_get()</code>에 대한 두 번째 인수는 추출할 부분을 지정합니다. 그것들은 모두 null로 끝나는 <code>char *</code> 데이터로 추출되므로 이러한 변수에 대한 포인터를 전달합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *host;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_HOST, &amp;host, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *scheme;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_SCHEME, &amp;scheme, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *user;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_USER, &amp;user, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *password;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_PASSWORD, &amp;password, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *port;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_PORT, &amp;port, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *path;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_PATH, &amp;path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *query;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_QUERY, &amp;query, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *fragment;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_FRAGMENT, &amp;fragment, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>작업이 끝나면 반환된 문자열을 curl_free로 해제하는 것을 잊지 마십시오!</p><p>추출된 부분은 사용자가 <code>CURLU_URLDECODE</code> 플래그로 요청하지 않는 한 URL 디코딩되지 않습니다.</p><h2 id="개별-URL-부분-설정"><a href="#개별-URL-부분-설정" class="headerlink" title="개별 URL 부분 설정"></a>개별 URL 부분 설정</h2><p>API를 사용하면 전체 URL을 구문 분석하거나 구문 분석하는 대신 <code>CURLU</code> 핸들에 보관된 URL의 개별 부분을 애플리케이션에서 설정할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rc = curl_url_set(urlp, CURLUPART_HOST, <span class="string">"www.example.com"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_SCHEME, <span class="string">"https"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_USER, <span class="string">"john"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_PASSWORD, <span class="string">"doe"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_PORT, <span class="string">"443"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_PATH, <span class="string">"/index.html"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_QUERY, <span class="string">"name=john"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_FRAGMENT, <span class="string">"anchor"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>API는 항상 세 번째 인수에서 null로 끝나는 <code>char *</code> 문자열을 예상하거나 필드를 지우려면 NULL을 예상합니다. 포트 번호도 이런 식으로 문자열로 제공됩니다.</p><p>사용자가 네 번째 인수에서 <code>CURLU_URLENCODE</code> 플래그를 사용하여 요청하지 않는 한 설정 부분은 URL로 인코딩되지 않습니다.</p><h2 id="쿼리에-추가"><a href="#쿼리에-추가" class="headerlink" title="쿼리에 추가"></a>쿼리에 추가</h2><p>응용 프로그램은 <code>CURLU_APPENDQUERY</code> 플래그를 사용하여 기존 쿼리 부분의 오른쪽 끝에 문자열을 추가할 수 있습니다.</p><p>URL <code>https://example.com/?shoes=2</code>를 보유하는 핸들을 고려하십시오. 그러면 애플리케이션은 다음과 같이 쿼리 부분에 문자열 <code>hat=1</code>을 추가할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rc = curl_url_set(urlp, CURLUPART_QUERY, <span class="string">"hat=1"</span>, CURLU_APPENDQUERY);</span><br></pre></td></tr></table></figure><p>앰퍼샌드(&amp;) 구분 기호가 없는 경우에도 이를 삽입하므로 핸들의 전체 URL은 <code>https://example.com/?shoes=2&amp;hat=1</code>과 같습니다.</p><p>추가된 문자열은 물론 추가 시 인코딩된 URL을 얻을 수도 있으며, 요청하는 경우 인코딩은 ‘=’ 문자를 건너뜁니다. 예를 들어, 우리가 이미 가지고 있는 것에 <code>candy=M&amp;M</code>을 추가하고 데이터의 앰퍼샌드를 처리하기 위해 그것을 URL 인코딩합니다:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rc = curl_url_set(urlp, CURLUPART_QUERY, <span class="string">"candy=M&amp;M"</span>,</span><br><span class="line">                  CURLU_APPENDQUERY | CURLU_URLENCODE);</span><br></pre></td></tr></table></figure><p>이제 URL은 <code>https://example.com/?shoes=2&amp;hat=1&amp;candy=M%26M</code>과 같습니다.</p><h2 id="CURLOPT-CURLU"><a href="#CURLOPT-CURLU" class="headerlink" title="CURLOPT_CURLU"></a>CURLOPT_CURLU</h2><p>응용 프로그램의 편의를 위해 <code>CURLOPT_URL</code>의 대안으로 이미 구문 분석된 URL을 libcurl에 전달할 수 있습니다.</p><p><code>CURLOPT_CURLU</code> 옵션을 사용하여 URL 문자열 대신 <code>CURLU</code> 핸들을 전달합니다.<br>예시:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CURLU *h = curl_url();</span><br><span class="line">rc = curl_url_set(h, CURLUPART_URL, <span class="string">"https://example.com/"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">CURL *easy = curl_easy_init();</span><br><span class="line">curl_easy_setopt(easy, CURLOPT_CURLU, h);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20URL%20API/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl 핸들 간에 데이터 공유</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%ED%95%B8%EB%93%A4%20%EA%B0%84%EC%97%90%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EA%B3%B5%EC%9C%A0/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%ED%95%B8%EB%93%A4%20%EA%B0%84%EC%97%90%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EA%B3%B5%EC%9C%A0/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;핸들-간에-데이터-공유&quot;&gt;&lt;a href=&quot;#핸들-간에-데이터-공유&quot; class=&quot;headerlink&quot; title=&quot;핸들 간에 데이터 공유&quot;&gt;&lt;/a&gt;핸들 간에 데이터 공유&lt;/h1&gt;&lt;p&gt;때때로 응용 프로그램은 전송 간에 데이터를 공유해야 합
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="핸들-간에-데이터-공유"><a href="#핸들-간에-데이터-공유" class="headerlink" title="핸들 간에 데이터 공유"></a>핸들 간에 데이터 공유</h1><p>때때로 응용 프로그램은 전송 간에 데이터를 공유해야 합니다. 동일한 다중 핸들에 추가된 모든 쉬운 핸들은 동일한 다중 핸들의 핸들 간에 많은 공유가 자동으로 수행되지만 때로는 정확히 원하는 것이 아닙니다.</p><h2 id="멀티-핸들"><a href="#멀티-핸들" class="headerlink" title="멀티 핸들"></a>멀티 핸들</h2><p>동일한 다중 핸들에 추가된 모든 간편 핸들은 <a href="https://jung-max.github.io/2022/02/08/Linux-libcurl%20연결%20재사용">연결 캐시</a>와 <a href="https://jung-max.github.io/2022/02/09/Linux-libcurl%20이름%20확인">DNS 캐시</a>를 자동으로 공유합니다.</p><h2 id="쉬운-핸들-간-공유"><a href="#쉬운-핸들-간-공유" class="headerlink" title="쉬운 핸들 간 공유"></a>쉬운 핸들 간 공유</h2><p>libcurl에는 일반 “공유 인터페이스”가 있으며, 여기서 응용 프로그램은 “공유 개체”를 생성한 다음 여러 손쉬운 핸들에서 공유할 수 있는 데이터를 보유합니다. 그런 다음 데이터를 공유하는 핸들 내에 보관하는 대신 공유 개체에서 데이터를 저장하고 읽습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURLSH *share = curl_share_init();</span><br></pre></td></tr></table></figure><p>공유 객체는 쿠키, 연결 캐시, dns 캐시 및 SSL 세션 ID 캐시의 전체 또는 일부를 공유하도록 설정할 수 있습니다.</p><p>예를 들어 쿠키 및 DNS 캐시를 보유하도록 공유 설정:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_COOKIE);</span><br><span class="line">curl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS);</span><br></pre></td></tr></table></figure><p>그런 다음 이 공유 개체를 사용하도록 해당 전송을 설정합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(curl, CURLOPT_SHARE, share);</span><br></pre></td></tr></table></figure><p>따라서 이 컬 핸들로 수행된 전송은 공유 핸들의 쿠키 및 DNS 정보를 사용하고 저장합니다. 동일한 공유 개체를 공유하기 위해 여러 개의 쉬운 핸들을 설정할 수 있습니다.</p><h2 id="무엇을-공유할-것인가"><a href="#무엇을-공유할-것인가" class="headerlink" title="무엇을 공유할 것인가"></a>무엇을 공유할 것인가</h2><p><code>CURL_LOCK_DATA_COOKIE</code> - 쿠키 항아리를 공유하려면 이 비트를 설정합니다. 각각의 쉬운 핸들은 쿠키 사용을 시작하기 위해 쿠키 “엔진”을 제대로 시작해야 합니다.</p><p><code>CURL_LOCK_DATA_DNS</code> - DNS 캐시는 libcurl이 이후 조회를 더 빠르게 하기 위해 확인된 호스트 이름에 대한 주소를 잠시 저장하는 곳입니다.</p><p><code>CURL_LOCK_DATA_SSL_SESSION</code> - SSL 세션 ID 캐시는 libcurl이 이전 연결을 더 빨리 재개할 수 있도록 SSL 연결에 대한 재개 정보를 저장하는 곳입니다.</p><p><code>CURL_LOCK_DATA_CONNECT</code> - 설정되면 이 핸들은 공유 연결 캐시를 사용하므로 재사용할 기존 연결을 찾을 가능성이 더 높아져 동일한 호스트에 직렬 방식으로 여러 번 전송할 때 성능이 더 빨라질 수 있습니다.</p><h2 id="잠금"><a href="#잠금" class="headerlink" title="잠금"></a>잠금</h2><p>다중 스레드 환경에서 전송을 통해 공유 개체를 공유하려는 경우. 아마도 많은 코어가 있는 CPU가 있고 각 코어가 자체 스레드를 실행하고 데이터를 전송하기를 원하지만 여전히 다른 전송에서 데이터를 공유하기를 원할 수 있습니다. 그런 다음 뮤텍스 콜백을 설정해야 합니다.</p><p>스레딩을 사용하지 않고 한 번에 하나씩 직렬 방식으로 공유 개체에 액세스한다는 것을 알고 있으면 잠금을 설정할 필요가 없습니다. 그러나 한 번에 공유 개체에 액세스하는 전송이 두 개 이상 있는 경우 데이터 파괴 및 충돌을 방지하기 위해 뮤텍스 콜백 설정을 가져와야 합니다.</p><p>libcurl 자체는 사물을 잠그는 방법이나 사용 중인 스레딩 모델을 알지 못하기 때문에 한 번에 하나의 액세스만 허용하는 뮤텍스 잠금을 수행해야 합니다. pthreads 사용 애플리케이션에 대한 잠금 콜백은 다음과 유사할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lock_cb</span><span class="params">(CURL *handle, curl_lock_data data,</span></span></span><br><span class="line"><span class="function"><span class="params">                    curl_lock_access access, <span class="keyword">void</span> *userptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;lock[data]); <span class="comment">/* uses a global lock array */</span></span><br><span class="line">&#125;</span><br><span class="line">curl_share_setopt(share, CURLSHOPT_LOCKFUNC, lock_cb);</span><br></pre></td></tr></table></figure><p>해당 잠금 해제 콜백을 사용하면 다음과 같이 보일 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unlock_cb</span><span class="params">(CURL *handle, curl_lock_data data,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *userptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock[data]); <span class="comment">/* uses a global lock array */</span></span><br><span class="line">&#125;</span><br><span class="line">curl_share_setopt(share, CURLSHOPT_UNLOCKFUNC, unlock_cb);</span><br></pre></td></tr></table></figure><h2 id="공유-해제"><a href="#공유-해제" class="headerlink" title="공유 해제"></a>공유 해제</h2><p>전송은 전송 중에 공유 개체를 사용하고 동일한 개체를 공유하는 다른 핸들과 공유하도록 지정된 개체를 공유합니다.</p><p>후속 전송에서 <code>CURLOPT_SHARE</code>를 NULL로 설정하여 전송이 계속 공유되는 것을 방지할 수 있습니다. 이 경우 핸들은 이전에 공유된 데이터에 대한 빈 캐시로 다음 전송을 시작할 수 있습니다.</p><p>두 전송 간에 공유 개체는 다른 속성 집합을 공유하도록 업데이트되어 해당 개체를 공유하는 핸들이 다음에 다른 데이터 집합을 공유할 수도 있습니다. DNS 데이터를 공유 해제할 때 다음과 같이 curl_share_setopt()의 <code>CURLSHOPT_UNSHARE</code> 옵션을 사용하여 공유 개체에서 공유할 항목을 제거합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_share_setopt(share, CURLSHOPT_UNSHARE, CURL_LOCK_DATA_DNS);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%ED%95%B8%EB%93%A4%20%EA%B0%84%EC%97%90%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EA%B3%B5%EC%9C%A0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl for C++ programmers</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20for%20C++%20programmers/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20for%20C++%20programmers/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;for-C-programmers&quot;&gt;&lt;a href=&quot;#for-C-programmers&quot; class=&quot;headerlink&quot; title=&quot;for C++ programmers&quot;&gt;&lt;/a&gt;for C++ programmers&lt;/h1&gt;&lt;p&gt;libcur
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="for-C-programmers"><a href="#for-C-programmers" class="headerlink" title="for C++ programmers"></a>for C++ programmers</h1><p>libcurl은 C API를 제공합니다. C와 C++는 비슷하지만 같지는 않습니다. C++에서 libcurl을 사용할 때 염두에 두어야 할 몇 가지 사항이 있습니다.</p><h2 id="문자열은-C-문자열-객체가-아니라-C-문자열입니다"><a href="#문자열은-C-문자열-객체가-아니라-C-문자열입니다" class="headerlink" title="문자열은 C++ 문자열 객체가 아니라 C 문자열입니다."></a>문자열은 C++ 문자열 객체가 아니라 C 문자열입니다.</h2><p><code>char *</code>를 허용하는 libcurl의 API에 문자열을 전달할 때 C++ 문자열이나 객체를 해당 함수에 전달할 수 없음을 의미합니다.</p><p>예를 들어, C++로 문자열을 작성한 다음 해당 문자열을 URL로 사용하려는 경우:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> url = <span class="string">"https://example.com/foo.asp?name="</span> + i;</span><br><span class="line">curl_easy_setopt(curl, CURLOPT_URL, url.c_str());</span><br></pre></td></tr></table></figure><h2 id="콜백-고려-사항"><a href="#콜백-고려-사항" class="headerlink" title="콜백 고려 사항"></a>콜백 고려 사항</h2><p>libcurl은 C 라이브러리이기 때문에 C++ 멤버 함수나 객체에 대해 아무것도 모릅니다. 클래스에 대한 포인터가 전달되는 정적 멤버 함수를 사용하면 이 “제한”을 비교적 쉽게 극복할 수 있습니다.</p><p>다음은 C++ 메서드를 콜백으로 사용하는 쓰기 콜백의 예입니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f is the pointer to your object.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">YourClass::func</span><span class="params">(<span class="keyword">void</span> *<span class="built_in">buffer</span>, <span class="keyword">size_t</span> sz, <span class="keyword">size_t</span> n, <span class="keyword">void</span> *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Call non-static member function.</span></span><br><span class="line">  <span class="keyword">static_cast</span>&lt;YourClass*&gt;(f)-&gt;nonStaticFunction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is how you pass pointer to the static function:</span></span><br><span class="line">curl_easy_setopt(hcurl, CURLOPT_WRITEFUNCTION, YourClass::func);</span><br><span class="line">curl_easy_setopt(hcurl, CURLOPT_WRITEDATA, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20for%20C++%20programmers/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl 이름 확인</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%9D%B4%EB%A6%84%20%ED%99%95%EC%9D%B8/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%9D%B4%EB%A6%84%20%ED%99%95%EC%9D%B8/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이름-확인&quot;&gt;&lt;a href=&quot;#이름-확인&quot; class=&quot;headerlink&quot; title=&quot;이름 확인&quot;&gt;&lt;/a&gt;이름 확인&lt;/h1&gt;&lt;p&gt;libcurl이 수행할 수 있는 대부분의 전송에는 먼저 인터넷 주소로 변환되어야 하는 이름이 포함됩니다.
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="이름-확인"><a href="#이름-확인" class="headerlink" title="이름 확인"></a>이름 확인</h1><p>libcurl이 수행할 수 있는 대부분의 전송에는 먼저 인터넷 주소로 변환되어야 하는 이름이 포함됩니다. 그것은 “이름 확인”입니다. URL에서 직접 숫자 IP 주소를 사용하면 일반적으로 이름 확인 단계를 피할 수 있지만 대부분의 경우 이름을 IP 주소로 수동으로 바꾸는 것이 쉽지 않습니다.</p><p>libcurl은 새로운 연결을 생성하기 보다는 <a href="https://jung-max.github.io/2022/02/09/Linux-libcurl%20연결%20재사용">기존 연결을 재사용</a>하기 위해 열심히 노력합니다. 사용할 기존 연결을 확인하는 기능은 순전히 이름을 기반으로 하며 이름 확인이 시도되기 전에 수행됩니다. 이것이 재사용이 훨씬 더 빠른 이유 중 하나입니다. 재사용된 연결을 사용하는 전송은 호스트 이름을 다시 확인하지 않습니다.</p><p>연결을 재사용할 수 없는 경우 libcurl은 확인하려는 주소 집합으로 호스트 이름을 확인합니다. 일반적으로 이것은 IPv4 및 IPv6 주소를 모두 요청한다는 것을 의미하며 libcurl에 반환된 전체 집합이 있을 수 있습니다. 그런 다음 해당 주소 집합이 작동하거나 실패를 반환할 때까지 시도됩니다.</p><p>응용 프로그램은 CURLOPT_IPRESOLVE를 기본 값으로 설정하여 libcurl이 IPv4 또는 IPv6 확인 주소만 사용하도록 할 수 있습니다. 예를 들어 IPv6 주소만 사용하도록 요청합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(easy, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V6);</span><br></pre></td></tr></table></figure><h2 id="이름-확인자-백엔드"><a href="#이름-확인자-백엔드" class="headerlink" title="이름 확인자 백엔드"></a>이름 확인자 백엔드</h2><p>libcurl은 이 세 가지 다른 방법 중 하나로 이름 확인을 수행하도록 빌드할 수 있으며 사용되는 백엔드 방법에 따라 약간 다른 기능 세트와 때때로 수정된 동작을 얻습니다.</p><ol><li>기본 백엔드는 새로운 도우미 스레드에서 “일반” libc 해석기 기능을 호출하므로 원하는 경우 여전히 세분화된 시간 초과를 수행할 수 있고 차단 호출이 포함되지 않습니다.</li><li>이전 시스템에서 libcurl은 표준 동기 이름 해석기 기능을 사용합니다. 불행히도 작동하는 동안 다중 핸들 블록 내에서 모든 전송을 수행하며 멋지게 시간 초과되는 것이 훨씬 더 어렵습니다.</li><li>스레드를 사용하지 않고 비동기식 이름 확인을 지원하는 c-ares 타사 라이브러리로 확인하기 위한 지원도 있습니다. 이것은 엄청난 수의 병렬 전송으로 더 잘 확장되지만 기본 이름 확인기 기능과 항상 100% 호환되는 것은 아닙니다.</li></ol><h2 id="HTTPS를-통한-DNS"><a href="#HTTPS를-통한-DNS" class="headerlink" title="HTTPS를 통한 DNS"></a>HTTPS를 통한 DNS</h2><p>libcurl이 사용하도록 빌드된 확인자 백엔드와는 별개로, 7.62.0부터는 사용자가 특정 DoH(DNS over HTTPS) 서버에 이름 주소를 요청할 수 있는 방법도 제공합니다. 이렇게 하면 일반적인 기본 리졸버 메서드와 서버를 사용하지 않고 전용 별도의 메서드와 서버를 요청합니다.</p><p>DoH 서버는 다음과 같이 <code>CURLOPT_DOH_URL</code> 옵션을 사용하여 전체 URL로 지정됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(easy, CURLOPT_DOH_URL, <span class="string">"https://example.com/doh"</span>);</span><br></pre></td></tr></table></figure><p>이 옵션에 전달되는 URL은 <code>https://</code>를 사용해야 하며 일반적으로 libcurl이 DoH 서버에 대한 연결을 통해 다중 DoH 요청을 수행할 수 있도록 HTTP/2 지원을 활성화하는 것이 좋습니다.</p><h2 id="캐싱"><a href="#캐싱" class="headerlink" title="캐싱"></a>캐싱</h2><p>이름이 확인되면 결과는 libcurl의 메모리 내 캐시에 저장되어 이름이 DNS 캐시에 유지되는 한 동일한 이름에 대한 후속 확인이 거의 즉시 이루어집니다. 기본적으로 각 항목은 캐시에 60초 동안 유지되지만 해당 값은 <code>CURLOPT_DNS_CACHE_TIMEOUT</code>으로 변경할 수 있습니다.</p><p>DNS 캐시는 <code>curl_easy_perform</code>을 사용하는 경우 easy 핸들 내에, 멀티 인터페이스를 사용하는 경우 멀티 핸들 내에 유지됩니다. 또한 <a href="https://jung-max.github.io/2022/02/09/Linux-libcurl%20핸들%20간에%20데이터%20공유">공유 인터페이스</a>를 사용하여 여러 개의 쉬운 핸들 간에 공유할 수 있습니다.</p><h2 id="호스트에-대한-사용자-지정-주소"><a href="#호스트에-대한-사용자-지정-주소" class="headerlink" title="호스트에 대한 사용자 지정 주소"></a>호스트에 대한 사용자 지정 주소</h2><p>때로는 실제 호스트 이름에 “가짜” 주소를 제공하여 libcurl이 실제 이름 확인이 제안하는 주소 대신 다른 주소에 연결하도록 하는 것이 편리합니다.</p><p><a href="https://curl.se/libcurl/c/CURLOPT_RESOLVE.html" rel="external nofollow noopener noreferrer" target="_blank">CURLOPT_RESOLVE</a> 옵션의 도움으로 응용 프로그램은 libcurl의 DNS 캐시를 지정된 호스트 이름 및 포트 번호에 대한 사용자 지정 주소로 미리 채울 수 있습니다.</p><p>포트 443의 example.com이 요청될 때 libcurl이 127.0.0.1에 연결되도록 하려면 애플리케이션에서 다음을 수행할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">curl_slist</span> *<span class="title">dns</span>;</span></span><br><span class="line">dns = curl_slist_append(<span class="literal">NULL</span>, <span class="string">"example.com:443:127.0.0.1"</span>);</span><br><span class="line">curl_easy_setopt(curl, CURLOPT_RESOLVE, dns);</span><br></pre></td></tr></table></figure><p>이렇게 하면 “가짜” 주소가 DNS 캐시에 저장되기 때문에 리디렉션 등을 따라갈 때도 작동합니다.</p><h2 id="네임서버-옵션"><a href="#네임서버-옵션" class="headerlink" title="네임서버 옵션"></a>네임서버 옵션</h2><p>c-ares를 사용하도록 빌드된 libcurl의 경우 사용할 DNS 서버와 방법을 세밀하게 제어할 수 있는 몇 가지 옵션이 있습니다. 이것은 이름 해석을 위한 표준 시스템 호출이 사용될 때 사용할 수 없는 권한이기 때문에 순전히 c-are 빌드로 제한됩니다.</p><ul><li><code>CURLOPT_DNS_SERVERS</code>를 통해 애플리케이션은 전용 DNS 서버 세트를 사용하도록 선택할 수 있습니다.</li><li><code>CURLOPT_DNS_INTERFACE</code>를 사용하면 기본 인터페이스 대신 DNS를 사용할 네트워크 인터페이스를 libcurl에 알릴 수 있습니다.</li><li><code>CURLOPT_DNS_LOCAL_IP4</code> 및 <code>CURLOPT_DNS_LOCAL_IP6</code>을 사용하면 응용 프로그램에서 DNS를 바인딩할 특정 네트워크 주소를 지정할 수 있습니다.</li></ul><h2 id="전역-DNS-캐시-없음"><a href="#전역-DNS-캐시-없음" class="headerlink" title="전역 DNS 캐시 없음"></a>전역 DNS 캐시 없음</h2><p><code>CURLOPT_DNS_USE_GLOBAL_CACHE</code>라는 옵션은 한때 curl에 전역 DNS 캐시를 사용하도록 지시했습니다. 이 기능은 7.65.0 이후 제거되었으므로 이 옵션이 여전히 존재하는 동안에는 아무 것도 하지 않습니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%9D%B4%EB%A6%84%20%ED%99%95%EC%9D%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl 전역 초기화</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%A0%84%EC%97%AD%20%EC%B4%88%EA%B8%B0%ED%99%94/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%A0%84%EC%97%AD%20%EC%B4%88%EA%B8%B0%ED%99%94/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;전역-초기화&quot;&gt;&lt;a href=&quot;#전역-초기화&quot; class=&quot;headerlink&quot; title=&quot;전역 초기화&quot;&gt;&lt;/a&gt;전역 초기화&lt;/h1&gt;&lt;p&gt;프로그램에서 libcurl과 관련된 작업을 수행하기 전에 &lt;code&gt;curl_global_init
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="전역-초기화"><a href="#전역-초기화" class="headerlink" title="전역 초기화"></a>전역 초기화</h1><p>프로그램에서 libcurl과 관련된 작업을 수행하기 전에 <code>curl_global_init()</code>으로 전역 libcurl 초기화 호출을 수행해야 합니다. 이는 libcurl이 사용할 수 있는 일부 기본 라이브러리가 설정을 가져오고 적절하게 초기화하기 위해 미리 호출해야 하기 때문에 필요합니다.</p><p><code>curl_global_init()</code>은 불행히도 스레드로부터 안전하지 않으므로 한 번만 수행하고 다른 호출과 동시에 수행하지 않도록 해야 합니다. 전역 상태를 초기화하므로 한 번만 호출해야 하며 프로그램이 libcurl을 사용하여 완전히 완료되면 <code>curl_global_cleanup()</code>을 호출하여 할당된 초기화 호출과 관련된 전역 리소스를 해제하고 정리할 수 있습니다.</p><p>libcurl은 <code>curl_global_init()</code> 호출을 건너뛰는 상황을 처리하도록 빌드되었지만 대신 자체적으로 호출하여 수행하고(실제 파일 전송이 시작되기 전에 수행하지 않은 경우) 자체 기본값을 사용합니다. 그러나 그때도 여전히 스레드로부터 안전하지 않으므로 “흥미로운” 부작용이 발생할 수 있습니다. <code>curl_global_init()</code>를 제어된 방식으로 직접 호출하는 것이 훨씬 좋습니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%A0%84%EC%97%AD%20%EC%B4%88%EA%B8%B0%ED%99%94/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl API 호환성</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20API%20%ED%98%B8%ED%99%98%EC%84%B1/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20API%20%ED%98%B8%ED%99%98%EC%84%B1/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;API-호환성&quot;&gt;&lt;a href=&quot;#API-호환성&quot; class=&quot;headerlink&quot; title=&quot;API 호환성&quot;&gt;&lt;/a&gt;API 호환성&lt;/h1&gt;&lt;p&gt;libcurl은 API 안정성을 약속하고 오늘 작성된 프로그램이 앞으로도 계속 작동할 것임
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="API-호환성"><a href="#API-호환성" class="headerlink" title="API 호환성"></a>API 호환성</h1><p>libcurl은 API 안정성을 약속하고 오늘 작성된 프로그램이 앞으로도 계속 작동할 것임을 보장합니다. 우리는 호환성을 깨뜨리지 않습니다.</p><p>시간이 지남에 따라 기능, 새 옵션 및 새 기능을 API에 추가하지만 호환되지 않는 방식으로 동작을 변경하거나 기능을 제거하지 않습니다.</p><p>API를 호환되지 않는 방식으로 마지막으로 변경한 것은 2006년 7.16.0용이었고 다시는 변경하지 않을 계획입니다.</p><h2 id="버전-번호"><a href="#버전-번호" class="headerlink" title="버전 번호"></a>버전 번호</h2><p>Curl과 libcurl은 개별적으로 버전이 지정되지만 대부분 서로 밀접하게 따릅니다.<br>버전 번호는 항상 동일한 시스템을 사용하여 구성됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X.Y.Z</span><br></pre></td></tr></table></figure><ul><li>X는 기본 버전 번호입니다.</li><li>Y는 릴리스 번호입니다.</li><li>Z는 패치 번호입니다.</li></ul><h2 id="범람하는-숫자"><a href="#범람하는-숫자" class="headerlink" title="범람하는 숫자"></a>범람하는 숫자</h2><p>이 X.Y.Z 숫자 중 하나는 모든 새 릴리스에서 충돌합니다. 범프된 숫자의 오른쪽에 있는 숫자는 0으로 재설정됩니다.</p><p>기본 버전 번호 X는 실제로 크고 충돌하는 변경 사항이 있을 때 충돌합니다. 릴리스 번호 Y는 변경이 수행되거나 사물/기능이 추가될 때 범프됩니다. 변경 사항이 단순한 버그 수정일 때 패치 번호 Z가 충돌합니다.</p><p>이는 릴리스 1.2.3 이후에 정말 큰 변화가 있으면 2.0.0을 릴리스할 수 있고, 그렇지 않은 경우 1.3.0을 릴리스하거나 대부분의 버그가 수정된 경우 1.2.4를 릴리스할 수 있음을 의미합니다.</p><p>숫자를 1로 늘릴 때와 같이 범핑은 무조건 숫자 중 하나에만 영향을 미칩니다(오른쪽에 있는 숫자는 0으로 설정됨). 1은 2가 되고 3은 4가 되고 9는 10이 되고 88은 89가 되고 99는 100이 됩니다. 따라서 1.2.9 이후에는 1.2.10이 됩니다. 3.99.3 이후에는 3.100.0이 나올 수 있습니다.</p><p>모든 원본 컬 소스 릴리스 아카이브는 libcurl 버전에 따라 이름이 지정됩니다(앞서 말했듯이 다를 수 있는 컬 클라이언트 버전이 아님).</p><h2 id="어떤-libcurl-버전"><a href="#어떤-libcurl-버전" class="headerlink" title="어떤 libcurl 버전"></a>어떤 libcurl 버전</h2><p>새로운 libcurl 기능을 지원하는 동시에 이전 버전으로 빌드할 수 있는 모든 애플리케이션에 대한 서비스로 모든 릴리스에는 비교에 사용할 수 있는 정적 번호 매기기 체계를 사용하여 <code>curl/curlver.h</code> 파일에 libcurl 버전이 저장되어 있습니다. . 버전 번호는 다음과 같이 정의됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBCURL_VERSION_NUM 0xXXYYZZ</span></span><br></pre></td></tr></table></figure><p>여기서 XX, YY 및 ZZ는 16진수의 기본 버전, 릴리스 및 패치 번호입니다. 세 개의 숫자 필드 모두는 항상 두 자리(각각 8비트)를 사용하여 표현됩니다. 1.2.0은 “0x010200”으로 표시되고 버전 9.11.7은 “0x090b07”로 표시됩니다.</p><p>이 6자리 16진수 숫자는 최신 릴리스에서 항상 더 큰 숫자입니다. 일보다 크거나 작음과 비교합니다.</p><p>이 번호는 <code>LIBCURL_VERSION_MAJOR</code>, <code>LIBCURL_VERSION_MINOR</code> 및 <code>LIBCURL_VERSION_PATCH</code>의 세 가지 개별 정의로도 사용할 수 있습니다.<br>물론 이러한 정의는 지금 빌드된 버전 번호를 파악하는 데에만 적합하며 지금부터 3년 후 런타임에 사용되는 libcurl 버전을 파악하는 데 도움이 되지 않습니다.</p><h2 id="실행되는-libcurl-버전"><a href="#실행되는-libcurl-버전" class="headerlink" title="실행되는 libcurl 버전"></a>실행되는 libcurl 버전</h2><p>애플리케이션이 현재 사용하고 있는 libcurl 버전을 파악하기 위해 <code>curl_version_info()</code>가 있습니다.</p><p>동적/DLL 라이브러리는 응용 프로그램과 독립적으로 변경할 수 있으므로 응용 프로그램은 컴파일 시간 검사를 사용하는 대신 이 기능을 사용하여 작업이 가능한지 여부를 판단해야 합니다.</p><p><code>curl_version_info()</code>는 버전 번호 및 다양한 기능과 실행 중인 libcurl 버전에 대한 정보가 포함된 구조체에 대한 포인터를 반환합니다. 당신은 libcurl이 그것을 호출하는 libcurl의 “나이”를 알 수 있도록 특별한 나이 카운터를 주어 그것을 호출합니다. 나이는 CURLVERSION_NOW라고 하는 정의이며 컬 발달 전반에 걸쳐 불규칙한 간격으로 증가하는 카운터입니다. 연령 번호는 libcurl이 반환할 수 있는 구조체 집합을 알려줍니다.</p><p>다음과 같이 함수를 호출합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_version_info_data *ver = curl_version_info( CURLVERSION_NOW );</span><br></pre></td></tr></table></figure><p>그러면 데이터는 다음 레이아웃을 갖거나 가질 수 있는 구조체를 가리킬 것입니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  CURLversion age;          <span class="comment">/* see description below */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 0 or higher, the members below also exist: */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *version;      <span class="comment">/* human readable string */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> version_num; <span class="comment">/* numeric representation */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *host;         <span class="comment">/* human readable string */</span></span><br><span class="line">  <span class="keyword">int</span> features;             <span class="comment">/* bitmask, see below */</span></span><br><span class="line">  <span class="keyword">char</span> *ssl_version;        <span class="comment">/* human readable string */</span></span><br><span class="line">  <span class="keyword">long</span> ssl_version_num;     <span class="comment">/* not used, always zero */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *libz_version; <span class="comment">/* human readable string */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *protocols; <span class="comment">/* protocols */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 1 or higher, the members below also exist: */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ares;         <span class="comment">/* human readable string */</span></span><br><span class="line">  <span class="keyword">int</span> ares_num;             <span class="comment">/* number */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 2 or higher, the member below also exists: */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *libidn;       <span class="comment">/* human readable string */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 3 or higher (7.16.1 or later), the members below also</span></span><br><span class="line"><span class="comment">     exist  */</span></span><br><span class="line">  <span class="keyword">int</span> iconv_ver_num;       <span class="comment">/* '_libiconv_version' if iconv support enabled */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *libssh_version; <span class="comment">/* human readable string */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 4 or higher, the member below also exists: */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> brotli_ver_num; <span class="comment">/* Numeric Brotli version</span></span><br><span class="line"><span class="comment">                                  (MAJOR &lt;&lt; 24) | (MINOR &lt;&lt; 12) | PATCH */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *brotli_version; <span class="comment">/* human readable string. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 5 or higher, the member below also exists: */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> nghttp2_ver_num; <span class="comment">/* Numeric nghttp2 version</span></span><br><span class="line"><span class="comment">                                   (MAJOR &lt;&lt; 16) | (MINOR &lt;&lt; 8) | PATCH */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *nghttp2_version; <span class="comment">/* human readable string. */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *quic_version;    <span class="comment">/* human readable quic (+ HTTP/3) library +</span></span><br><span class="line"><span class="comment">                                  version or NULL */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 6 or higher, the member below also exists: */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cainfo;          <span class="comment">/* the built-in default CURLOPT_CAINFO, might</span></span><br><span class="line"><span class="comment">                                  be NULL */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *capath;          <span class="comment">/* the built-in default CURLOPT_CAPATH, might</span></span><br><span class="line"><span class="comment">                                  be NULL */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 7 or higher, the member below also exists: */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> zstd_ver_num; <span class="comment">/* Numeric Zstd version</span></span><br><span class="line"><span class="comment">                                  (MAJOR &lt;&lt; 24) | (MINOR &lt;&lt; 12) | PATCH */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *zstd_version; <span class="comment">/* human readable string. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 8 or higher, the member below also exists: */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *hyper_version; <span class="comment">/* human readable string. */</span></span><br><span class="line"></span><br><span class="line">&#125; curl_version_info_data;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20API%20%ED%98%B8%ED%99%98%EC%84%B1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl Header files</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Header%20files/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Header%20files/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Header-files&quot;&gt;&lt;a href=&quot;#Header-files&quot; class=&quot;headerlink&quot; title=&quot;Header files&quot;&gt;&lt;/a&gt;Header files&lt;/h1&gt;&lt;p&gt;응용 프로그램을 사용하는 libcurl이 포함해야 하는
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Header-files"><a href="#Header-files" class="headerlink" title="Header files"></a>Header files</h1><p>응용 프로그램을 사용하는 libcurl이 포함해야 하는 헤더는 단 하나뿐입니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>그 파일에는 몇 가지 다른 공개 헤더 파일이 포함되어 있지만 존재하지 않는 척 할 수 있습니다. (역사적으로 말해서, 우리는 약간 다르게 시작했지만 시간이 지남에 따라 포함에 대해 하나만 사용하는 이 형식을 중심으로 안정화되었습니다.)</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Header%20files/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl --libcurl</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20--libcurl/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20--libcurl/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;–libcurl&quot;&gt;&lt;a href=&quot;#–libcurl&quot; class=&quot;headerlink&quot; title=&quot;–libcurl&quot;&gt;&lt;/a&gt;–libcurl&lt;/h1&gt;&lt;p&gt;우리는 사용자가 먼저 curl 명령줄 도구로 수행하려는 전송을 시도할 것을 적극 권
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="–libcurl"><a href="#–libcurl" class="headerlink" title="–libcurl"></a>–libcurl</h1><p>우리는 사용자가 먼저 curl 명령줄 도구로 수행하려는 전송을 시도할 것을 적극 권장하며, 대략 원하는 대로 작동하면 <code>--libcurl [filename]</code> 옵션을 명령줄에 추가하고 다시 다음을 실행합니다.</p><p><code>--libcurl</code> 명령줄 옵션은 제공된 파일 이름으로 C 프로그램을 생성합니다. C 프로그램은 libcurl을 사용하여 방금 curl 명령줄 도구에서 수행한 전송을 실행하는 응용 프로그램입니다. 몇 가지 예외가 있고 항상 100% 일치하는 것은 아니지만 원하는 libcurl 옵션과 사용할 수 있는 libcurl 옵션 및 제공할 추가 인수에 대한 훌륭한 영감 소스 역할을 할 수 있습니다.</p><p><code>--libcurl -</code>과 같이 파일 이름을 단일 대시로 지정하면 파일 대신 stdout에 프로그램이 작성됩니다.</p><p>예를 들어 <code>http://example.com</code>을 가져오는 명령을 실행합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:<span class="comment">//example.com --libcurl example.c</span></span><br></pre></td></tr></table></figure><p>이렇게 하면 현재 디렉토리에 다음과 유사한 <code>example.c</code>가 생성됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********* Sample code generated by the curl command-line tool **********</span></span><br><span class="line"><span class="comment"> * All curl_easy_setopt() options are documented at:</span></span><br><span class="line"><span class="comment"> * https://curl.se/libcurl/c/curl_easy_setopt.html</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURLcode ret;</span><br><span class="line">  CURL *hnd;</span><br><span class="line"></span><br><span class="line">  hnd = curl_easy_init();</span><br><span class="line">  curl_easy_setopt(hnd, CURLOPT_URL, <span class="string">"http://example.com"</span>);</span><br><span class="line">  curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, <span class="number">1L</span>);</span><br><span class="line">  curl_easy_setopt(hnd, CURLOPT_USERAGENT, <span class="string">"curl/7.45.0"</span>);</span><br><span class="line">  curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, <span class="number">50L</span>);</span><br><span class="line">  curl_easy_setopt(hnd, CURLOPT_SSH_KNOWNHOSTS, <span class="string">"/home/daniel/.ssh/known_hosts"</span>);</span><br><span class="line">  curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, <span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Here is a list of options the curl code used that cannot get generated</span></span><br><span class="line"><span class="comment">     as source easily. You may select to either not use them or implement</span></span><br><span class="line"><span class="comment">     them yourself.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  CURLOPT_WRITEDATA set to a objectpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_WRITEFUNCTION set to a functionpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_READDATA set to a objectpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_READFUNCTION set to a functionpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_SEEKDATA set to a objectpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_SEEKFUNCTION set to a functionpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_ERRORBUFFER set to a objectpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_STDERR set to a objectpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_HEADERFUNCTION set to a functionpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_HEADERDATA set to a objectpointer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  ret = curl_easy_perform(hnd);</span><br><span class="line"></span><br><span class="line">  curl_easy_cleanup(hnd);</span><br><span class="line">  hnd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**** End of sample code ****/</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20--libcurl/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl Proxies</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Proxies/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Proxies/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;프록시&quot;&gt;&lt;a href=&quot;#프록시&quot; class=&quot;headerlink&quot; title=&quot;프록시&quot;&gt;&lt;/a&gt;프록시&lt;/h1&gt;&lt;p&gt;네트워크 컨텍스트에서 프록시는 중개자, 즉 클라이언트인 귀하와 통신하려는 원격 서버 사이에 있는 서버입니다. 클라이언트
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="프록시"><a href="#프록시" class="headerlink" title="프록시"></a>프록시</h1><p>네트워크 컨텍스트에서 프록시는 중개자, 즉 클라이언트인 귀하와 통신하려는 원격 서버 사이에 있는 서버입니다. 클라이언트는 중간 사람에게 연락한 다음 계속해서 원격 서버에 연락합니다.</p><p>이 스타일의 프록시 사용은 회사와 조직에서 사용하는 경우가 있으며, 이 경우 일반적으로 대상 서버에 도달하기 위해 사용해야 합니다.</p><p>프록시와 통신할 때 사용할 여러 종류의 프록시와 프로토콜이 있으며 libcurl은 가장 일반적인 몇 가지 프록시 프로토콜을 지원합니다. 프록시에 사용되는 프로토콜이 원격 서버에 사용되는 프로토콜과 반드시 같지는 않다는 점을 인식하는 것이 중요합니다.</p><p>libcurl로 전송을 설정할 때 프록시의 서버 이름과 포트 번호를 지적해야 합니다. 여러분이 즐겨 사용하는 브라우저가 libcurl보다 약간 더 고급 방식으로 이 작업을 수행할 수 있다는 것을 알게 될 것입니다. 이러한 세부 사항은 이후 섹션에서 다룰 것입니다.</p><h2 id="프록시-유형"><a href="#프록시-유형" class="headerlink" title="프록시 유형"></a>프록시 유형</h2><p>libcurl은 SOCKS 및 HTTP 프록시의 두 가지 주요 프록시 유형을 지원합니다. 보다 구체적으로, 원격 이름 조회가 있거나 없는 SOCKS4 및 SOCKS5와 로컬 프록시에 대한 HTTP 및 HTTPS를 모두 지원합니다.</p><p>말하는 프록시의 종류를 지정하는 가장 쉬운 방법은 프록시 호스트 이름 문자열(<code>CURLOPT_PROXY</code>)의 구성표 부분을 일치하도록 설정하는 것입니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socks4:<span class="comment">//proxy.example.com:12345/</span></span><br><span class="line">socks4a:<span class="comment">//proxy.example.com:12345/</span></span><br><span class="line">socks5:<span class="comment">//proxy.example.com:12345/</span></span><br><span class="line">socks5h:<span class="comment">//proxy.example.com:12345/</span></span><br><span class="line">http:<span class="comment">//proxy.example.com:12345/</span></span><br><span class="line">https:<span class="comment">//proxy.example.com:12345/</span></span><br></pre></td></tr></table></figure><ul><li><code>socks4</code> - 로컬 이름 확인이 있는 SOCKS4를 의미합니다.</li><li><code>socks4a</code> - 프록시 이름이 확인되는 SOCKS4를 의미합니다.</li><li><code>socks5</code> - 로컬 이름 확인이 있는 SOCKS5를 의미합니다.</li><li><code>socks5h</code> - 프록시 이름이 확인되는 SOCKS5를 의미합니다.</li><li><code>http</code> - 프록시가 항상 이름을 확인할 수 있도록 하는 HTTP를 의미합니다.</li><li><code>https</code> - 프록시에 대한 HTTPS를 의미하며 항상 프록시가 이름을 확인할 수 있습니다(HTTPS 프록시 지원은 최근 curl 7.52.0에 추가되었으며 OpenSSL, GnuTLS 및 NSS와 같은 TLS 라이브러리의 하위 집합에서만 작동합니다. )</li></ul><p><code>CURLOPT_PROXYTYPE</code>을 사용하여 호스트 이름만 설정하려는 경우 별도의 옵션으로 프록시 유형을 설정하도록 선택할 수도 있습니다. 마찬가지로 <code>CURLOPT_PROXYPORT</code>와 함께 사용할 프록시 포트 번호를 설정할 수 있습니다.</p><h2 id="로컬-또는-프록시-이름-조회"><a href="#로컬-또는-프록시-이름-조회" class="headerlink" title="로컬 또는 프록시 이름 조회"></a>로컬 또는 프록시 이름 조회</h2><p>위의 섹션에서 서로 다른 프록시 설정을 통해 전송에 관련된 다른 당사자가 이름 확인을 수행할 수 있음을 알 수 있습니다. 여러 경우에 클라이언트가 서버 호스트 이름을 확인하고 연결할 프록시에 IP 주소를 전달하도록 할 수 있습니다. 물론 이름 조회가 클라이언트 시스템에서 정확하게 작동한다고 가정합니다. 프록시가 이름을 확인하도록 합니다. 연결할 IP 주소로 변환합니다.</p><p>HTTP 또는 HTTPS 프록시를 사용하는 경우 항상 확인할 프록시에 이름을 지정합니다.</p><h2 id="어떤-프록시"><a href="#어떤-프록시" class="headerlink" title="어떤 프록시?"></a>어떤 프록시?</h2><p>네트워크 연결에서 목적지에 도달하기 위해 프록시를 사용해야 하는 경우, 이를 파악하고 올바른 프록시를 사용하도록 libcurl에 알려야 합니다. libcurl에서는 프록시를 자동으로 파악하거나 감지하도록 지원하지 않습니다.</p><p>브라우저를 사용할 때 프록시에 PAC 스크립트 또는 기타 수단을 제공하는 것이 일반적이지만 libcurl에서는 그 중 어느 것도 인식하지 못합니다.</p><h3 id="프록시-환경-변수"><a href="#프록시-환경-변수" class="headerlink" title="프록시 환경 변수"></a>프록시 환경 변수</h3><p>프록시 옵션이 설정되지 않은 경우 libcurl은 프록시가 사용되도록 요청되었는지 확인하기 위해 전송을 수행하기 전에 특별히 명명된 환경 변수의 존재를 확인합니다.</p><p>프록시 호스트 이름을 보유하도록 <code>[scheme]_proxy</code>라는 변수를 설정하여 프록시를 지정할 수 있습니다(호스트를 -x로 지정하는 것과 동일한 방식). 따라서 HTTP 서버에 접근할 때 프록시를 사용하도록 curl에 지시하려면 ‘http_proxy’ 환경 변수를 설정합니다. 이와 같이:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://proxy.example.com:80</span><br></pre></td></tr></table></figure><p>위의 프록시 예제는 HTTP용이지만 물론 프록시하려는 특정 프로토콜에 대해 <code>ftp_proxy</code>, <code>https_proxy</code> 등을 설정할 수도 있습니다. http_proxy를 제외한 이러한 모든 프록시 환경 변수 이름은 <code>HTTPS_PROXY</code>와 같이 대문자로 지정할 수도 있습니다.</p><p>모든 프로토콜을 제어하는 단일 변수를 설정하기 위해 <code>ALL_PROXY</code>가 존재합니다. 특정 프로토콜 변수가 있는 경우 해당 변수가 우선 적용됩니다.</p><p>환경 변수를 사용하여 프록시를 설정할 때 하나 또는 몇 개의 호스트 이름이 프록시를 통과하지 못하도록 제외되어야 하는 상황에 쉽게 도달할 수 있습니다. 이것은 <code>NO_PROXY</code> 변수 또는 해당 <code>CURLOPT_NOPROXY</code> libcurl 옵션을 사용하여 수행할 수 있습니다. 액세스할 때 프록시를 사용하지 않아야 하는 쉼표로 구분된 호스트 이름 목록으로 설정합니다. 모든 호스트와 일치하도록 NO_PROXY를 단일 별표(‘*’)로 설정할 수 있습니다.</p><h2 id="HTTP-프록시"><a href="#HTTP-프록시" class="headerlink" title="HTTP 프록시"></a>HTTP 프록시</h2><p>HTTP 프로토콜은 HTTP 프록시를 사용하는 방법에 대해 자세히 설명합니다. 실제 원격 서버에 요청을 보내는 대신 클라이언트(libcurl)는 대신 프록시에 특정 리소스를 요청합니다. HTTP 프록시에 대한 연결은 암호화되지 않은 일반 HTTP를 사용하여 이루어집니다.</p><p>HTTPS 리소스가 요청되면 libcurl은 대신 프록시에 CONNECT 요청을 발행합니다. 이러한 요청은 프록시를 통해 터널을 열어 데이터를 이해하지 못한 채 전달합니다. 이런 식으로 libcurl은 HTTP 프록시가 있는 경우에도 안전한 종단 간 TLS 연결을 설정할 수 있습니다.</p><p>HTTP 프록시를 통해 비 HTTP 프로토콜을 프록시할 수 있지만 이는 대부분 CONNECT 메서드를 통해 데이터를 터널링하여 수행되기 때문에 클라이언트가 다른 특정 원격 포트 번호에 연결할 수 있도록 프록시를 구성해야 합니다. 많은 HTTP 프록시는 80 및 443 이외의 다른 포트 번호에 대한 연결을 금지하도록 설정됩니다.</p><h2 id="HTTPS-프록시"><a href="#HTTPS-프록시" class="headerlink" title="HTTPS 프록시"></a>HTTPS 프록시</h2><p>HTTPS 프록시는 HTTP 프록시와 유사하지만 클라이언트가 보안 HTTPS 연결을 사용하여 연결할 수 있습니다. 이 경우에도 프록시 연결은 원격 사이트와의 연결과 분리되어 있으므로 원격 사이트에 대한 HTTPS는 프록시에 대한 HTTPS 연결을 통해 터널링되므로 libcurl은 별도의 프록시 연결에 대한 전체 TLS 옵션 집합을 제공합니다. 원격 호스트에 대한 연결에서.</p><p>예를 들어, <code>CURLOPT_PROXY_CAINFO</code>는 <code>CURLOPT_CAINFO</code>가 원격 호스트를 위한 것과 같은 HTTPS 프록시의 기능입니다. <code>CURLOPT_PROXY_SSL_VERIFYPEER</code>는 <code>CURLOPT_SSL_VERIFYPEER</code> 등의 프록시 버전입니다.</p><p>HTTPS 프록시는 오늘날에도 여전히 조직과 회사에서 상당히 이례적입니다.</p><h2 id="프록시-인증"><a href="#프록시-인증" class="headerlink" title="프록시 인증"></a>프록시 인증</h2><p>프록시를 사용한 인증은 프록시 자체와의 핸드셰이크 협상에서 유효한 자격 증명을 제공해야 함을 의미합니다. 프록시 인증은 원격 호스트와의 가능한 인증 또는 인증 부족에 추가 및 분리됩니다.</p><p>libcurl은 HTTP, HTTPS 및 SOCKS5 프록시를 통한 인증을 지원합니다. 핵심 옵션은 <code>CURLOPT_PROXY</code> 문자열 내에서 설정하지 않는 한 사용할 사용자 이름과 암호를 설정하는 <code>CURLOPT_PROXYUSERPWD</code>입니다.</p><h2 id="HTTP-프록시-헤더"><a href="#HTTP-프록시-헤더" class="headerlink" title="HTTP 프록시 헤더"></a>HTTP 프록시 헤더</h2><p>HTTP 또는 HTTP 프록시를 사용하여 libcurl은 헤더 세트를 포함하는 프록시에 요청을 발행합니다. 물론 애플리케이션은 서버로 보낸 요청과 마찬가지로 헤더를 수정할 수 있습니다.</p><p>libcurl은 <strong>서버에 별도의 요청이 전송될 때</strong> 프록시로 전송되는 헤더를 제어하기 위해 <code>CURLOPT_PROXYHEADER</code>를 제공합니다. 이는 일반적으로 프록시를 통해 터널을 설정하기 위해 프록시로 전송된 초기 CONNECT 요청을 의미합니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Proxies/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl curl easy options</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20curl%20easy%20options/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20curl%20easy%20options/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;curl-easy-options&quot;&gt;&lt;a href=&quot;#curl-easy-options&quot; class=&quot;headerlink&quot; title=&quot;curl easy options&quot;&gt;&lt;/a&gt;curl easy options&lt;/h1&gt;&lt;p&gt;이지 핸들에서 옵션
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="curl-easy-options"><a href="#curl-easy-options" class="headerlink" title="curl easy options"></a>curl easy options</h1><p>이지 핸들에서 옵션을 설정하여 전송 방식을 제어하거나 경우에 따라 실제로 옵션을 설정하고 전송이 진행되는 동안 전송 동작을 수정할 수 있습니다. <code>curl_easy_setopt()</code>로 옵션을 설정하고 핸들, 설정하려는 옵션 및 옵션에 대한 인수를 제공합니다. 모든 옵션은 정확히 하나의 인수를 취하며 항상 <code>curl_easy_setopt()</code> 호출에 정확히 세 개의 매개변수를 전달해야 합니다.</p><p><code>curl_easy_setopt()</code> 호출은 수백 가지 다른 옵션을 허용하고 다양한 옵션은 다양한 유형의 인수를 허용하므로 세부 사항을 읽고 특정 옵션이 지원하고 기대하는 인수 유형을 정확히 제공하는 것이 중요합니다. 잘못된 유형을 전달하면 예기치 않은 부작용이 발생하거나 딸꾹질을 이해하기 어려울 수 있습니다.</p><p>모든 전송에 필요한 가장 중요한 옵션은 URL입니다. libcurl은 관련된 URL을 알지 못하면 전송을 수행할 수 없으므로 알려야 합니다. URL 옵션 이름은 <code>CURLOPT_URL</code>입니다. 모든 옵션에는 <code>CURLOPT_</code> 접두어가 붙은 다음 설명이 포함된 이름이 모두 대문자를 사용하기 때문입니다. <code>http://example.com</code> HTTP 콘텐츠를 가져오기 위해 URL을 설정하는 예제 줄은 다음과 같습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURLcode ret = curl_easy_setopt(easy, CURLOPT_URL, <span class="string">"http://example.com"</span>);</span><br></pre></td></tr></table></figure><p>다시: 이것은 핸들의 옵션만 설정합니다. 실제 전송 또는 기타 작업을 수행하지 않습니다. libcurl에게 문자열을 복사하도록 지시하고 작동하면 OK를 반환합니다.</p><p>물론 반환 코드를 확인하여 아무 문제가 없는지 확인하는 것이 좋습니다.</p><h2 id="숫자-옵션-설정"><a href="#숫자-옵션-설정" class="headerlink" title="숫자 옵션 설정"></a>숫자 옵션 설정</h2><p><code>curl_easy_setopt()</code>는 3번째 인자가 상황에 따라 다른 타입을 사용할 수 있는 vararg 함수이기 때문에 일반적인 C언어 타입 변환은 불가능하다. 따라서 문서에서 그렇게 말하는 경우 ‘int’가 아닌 ‘long’을 실제로 전달했는지 확인해야 합니다. 크기가 같은 아키텍처에서는 문제가 발생하지 않을 수 있지만 모두가 그렇게 작동하지는 않습니다. 마찬가지로 ‘curl_off_t’ 유형을 허용하는 옵션의 경우 해당 유형을 사용하고 다른 유형을 사용하지 않는 인수를 전달하는 것이 중요합니다.</p><p>긴 실행:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_TIMEOUT, <span class="number">5L</span>); <span class="comment">/* 5 seconds timeout */</span></span><br></pre></td></tr></table></figure><p>curl_off_t 시행:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">curl_off_t</span> no_larger_than = <span class="number">0x50000</span>;</span><br><span class="line">curl_easy_setopt(handle, CURLOPT_MAXFILESIZE_LARGE, no_larger_than);</span><br></pre></td></tr></table></figure><h2 id="핸들-옵션-가져오기"><a href="#핸들-옵션-가져오기" class="headerlink" title="핸들 옵션 가져오기"></a>핸들 옵션 가져오기</h2><p>이전에 <code>curl_easy_setopt()</code>로 설정한 것과 동일한 정보를 추출하는 일반적인 방법은 없습니다! 이전에 설정한 정보를 다시 추출해야 하는 경우 애플리케이션에서 해당 데이터를 직접 추적하는 것이 좋습니다.</p><h2 id="TLS-옵션"><a href="#TLS-옵션" class="headerlink" title="TLS 옵션"></a>TLS 옵션</h2><p>이 글을 쓰는 시점에서 libcurl이 SSL과 TLS를 수행하는 방식을 제어하기 위한 전용 curl_easy_setopt에 대해 40가지 이상의 다른 옵션이 있습니다.</p><p>TLS를 사용하여 수행된 전송은 안전한 기본값을 사용하지만 curl은 다양한 시나리오 및 설정에서 사용되기 때문에 이러한 동작을 변경하려는 상황이 발생할 가능성이 있습니다.</p><h3 id="프로토콜-버전"><a href="#프로토콜-버전" class="headerlink" title="프로토콜 버전"></a>프로토콜 버전</h3><p><code>CURLOPT_SSLVERSION</code> 및 <code>CURLOPT_PROXY_SSLVERSION</code>을 사용하여 허용되는 SSL 또는 TLS 프로토콜 범위를 지정할 수 있습니다. 전통적으로 SSL 및 TLS 프로토콜 버전은 시간이 지남에 따라 감지되고 사용하기에 부적합한 것으로 밝혀졌으며 curl 자체가 시간이 지남에 따라 기본 낮은 버전을 올리더라도 가장 최신의 보안 프로토콜 버전만 사용하도록 선택할 수 있습니다.</p><p>이러한 옵션은 허용 가능한 가장 낮은 버전과 선택적으로 최대값을 사용합니다. 서버가 해당 조건으로 연결을 협상할 수 없으면 전송이 실패합니다.</p><p>예시:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(easy, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);</span><br></pre></td></tr></table></figure><h3 id="프로토콜-세부정보-및-동작"><a href="#프로토콜-세부정보-및-동작" class="headerlink" title="프로토콜 세부정보 및 동작"></a>프로토콜 세부정보 및 동작</h3><p><code>CURLOPT_SSL_CIPHER_LIST</code> 및 <code>CURLOPT_PROXY_SSL_CIPHER_LIST</code>를 설정하여 사용할 암호를 선택할 수 있습니다.</p><p><code>CURLOPT_SSL_FALSESTART</code>를 사용하여 SSL “False Start”를 활성화하도록 요청할 수 있으며 <code>CURLOPT_SSL_OPTIONS</code>를 사용하여 조정할 몇 가지 다른 동작 변경 사항이 있습니다.</p><h3 id="확인-Verification"><a href="#확인-Verification" class="headerlink" title="확인(Verification)"></a>확인(Verification)</h3><p>TLS를 사용하는 클라이언트는 자신이 말하는 서버가 정확하고 신뢰할 수 있는 서버인지 확인해야 합니다. 이것은 서버의 인증서가 curl에 대한 공개 키가 있는 인증 기관(CA)에 의해 서명되었고 인증서에 서버의 이름이 포함되어 있는지 확인하여 수행됩니다. 이러한 검사 중 하나라도 실패하면 전송이 실패합니다.</p><p>개발 목적과 실험을 위해 curl을 사용하면 애플리케이션이 서버 또는 HTTPS 프록시에 대한 이러한 검사 중 하나 또는 둘 다를 끌 수 있습니다.</p><ul><li><code>CURLOPT_SSL_VERIFYPEER</code>는 인증서가 신뢰할 수 있는 CA에 의해 서명되었는지 확인하는 것을 제어합니다.</li><li><code>CURLOPT_SSL_VERIFYHOST</code>는 인증서 내의 이름 확인을 제어합니다.</li><li><code>CURLOPT_PROXY_SSL_VERIFYPEER</code>는 <code>CURLOPT_SSL_VERIFYPEER</code>의 프록시 버전입니다.</li><li><code>CURLOPT_PROXY_SSL_VERIFYHOST</code>는 <code>CURLOPT_SSL_VERIFYHOST</code>의 프록시 버전입니다.</li></ul><p>선택적으로 <code>CURLOPT_PINNEDPUBLICKEY</code> 또는 <code>CURLOPT_PROXY_PINNEDPUBLICKEY</code>를 사용하여 알려진 해시에 대해 인증서의 공개 키를 확인하도록 curl에 지시할 수 있습니다. 여기에서도 불일치로 인해 전송이 실패합니다.</p><h3 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h3><h4 id="TLS-클라이언트-인증서"><a href="#TLS-클라이언트-인증서" class="headerlink" title="TLS 클라이언트 인증서"></a>TLS 클라이언트 인증서</h4><p>TLS를 사용하고 서버가 클라이언트에게 인증서를 사용하여 인증하도록 요청할 때 일반적으로 <code>CURLOPT_SSLKEY</code> 및 <code>CURLOPT_SSLCERT</code>를 사용하여 개인 키와 해당 클라이언트 인증서를 지정합니다. 일반적으로 <code>CURLOPT_SSLKEYPASSWD</code>를 사용하여 키의 비밀번호도 설정해야 합니다.</p><p>다시 말하지만, <code>CURLOPT_PROXY_SSLKEY</code>, <code>CURLOPT_PROXY_SSLCERT</code> 등 HTTPS 프록시에 대한 연결에 대해 동일한 옵션 세트가 별도로 존재합니다.</p><h4 id="TLS-인증"><a href="#TLS-인증" class="headerlink" title="TLS 인증"></a>TLS 인증</h4><p>TLS 연결은 보안 원격 암호라는 (거의 사용되지 않는) 기능을 제공합니다. 이것을 사용하여 이름과 암호를 사용하여 서버에 대한 연결을 인증하고 옵션은 <code>CURLOPT_TLSAUTH_USERNAME</code> 및 <code>CURLOPT_TLSAUTH_PASSWORD</code>입니다.</p><h3 id="STARTTLS"><a href="#STARTTLS" class="headerlink" title="STARTTLS"></a>STARTTLS</h3><p>STARTTLS 방법을 사용하여 TLS(FTP, IMAP, POP3 및 SMTP)로의 연결을 업그레이드하는 프로토콜의 경우 일반적으로 URL을 지정할 때 curl에 비TLS 버전의 프로토콜을 사용하도록 지시한 다음 curl에게 TLS를 활성화하도록 <code>CURLOPT_USE_SSL</code> 옵션으로 요청합니다.</p><p>이 옵션을 사용하면 클라이언트가 TLS로 업그레이드할 수 없는 경우 curl을 계속할 수 있지만 제대로 인식하지 못한 채 안전하지 않은 프로토콜을 사용할 수 있으므로 권장하지 않는 경로입니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* require use of SSL for this, or fail */</span></span><br><span class="line">curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_ALL);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20curl%20easy%20options/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl multi-threading</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20multi-threading/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20multi-threading/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;multi-threading&quot;&gt;&lt;a href=&quot;#multi-threading&quot; class=&quot;headerlink&quot; title=&quot;multi-threading&quot;&gt;&lt;/a&gt;multi-threading&lt;/h1&gt;&lt;p&gt;libcurl은 스레드로부터 안전
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="multi-threading"><a href="#multi-threading" class="headerlink" title="multi-threading"></a>multi-threading</h1><p>libcurl은 스레드로부터 안전하지만 내부 스레드 동기화가 없습니다. libcurl 스레드를 올바르게 사용하려면 고유한 잠금을 제공하거나 옵션을 변경해야 할 수 있습니다. 정확히 필요한 것은 libcurl이 빌드된 방식에 따라 다릅니다. 최신 정보가 포함된 libcurl <a href="https://curl.se/libcurl/c/threadsafe.html" rel="external nofollow noopener noreferrer" target="_blank">스레드 안전 웹페이지</a>를 참조하십시오.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20multi-threading/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl Post transfer info</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Post%20transfer%20info/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Post%20transfer%20info/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Post-transfer-info&quot;&gt;&lt;a href=&quot;#Post-transfer-info&quot; class=&quot;headerlink&quot; title=&quot;Post transfer info&quot;&gt;&lt;/a&gt;Post transfer info&lt;/h1&gt;&lt;p&gt;libcur
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Post-transfer-info"><a href="#Post-transfer-info" class="headerlink" title="Post transfer info"></a>Post transfer info</h1><p>libcurl 전송이 “쉬운 핸들”과 어떻게 연관되어 있는지 기억하십시오! 각 전송에는 이러한 핸들이 있으며 전송이 완료되면 핸들을 정리하거나 다른 전송에 재사용하기 전에 이전 작업에서 정보를 추출하는 데 사용할 수 있습니다.</p><p>이 작업을 수행하는 친구를 <code>curl_easy_getinfo()</code>라고 하며 관심 있는 특정 정보를 알려주면 가능한 경우 해당 정보를 반환합니다.</p><p>이 함수를 사용할 때 원하는 정보와 답을 담을 변수에 대한 포인터를 쉽게 처리할 수 있습니다. 올바른 유형의 변수에 대한 포인터를 전달해야 합니다. 그렇지 않으면 일이 엉뚱한 방향으로 갈 위험이 있습니다. 이러한 정보 값은 전송이 완료된 후 제공되도록 설계되었습니다.</p><p>받는 데이터는 long, ‘char’, ‘struct curl_slist’, double 또는 socket일 수 있습니다.</p><p>이전 HTTP 전송에서 <code>Content-Type</code>: 값을 추출하는 방법은 다음과 같습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CURLcode res;</span><br><span class="line"><span class="keyword">char</span> *content_type;</span><br><span class="line">res = curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &amp;content_type);</span><br></pre></td></tr></table></figure><p>해당 연결에 사용된 로컬 포트 번호를 추출하려면 다음을 수행하십시오.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CURLcode res;</span><br><span class="line"><span class="keyword">long</span> port_number;</span><br><span class="line">res = curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT, &amp;port_number);</span><br></pre></td></tr></table></figure><h2 id="이용-가능한-정보"><a href="#이용-가능한-정보" class="headerlink" title="이용 가능한 정보"></a>이용 가능한 정보</h2><table><thead><tr><th align="left">Getinfo option</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">CURLINFO_ACTIVESOCKET</td><td align="left">curl_socket_t</td><td align="left">세션의 활성 소켓</td></tr><tr><td align="left">CURLINFO_APPCONNECT_TIME</td><td align="left">double</td><td align="left">시작부터 SSL/SSH 핸드셰이크가 완료될 때까지의 시간</td></tr><tr><td align="left">CURLINFO_APPCONNECT_TIME_T</td><td align="left">curl_off_t</td><td align="left">시작부터 SSL/SSH 핸드셰이크가 완료될 때까지의 시간(마이크로초)</td></tr><tr><td align="left">CURLINFO_CERTINFO</td><td align="left">struct curl_slist *</td><td align="left">인증서 체인</td></tr><tr><td align="left">CURLINFO_CONDITION_UNMET</td><td align="left">long</td><td align="left">시간 조건이 충족되었는지 여부</td></tr><tr><td align="left">CURLINFO_CONNECT_TIME</td><td align="left">double</td><td align="left">시작부터 원격 호스트 또는 프록시가 완료될 때까지의 시간</td></tr><tr><td align="left">CURLINFO_CONNECT_TIME_T</td><td align="left">curl_off_t</td><td align="left">시작부터 원격 호스트 또는 프록시가 완료될 때까지의 시간(마이크로초)</td></tr><tr><td align="left">CURLINFO_CONTENT_LENGTH_DOWNLOAD</td><td align="left">double</td><td align="left">Content-Length 헤더의 콘텐츠 길이</td></tr><tr><td align="left">CURLINFO_CONTENT_LENGTH_UPLOAD</td><td align="left">double</td><td align="left">업로드 크기</td></tr><tr><td align="left">CURLINFO_CONTENT_TYPE</td><td align="left">char *</td><td align="left">Content-Type 헤더의 콘텐츠 유형</td></tr><tr><td align="left">CURLINFO_COOKIELIST</td><td align="left">struct curl_slist *</td><td align="left">알려진 모든 쿠키 목록</td></tr><tr><td align="left">CURLINFO_EFFECTIVE_METHOD</td><td align="left">char *</td><td align="left">마지막으로 사용한 HTTP 요청 방법</td></tr><tr><td align="left">CURLINFO_EFFECTIVE_URL</td><td align="left">char *</td><td align="left">마지막으로 사용한 URL</td></tr><tr><td align="left">CURLINFO_PROXY_SSL_VERIFYRESULT</td><td align="left">long</td><td align="left">프록시 인증서 확인 결과</td></tr><tr><td align="left">CURLINFO_PROXYAUTH_AVAIL</td><td align="left">long</td><td align="left">사용 가능한 HTTP 프록시 인증 방법</td></tr><tr><td align="left">CURLINFO_REDIRECT_COUNT</td><td align="left">long</td><td align="left">팔로우한 총 리디렉션 수</td></tr><tr><td align="left">CURLINFO_REDIRECT_TIME</td><td align="left">double</td><td align="left">최종 전송 전 모든 리디렉션 단계에 소요된 시간</td></tr><tr><td align="left">CURLINFO_REDIRECT_TIME_T</td><td align="left">curl_off_t</td><td align="left">최종 전송 전 모든 리디렉션 단계에 소요된 시간(마이크로초)</td></tr><tr><td align="left">CURLINFO_REDIRECT_URL</td><td align="left">char *</td><td align="left">리디렉션을 활성화한 경우 리디렉션을 통해 이동할 URL</td></tr><tr><td align="left">CURLINFO_REQUEST_SIZE</td><td align="left">long</td><td align="left">발행된 HTTP 요청에서 보낸 바이트 수</td></tr><tr><td align="left">CURLINFO_RESPONSE_CODE</td><td align="left">long</td><td align="left">마지막으로 받은 응답 코드</td></tr><tr><td align="left">CURLINFO_RETRY_AFTER</td><td align="left">curl_off_t</td><td align="left">응답 Retry-After: 헤더의 값</td></tr><tr><td align="left">CURLINFO_RTSP_CLIENT_CSEQ</td><td align="left">long</td><td align="left">다음에 사용될 RTSP CSeq</td></tr><tr><td align="left">CURLINFO_RTSP_CSEQ_RECV</td><td align="left">long</td><td align="left">RTSP CSeq 마지막 수신</td></tr><tr><td align="left">CURLINFO_RTSP_SERVER_CSEQ</td><td align="left">long</td><td align="left">다음에 예상되는 RTSP CSeq</td></tr><tr><td align="left">CURLINFO_RTSP_SESSION_ID</td><td align="left">char *</td><td align="left">RTSP 세션 ID</td></tr><tr><td align="left">CURLINFO_SCHEME</td><td align="left">char *</td><td align="left">연결에 사용된 체계</td></tr><tr><td align="left">CURLINFO_SIZE_DOWNLOAD</td><td align="left">double</td><td align="left">다운로드된 바이트 수</td></tr><tr><td align="left">CURLINFO_SIZE_UPLOAD</td><td align="left">double</td><td align="left">업로드된 바이트 수</td></tr><tr><td align="left">CURLINFO_SPEED_DOWNLOAD</td><td align="left">double</td><td align="left">평균 다운로드 속도</td></tr><tr><td align="left">CURLINFO_SPEED_UPLOAD</td><td align="left">double</td><td align="left">평균 업로드 속도</td></tr><tr><td align="left">CURLINFO_SSL_ENGINES</td><td align="left">struct curl_slist *</td><td align="left">OpenSSL 암호화 엔진 목록</td></tr><tr><td align="left">CURLINFO_SSL_VERIFYRESULT</td><td align="left">long</td><td align="left">인증서 확인 결과</td></tr><tr><td align="left">CURLINFO_STARTTRANSFER_TIME</td><td align="left">double</td><td align="left">시작부터 첫 번째 바이트가 수신될 때까지의 시간</td></tr><tr><td align="left">CURLINFO_STARTTRANSFER_TIME_T</td><td align="left">curl_off_t</td><td align="left">시작부터 첫 번째 바이트가 수신될 때까지의 시간(마이크로초)</td></tr><tr><td align="left">CURLINFO_TLS_SSL_PTR</td><td align="left">struct curl_slist *</td><td align="left">추가 처리에 사용할 수 있는 TLS 세션 정보</td></tr><tr><td align="left">CURLINFO_TOTAL_TIME</td><td align="left">double</td><td align="left">이전 전송의 총 시간</td></tr><tr><td align="left">CURLINFO_TOTAL_TIME_T</td><td align="left">curl_off_t</td><td align="left">이전 전송의 총 시간(마이크로초)</td></tr></tbody></table>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Post%20transfer%20info/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl 자세한 작업</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%9E%90%EC%84%B8%ED%95%9C%20%EC%9E%91%EC%97%85/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%9E%90%EC%84%B8%ED%95%9C%20%EC%9E%91%EC%97%85/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;자세한-작업&quot;&gt;&lt;a href=&quot;#자세한-작업&quot; class=&quot;headerlink&quot; title=&quot;자세한 작업&quot;&gt;&lt;/a&gt;자세한 작업&lt;/h1&gt;&lt;p&gt;좋습니다, 우리는 특정 전송에서 무엇이 잘못되었는지 파악하고 종종 왜 그렇게 할 수 있는지 또는 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="자세한-작업"><a href="#자세한-작업" class="headerlink" title="자세한 작업"></a>자세한 작업</h1><p>좋습니다, 우리는 특정 전송에서 무엇이 잘못되었는지 파악하고 종종 왜 그렇게 할 수 있는지 또는 현재 문제가 무엇인지 설명하기 때문에 사람이 읽을 수 있는 텍스트로 오류를 얻는 방법을 보여주었습니다.</p><p>최소한 libcurl 애플리케이션을 개발하거나 libcurl 자체를 디버깅하는 동안 모두가 알아야 하고 광범위하게 사용해야 하는 libcurl 애플리케이션을 작성할 때 다음 생명의 은인은 <code>CURLOPT_VERBOSE</code>를 사용하여 “상세 모드”를 활성화하는 것입니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURLcode ret = curl_easy_setopt(handle, CURLOPT_VERBOSE, <span class="number">1L</span>);</span><br></pre></td></tr></table></figure><p>libcurl이 verbose라고 하면 전송이 진행되는 동안 전송 관련 세부 정보 및 정보를 stderr에 언급합니다. 이것은 일이 실패하는 이유를 알아내고 libcurl이 다른 것을 요청할 때 정확히 무엇을 하는지 알아내는 것은 굉장합니다. <code>CURLOPT_STDERR</code>을 사용하여 stderr을 변경하여 출력을 다른 곳으로 리디렉션하거나 디버그 콜백을 사용하여 더 멋진 방식으로 더 많은 정보를 얻을 수 있습니다(나중 섹션에서 자세히 설명).</p><h2 id="모든-것을-추적"><a href="#모든-것을-추적" class="headerlink" title="모든 것을 추적"></a>모든 것을 추적</h2><p>Verbose는 확실히 괜찮지만 때로는 더 필요합니다. libcurl은 또한 자세한 정보 표시 모드가 수행하는 모든 작업을 표시하는 것 외에도 전송 및 수신된 모든 데이터를 전달하여 애플리케이션이 모든 것을 완벽하게 추적할 수 있도록 추적 콜백을 제공합니다.</p><p>추적 콜백으로 전달되고 수신된 데이터는 암호화되지 않은 형식으로 콜백에 제공되며, 이는 디버깅을 위해 네트워크에서 데이터를 캡처하는 것이 실용적이지 않을 때 TLS 또는 SSH 기반 프로토콜로 작업할 때 편리할 수 있습니다.</p><p><code>CURLOPT_DEBUGFUNCTION</code> 옵션을 설정할 때 여전히 <code>CURLOPT_VERBOSE</code>를 활성화해야 하지만 추적 콜백을 설정하면 libcurl은 내부 처리 대신 해당 콜백을 사용합니다.</p><p>추적 콜백은 다음과 같은 프로토타입과 일치해야 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_trace</span><span class="params">(CURL *handle, curl_infotype type, <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">void</span> *userp)</span></span>;</span><br></pre></td></tr></table></figure><p>핸들은 관련된 쉬운 핸들이고, 유형은 콜백에 전달된 특정 데이터(데이터 입/출력, 헤더 입/출력, TLS 데이터 입/출력 및 “텍스트”)를 설명하고, ptr은 크기가 바이트 수인 데이터를 가리킵니다. userp는 <code>CURLOPT_DEBUGDATA</code>로 설정한 사용자 지정 포인터입니다.</p><p>ptr이 가리키는 데이터는 0으로 종료되지 않지만 size 인수에 의해 지시된 크기와 정확히 일치합니다.</p><p>콜백은 0을 반환해야 하며 그렇지 않으면 libcurl은 이를 오류로 간주하고 전송을 중단합니다.</p><p>curl 웹사이트에서 영감을 얻을 수 있는 간단한 추적 기능이 포함된 <a href="https://curl.se/libcurl/c/debug.html" rel="external nofollow noopener noreferrer" target="_blank">debug.c</a>라는 예제를 호스팅합니다.</p><p><a href="https://curl.se/libcurl/c/CURLOPT_DEBUGFUNCTION.html" rel="external nofollow noopener noreferrer" target="_blank">CURLOPT_DEBUGFUNCTION 매뉴얼 페이지</a>에도 추가 세부 정보가 있습니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%9E%90%EC%84%B8%ED%95%9C%20%EC%9E%91%EC%97%85/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl CURL코드 리턴 코드</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20CURL%EC%BD%94%EB%93%9C%20%EB%A6%AC%ED%84%B4%20%EC%BD%94%EB%93%9C/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20CURL%EC%BD%94%EB%93%9C%20%EB%A6%AC%ED%84%B4%20%EC%BD%94%EB%93%9C/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CURL코드-리턴-코드&quot;&gt;&lt;a href=&quot;#CURL코드-리턴-코드&quot; class=&quot;headerlink&quot; title=&quot;CURL코드 리턴 코드&quot;&gt;&lt;/a&gt;CURL코드 리턴 코드&lt;/h1&gt;&lt;p&gt;많은 libcurl 함수는 CURLcode를 반환합니다
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="CURL코드-리턴-코드"><a href="#CURL코드-리턴-코드" class="headerlink" title="CURL코드 리턴 코드"></a>CURL코드 리턴 코드</h1><p>많은 libcurl 함수는 CURLcode를 반환합니다. 그것은 오류 코드에 대한 특별한 libcurl typedeffed 변수입니다. 모든 것이 훌륭하고 멋지면 <code>CURLE_OK</code>(값이 0임)를 반환하고 문제가 감지되면 0이 아닌 숫자를 반환합니다. 거의 100개의 <code>CURLcode</code> 오류가 사용 중이며, 모두 <code>curl/curl.h</code> 헤더 파일에서 찾을 수 있으며 libcurl-errors 매뉴얼 페이지에 문서화되어 있습니다.</p><p><code>curl_easy_strerror()</code> 함수를 사용하여 CURLcode를 사람이 읽을 수 있는 문자열로 변환할 수 있습니다. 그러나 이러한 오류는 UI 또는 최종 사용자에게 노출하기에 적합한 방식으로 표현되는 경우가 거의 없다는 점에 유의하십시오.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = curl_easy_strerror( error );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"libcurl said %s\n"</span>, str);</span><br></pre></td></tr></table></figure><p>오류가 발생했을 때 약간 더 나은 오류 텍스트를 얻는 또 다른 방법은 프로그램의 버퍼를 가리키도록 <code>CURLOPT_ERRORBUFFER</code> 옵션을 설정하는 것입니다. 그러면 libcurl은 오류를 반환하기 전에 관련 오류 메시지를 그곳에 저장합니다:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> error[CURL_ERROR_SIZE]; <span class="comment">/* needs to be at least this big */</span></span><br><span class="line">CURLcode ret = curl_easy_setopt(handle, CURLOPT_ERRORBUFFER, error);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20CURL%EC%BD%94%EB%93%9C%20%EB%A6%AC%ED%84%B4%20%EC%BD%94%EB%93%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl Cleanup</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Cleanup/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Cleanup/</guid>
      <pubDate>Wed, 09 Feb 2022 04:00:18 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Cleanup&quot;&gt;&lt;a href=&quot;#Cleanup&quot; class=&quot;headerlink&quot; title=&quot;Cleanup&quot;&gt;&lt;/a&gt;Cleanup&lt;/h1&gt;&lt;p&gt;이전 섹션에서 핸들을 설정하는 방법과 전송을 구동하는 방법에 대해 논의했습니다. 물론 모든
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Cleanup"><a href="#Cleanup" class="headerlink" title="Cleanup"></a>Cleanup</h1><p>이전 섹션에서 핸들을 설정하는 방법과 전송을 구동하는 방법에 대해 논의했습니다. 물론 모든 전송은 성공하거나 실패하는 어느 시점에서 끝납니다.</p><h2 id="멀티-API"><a href="#멀티-API" class="headerlink" title="멀티 API"></a>멀티 API</h2><p>다중 API로 단일 전송을 완료하면 <code>curl_multi_info_read()</code>를 사용하여 어떤 easy 핸들이 완료되었는지 정확히 식별하고 <code>curl_multi_remove_handle()</code>로 다중 핸들에서 해당 easy 핸들을 제거합니다.</p><p>더 이상 전송이 진행되지 않도록 다중 핸들에서 마지막 쉬운 핸들을 제거하면 다음과 같이 다중 핸들을 닫을 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_multi_cleanup( multi_handle );</span><br></pre></td></tr></table></figure><h2 id="쉬운-핸들"><a href="#쉬운-핸들" class="headerlink" title="쉬운 핸들"></a>쉬운 핸들</h2><p>쉬운 핸들이 목적을 달성하면 닫을 수 있습니다. 다른 전송을 수행하려는 경우 핸들을 닫고 새 핸들을 만드는 것보다 핸들을 재사용하는 것이 좋습니다.</p><p>쉬운 핸들로 다른 전송을 수행하지 않으려면 libcurl에 정리를 요청하기만 하면 됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_cleanup( easy_handle );</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Cleanup/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl Callback</title>
      <link>http://jung-max.github.io/2022/02/08/Linux-libcurl%20callback/</link>
      <guid>http://jung-max.github.io/2022/02/08/Linux-libcurl%20callback/</guid>
      <pubDate>Tue, 08 Feb 2022 06:27:44 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;콜백&quot;&gt;&lt;a href=&quot;#콜백&quot; class=&quot;headerlink&quot; title=&quot;콜백&quot;&gt;&lt;/a&gt;콜백&lt;/h1&gt;&lt;p&gt;libcurl 내의 많은 작업은 콜백을 사용하여 제어됩니다. 콜백은 libcurl이 특정 작업을 완료하기 위해 특정 시점에서 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="콜백"><a href="#콜백" class="headerlink" title="콜백"></a>콜백</h1><p>libcurl 내의 많은 작업은 콜백을 사용하여 제어됩니다. 콜백은 libcurl이 특정 작업을 완료하기 위해 특정 시점에서 호출하는 libcurl에 제공되는 함수 포인터입니다.</p><p>각 콜백에는 문서화된 특정 목적이 있으며 올바른 인수를 수락하고 문서화된 반환 코드와 반환 값을 반환하여 libcurl이 원하는 방식으로 수행할 수 있도록 정확한 함수 프로토타입으로 작성해야 합니다.</p><p>각 콜백 옵션에는 연결된 “사용자 포인터”를 설정하는 동반 옵션도 있습니다. 이 사용자 포인터는 libcurl이 만지거나 신경 쓰지 않고 콜백에 대한 인수로 전달하는 포인터입니다. 이를 통해 예를 들어 로컬 데이터에 대한 포인터를 콜백 함수까지 전달할 수 있습니다.</p><p>libcurl 함수 문서에 명시적으로 언급되지 않은 한 libcurl 콜백 내에서 libcurl 함수를 호출하는 것은 불법입니다.</p><h2 id="데이터-쓰기"><a href="#데이터-쓰기" class="headerlink" title="데이터 쓰기"></a>데이터 쓰기</h2><p>쓰기 콜백은 <code>CURLOPT_WRITEFUNCTION</code>으로 설정됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_WRITEFUNCTION, write_callback);</span><br></pre></td></tr></table></figure><p>write_callback 함수는 다음 프로토타입과 일치해야 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">write_callback</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nmemb, <span class="keyword">void</span> *userdata)</span></span>;</span><br></pre></td></tr></table></figure><p>이 콜백 함수는 저장해야 하는 데이터가 수신되는 즉시 libcurl에 의해 호출됩니다. ptr은 전달된 데이터를 가리키며 해당 데이터의 크기는 nmemb와 곱한 크기입니다.</p><p>이 콜백이 설정되지 않은 경우 libcurl은 기본적으로 ‘fwrite’를 대신 사용합니다.</p><p>쓰기 콜백은 모든 호출에서 가능한 한 많은 데이터를 전달하지만 어떤 가정도 해서는 안 됩니다. 1바이트일 수도 있고 수천 바이트일 수도 있습니다. 쓰기 콜백에 전달될 본문 데이터의 최대 양은 curl.h 헤더 파일 <code>CURL_MAX_WRITE_SIZE</code>에 정의되어 있습니다(일반적인 기본값은 16KB). 헤더 데이터가 쓰기 콜백으로 전달되도록 이 전송에 대해 <code>CURLOPT_HEADER</code>가 활성화된 경우 전달된 헤더 데이터의 최대 <code>CURL_MAX_HTTP_HEADER</code> 바이트를 얻을 수 있습니다. 이것은 일반적으로 100KB를 의미합니다.</p><p>이 함수는 전송된 파일이 비어 있는 경우 0바이트 데이터로 호출될 수 있습니다.</p><p>이 함수에 전달된 데이터는 0으로 종료되지 않습니다. 예를 들어, printf의 <code>%s</code> 연산자를 사용하여 내용을 표시하거나 strcpy를 사용하여 복사할 수 없습니다.</p><p>이 콜백은 실제로 처리된 바이트 수를 반환해야 합니다. 해당 번호가 콜백 함수에 전달된 번호와 다르면 라이브러리에 오류 상태를 알립니다. 이로 인해 전송이 중단되고 사용된 libcurl 함수는 <code>CURLE_WRITE_ERROR</code>를 반환합니다.</p><p>userdata 인수의 콜백에 전달된 사용자 포인터는 <code>CURLOPT_WRITEDATA</code>로 설정됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_WRITEDATA, custom_pointer);</span><br></pre></td></tr></table></figure><h3 id="메모리에-저장"><a href="#메모리에-저장" class="headerlink" title="메모리에 저장"></a>메모리에 저장</h3><p>인기 있는 요구는 검색된 응답을 메모리에 저장하는 것이며 위에서 설명한 콜백이 이를 지원합니다. 이 작업을 수행할 때 응답이 잠재적으로 엄청날 수 있으므로 주의하십시오.</p><p>다음과 유사한 방식으로 콜백을 구현합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">response</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *memory;</span><br><span class="line">  <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">mem_cb(<span class="keyword">void</span> *contents, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nmemb, <span class="keyword">void</span> *userp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> realsize = <span class="built_in">size</span> * nmemb;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">repsonse</span> *<span class="title">mem</span> = (<span class="title">struct</span> <span class="title">response</span> *)<span class="title">userp</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> *ptr = <span class="built_in">realloc</span>(mem-&gt;memory, mem-&gt;<span class="built_in">size</span> + realsize + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(!ptr) &#123;</span><br><span class="line">    <span class="comment">/* out of memory! */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"not enough memory (realloc returned NULL)\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mem-&gt;memory = ptr;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;(mem-&gt;memory[mem-&gt;<span class="built_in">size</span>]), contents, realsize);</span><br><span class="line">  mem-&gt;<span class="built_in">size</span> += realsize;</span><br><span class="line">  mem-&gt;memory[mem-&gt;<span class="built_in">size</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> realsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">response</span> <span class="title">chunk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* send all data to this function  */</span></span><br><span class="line">  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, mem_cb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* we pass our 'chunk' to the callback function */</span></span><br><span class="line">  curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (<span class="keyword">void</span> *)&amp;chunk);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="데이터-읽기"><a href="#데이터-읽기" class="headerlink" title="데이터 읽기"></a>데이터 읽기</h2><p>읽기 콜백은 <code>CURLOPT_READFUNCTION</code>으로 설정됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_READFUNCTION, read_callback);</span><br></pre></td></tr></table></figure><p>read`_callback 함수는 다음 프로토타입과 일치해야 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">read_callback</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">buffer</span>, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nitems, <span class="keyword">void</span> *stream)</span></span>;</span><br></pre></td></tr></table></figure><p>이 콜백 함수는 서버에 데이터를 보내려고 할 때 libcurl에 의해 호출됩니다. 이것은 데이터를 업로드하거나 서버로 보내도록 설정한 전송입니다. 이 콜백은 모든 데이터가 전달되거나 전송이 실패할 때까지 계속해서 호출됩니다.</p><p>스트림 포인터는 <code>CURLOPT_READDATA</code>를 사용하여 개인 데이터 세트를 가리킵니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_READDATA, custom_pointer);</span><br></pre></td></tr></table></figure><p>이 콜백이 설정되지 않은 경우 libcurl은 기본적으로 ‘fread’를 대신 사용합니다.</p><p>포인터 버퍼가 가리키는 데이터 영역은 함수에 의해 nitems 수를 곱한 최대 크기로 채워져야 합니다. 그런 다음 콜백은 해당 메모리 영역에 저장된 바이트 수를 반환하거나 데이터 끝에 도달한 경우 0을 반환해야 합니다. 콜백은 또한 libcurl이 즉시 실패를 반환하거나 특정 전송을 일시 중지하도록 하는 몇 가지 “마법” 반환 코드를 반환할 수 있습니다. 자세한 내용은 <a href="https://curl.se/libcurl/c/CURLOPT_READFUNCTION.html" rel="external nofollow noopener noreferrer" target="_blank">CURLOPT_READFUNCTION 매뉴얼 페이지</a>를 참조하십시오.</p><h2 id="진행-정보"><a href="#진행-정보" class="headerlink" title="진행 정보"></a>진행 정보</h2><p>진행 콜백은 전송의 전체 수명 동안 각 전송에 대해 정기적으로 반복적으로 호출되는 것입니다. 이전 콜백은 <code>CURLOPT_PROGRESSFUNCTION</code>으로 설정되었지만 최신 콜백은 <code>CURLOPT_XFERINFOFUNCTION</code>으로 설정되었습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_XFERINFOFUNCTION, xfer_callback);</span><br></pre></td></tr></table></figure><p><code>xfer_callback</code> 함수는 다음 프로토타입과 일치해야 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">xfer_callback</span><span class="params">(<span class="keyword">void</span> *clientp, <span class="keyword">curl_off_t</span> dltotal, <span class="keyword">curl_off_t</span> dlnow,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">curl_off_t</span> ultotal, <span class="keyword">curl_off_t</span> ulnow)</span></span>;</span><br></pre></td></tr></table></figure><p>이 옵션이 설정되고 <code>CURLOPT_NOPROGRESS</code>가 0(영)으로 설정되면 이 콜백 함수는 libcurl에 의해 빈번한 간격으로 호출됩니다. 데이터가 전송되는 동안에는 자주 호출되며 아무 것도 전송되지 않는 경우와 같이 느린 시간에는 초당 약 1회의 호출로 느려질 수 있습니다.</p><p><strong>clientp</strong> 포인터는 <code>CURLOPT_XFERINFODATA</code>를 사용하여 개인 데이터 세트를 가리킵니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_XFERINFODATA, custom_pointer);</span><br></pre></td></tr></table></figure><p>콜백은 libcurl이 전송하고 전송한 데이터의 양을 바이트 수로 알려줍니다.</p><ul><li><strong>dltotal</strong>은 libcurl이 이 전송에서 다운로드할 것으로 예상하는 총 바이트 수입니다.</li><li><strong>dlnow</strong>는 지금까지 다운로드한 바이트 수입니다.</li><li><strong>ultotal</strong>은 libcurl이 이 전송에서 업로드할 것으로 예상하는 총 바이트 수입니다.</li><li><strong>ulnow</strong>는 지금까지 업로드된 바이트 수입니다.</li></ul><p>콜백에 전달된 알 수 없거나 사용되지 않은 인수 값은 0으로 설정됩니다(예: 데이터만 다운로드하는 경우 업로드 크기는 0으로 유지됨). 여러 번 콜백은 데이터 크기를 알기 전에 먼저 한 번 이상 호출되므로 이를 처리하도록 프로그램을 만들어야 합니다.</p><p>이 콜백에서 0이 아닌 값을 반환하면 libcurl이 전송을 중단하고 <code>CURLE_ABORTED_BY_CALLBACK</code>을 반환합니다.</p><p>다중 인터페이스로 데이터를 전송하는 경우 전송을 수행하는 적절한 libcurl 함수를 호출하지 않는 한 유휴 기간 동안 이 함수가 호출되지 않습니다.</p><p>(더 이상 사용되지 않는 콜백 <code>CURLOPT_PROGRESSFUNCTION</code>은 동일하게 작동했지만 <code>curl_off_t</code> 유형의 인수를 사용하는 대신 <code>double</code>을 사용했습니다.)</p><h2 id="헤더-데이터"><a href="#헤더-데이터" class="headerlink" title="헤더 데이터"></a>헤더 데이터</h2><p>헤더 콜백은 <code>CURLOPT_HEADERFUNCTION</code>으로 설정됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_HEADERFUNCTION, header_callback);</span><br></pre></td></tr></table></figure><p><code>header_callback</code> 함수는 다음 프로토타입과 일치해야 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">header_callback</span><span class="params">(<span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nmemb, <span class="keyword">void</span> *userdata)</span></span>;</span><br></pre></td></tr></table></figure><p>이 콜백 함수는 헤더가 수신되는 즉시 libcurl에 의해 호출됩니다. ptr은 전달된 데이터를 가리키며 해당 데이터의 크기는 nmemb와 곱한 크기입니다. libcurl은 헤더를 버퍼링하고 “전체” 헤더만 이 콜백에 하나씩 전달합니다.</p><p>이 함수에 전달된 데이터는 0으로 종료되지 않습니다! 예를 들어, printf의 <code>%s</code> 연산자를 사용하여 내용을 표시하거나 strcpy를 사용하여 복사할 수 없습니다.</p><p>이 콜백은 실제로 처리된 바이트 수를 반환해야 합니다. 해당 번호가 콜백 함수에 전달된 번호와 다르면 라이브러리에 오류 조건을 알립니다. 이로 인해 전송이 중단되고 사용된 libcurl 함수는 <code>CURLE_WRITE_ERROR</code>를 반환합니다.</p><p>userdata 인수의 콜백에 전달된 사용자 포인터는 <code>CURLOPT_HEADERDATA</code>로 설정됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_HEADERDATA, custom_pointer);</span><br></pre></td></tr></table></figure><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>디버그 콜백은 <code>CURLOPT_DEBUGFUNCTION</code>으로 설정됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_DEBUGFUNCTION, debug_callback);</span><br></pre></td></tr></table></figure><p><code>debug_callback</code> 함수는 다음 프로토타입과 일치해야 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">debug_callback</span><span class="params">(CURL *handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                   curl_infotype type,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">char</span> *data,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">void</span> *userdata)</span></span>;</span><br></pre></td></tr></table></figure><p>이 콜백 함수는 라이브러리의 기본 상세 출력 함수를 대체하며 모든 디버그 및 추적 메시지에 대해 호출되어 애플리케이션이 무슨 일이 일어나고 있는지 이해하도록 돕습니다. type 인수는 헤더, 데이터 또는 SSL 데이터와 같이 제공되는 데이터의 종류와 흐름 방향을 설명합니다.</p><p>이 콜백의 일반적인 용도는 libcurl이 보내고 받는 모든 데이터의 전체 추적을 가져오는 것입니다. 이 콜백으로 전송되는 데이터는 예를 들어 HTTPS 또는 기타 암호화된 프로토콜이 사용되는 경우에도 항상 암호화되지 않은 버전입니다.<br>이 콜백은 0을 반환하거나 오류 코드와 함께 전송을 중지해야 합니다.</p><p>userdata 인수의 콜백에 전달된 사용자 포인터는 <code>CURLOPT_DEBUGDATA</code>로 설정됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_DEBUGDATA, custom_pointer);</span><br></pre></td></tr></table></figure><h2 id="sockopt"><a href="#sockopt" class="headerlink" title="sockopt"></a>sockopt</h2><p>sockopt 콜백은 <code>CURLOPT_SOCKOPTFUNCTION</code>으로 설정됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_SOCKOPTFUNCTION, sockopt_callback);</span><br></pre></td></tr></table></figure><p><code>sockopt_callback</code> 함수는 다음 프로토타입과 일치해야 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockopt_callback</span><span class="params">(<span class="keyword">void</span> *clientp,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">curl_socket_t</span> curlfd,</span></span></span><br><span class="line"><span class="function"><span class="params">                     curlsocktype purpose)</span></span>;</span><br></pre></td></tr></table></figure><p>이 콜백 함수는 새 소켓이 생성되었지만 연결 호출 전에 응용 프로그램이 특정 소켓 옵션을 변경할 수 있도록 libcurl에 의해 호출됩니다.</p><p>clientp 포인터는 <code>CURLOPT_SOCKOPTDATA</code>를 사용하여 개인 데이터 세트를 가리킵니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_SOCKOPTDATA, custom_pointer);</span><br></pre></td></tr></table></figure><p>이 콜백은 다음을 반환해야 합니다.</p><ul><li><strong>CURL_SOCKOPT_OK</strong> 성공</li><li>libcurl에 복구할 수 없는 오류를 알리는 <strong>CURL_SOCKOPT_ERROR</strong></li><li><strong>CURL_SOCKOPT_ALREADY_CONNECTED</strong>는 성공을 알리지만 소켓이 실제로 이미 대상에 연결되어 있음을 나타냅니다.</li></ul><h2 id="SSL-context"><a href="#SSL-context" class="headerlink" title="SSL context"></a>SSL context</h2><p>libcurl은 <code>CURLOPT_SSL_CTX_FUNCTION</code>이라는 특수한 TLS 관련 콜백을 제공합니다. 이 옵션은 OpenSSL, wolfSSL 또는 mbedTLS로 구동되는 libcurl에서만 작동하며 libcurl이 다른 TLS 백엔드로 빌드된 경우에는 아무 작업도 수행하지 않습니다.</p><p>이 콜백은 응용 프로그램이 TLS 초기화 동작을 수정할 수 있는 마지막 기회를 제공하기 위해 다른 모든 TLS 관련 옵션을 처리한 후 TLS 연결 초기화 직전에 libcurl에 의해 호출됩니다. 두 번째 인수에서 콜백에 전달된 <code>ssl_ctx</code> 매개변수는 실제로 OpenSSL 또는 wolfSSL의 경우 SSL 라이브러리의 <code>SSL_CTX</code>에 대한 포인터이고 mbedTLS의 경우 <code>mbedtls_ssl_config</code>에 대한 포인터입니다. 콜백에서 오류가 반환되면 연결 설정을 시도하지 않고 작업에서 콜백의 오류 코드를 반환합니다. <code>CURLOPT_SSL_CTX_DATA</code> 옵션으로 userptr 인수를 설정합니다.</p><p>이 함수는 TLS 협상 중에 서버에 대한 모든 새 연결에서 호출됩니다. TLS 컨텍스트는 매번 새로 초기화된 개체를 가리킵니다.</p><h2 id="Seek-and-ioctl"><a href="#Seek-and-ioctl" class="headerlink" title="Seek and ioctl"></a>Seek and ioctl</h2><p>이 콜백은 <code>CURLOPT_SEEKFUNCTION</code>으로 설정됩니다.</p><p>콜백은 입력 스트림의 특정 위치를 찾기 위해 libcurl에 의해 호출되며 재개된 업로드에서 파일을 빨리 전달하는 데 사용할 수 있습니다(일반 읽기 기능/콜백으로 업로드된 모든 바이트를 읽는 대신). 데이터가 이미 서버로 전송되어 다시 전송해야 할 때 스트림을 되감기 위해 호출되기도 합니다. 이는 다중 패스 인증 방법으로 HTTP PUT 또는 POST를 수행할 때 또는 기존 HTTP 연결이 너무 늦게 재사용되어 서버가 연결을 닫을 때 발생할 수 있습니다. 이 함수는 fseek(3) 또는 lseek(3)처럼 작동해야 하며 libcurl이 현재 <code>SEEK_SET</code>만 전달하지만 <code>SEEK_SET</code>, <code>SEEK_CUR</code> 또는 <code>SEEK_END</code>를 원본에 대한 인수로 가져옵니다.</p><p>콜백으로 전송된 사용자 정의 userp는 <code>CURLOPT_SEEKDATA</code>로 설정한 포인터입니다.</p><p>콜백 함수는 성공 시 <code>CURL_SEEKFUNC_OK</code>를 반환해야 하고, 업로드 작업이 실패하도록 하려면 <code>CURL_SEEKFUNC_FAIL</code>을 반환해야 하며, 탐색이 실패한 동안 가능한 경우 libcurl이 자유롭게 문제를 해결할 수 있음을 나타내려면 <code>CURL_SEEKFUNC_CANTSEEK</code>를 반환해야 합니다. 후자는 때때로 입력 또는 이와 유사한 것을 대신 읽어서 수행할 수 있습니다.</p><p>입력 인수를 fseek(3) 또는 lseek(3)에 직접 전달하는 경우 offset의 데이터 유형은 많은 시스템에서 <code>curl_off_t</code>에 대해 정의된 것과 동일하지 않습니다.</p><h2 id="네트워크-데이터-변환"><a href="#네트워크-데이터-변환" class="headerlink" title="네트워크 데이터 변환"></a>네트워크 데이터 변환</h2><h3 id="네트워크-콜백과의-변환"><a href="#네트워크-콜백과의-변환" class="headerlink" title="네트워크 콜백과의 변환"></a>네트워크 콜백과의 변환</h3><p>비 ASCII 플랫폼의 경우 <code>CURLOPT_CONV_FROM_NETWORK_FUNCTION</code>이 제공됩니다. 이 기능은 네트워크 인코딩에서 호스트 인코딩으로 변환되어야 합니다.</p><p><code>CURLOPT_CONV_TO_NETWORK_FUNCTION</code>은 호스트 인코딩에서 네트워크 인코딩으로 변환해야 합니다. 네트워크를 통해 명령이나 ASCII 데이터를 보낼 때 사용합니다.</p><h3 id="UTF-8-콜백에서-변환"><a href="#UTF-8-콜백에서-변환" class="headerlink" title="UTF-8 콜백에서 변환"></a>UTF-8 콜백에서 변환</h3><p><code>CURLOPT_CONV_FROM_UTF8_FUNCTION</code>은 UTF-8 인코딩에서 호스트 인코딩으로 변환해야 합니다. SSL 처리에만 필요합니다.</p><h2 id="Opensocket-and-closesocket"><a href="#Opensocket-and-closesocket" class="headerlink" title="Opensocket and closesocket"></a>Opensocket and closesocket</h2><p>때때로 libcurl이 작업에 사용할 소켓을 보다 정확하게 제어하기를 원하는 상황이 발생합니다. libcurl은 socket()에 대한 libcurl의 자체 호출과 동일한 파일 설명자의 후속 <code>close()</code>를 대체하는 이 콜백 쌍을 제공합니다.</p><h3 id="파일-설명자-제공"><a href="#파일-설명자-제공" class="headerlink" title="파일 설명자 제공"></a>파일 설명자 제공</h3><p><code>CURLOPT_OPENSOCKETFUNCTION</code> 콜백을 설정하여 libcurl이 사용할 파일 설명자를 반환하는 사용자 정의 함수를 제공할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_OPENSOCKETFUNCTION, opensocket_callback);</span><br></pre></td></tr></table></figure><p><code>opensocket_callback</code> 함수는 다음 프로토타입과 일치해야 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">curl_socket_t</span> <span class="title">opensocket_callback</span><span class="params">(<span class="keyword">void</span> *clientp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  curlsocktype purpose,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  struct curl_sockaddr *address)</span></span>;</span><br></pre></td></tr></table></figure><p>콜백은 <code>CURLOPT_OPENSOCKETDATA</code>로 설정한 단순히 불투명한 포인터인 clientp를 첫 번째 인수로 가져옵니다.</p><p>다른 두 인수는 소켓을 사용할 목적과 주소를 식별하는 데이터를 전달합니다. 목적은 소켓이 생성되는 상황을 식별하는 <code>CURLSOCKTYPE_IPCXN</code> 또는 <code>CURLSOCKTYPE_ACCEPT</code> 값을 가진 typedef입니다. “수락” 경우는 FTP 활성 모드가 사용될 때 libcurl이 들어오는 FTP 연결을 수락하는 데 사용되며 libcurl이 자체 나가는 연결을 위한 소켓을 만드는 다른 모든 경우에는 IPCXN 값이 전달됩니다.</p><p>주소 포인터는 이 소켓이 생성되는 네트워크 대상의 IP 주소를 설명하는 <code>curl_sockaddr 구조체</code>를 가리킵니다. 예를 들어 콜백은 이 정보를 사용하여 특정 주소 또는 주소 범위를 화이트리스트 또는 블랙리스트에 추가할 수 있습니다.</p><p>어떤 종류의 네트워크 필터 또는 변환 계층을 제공하려는 경우 socketopen 콜백은 해당 구조체의 대상 주소를 수정할 수도 있습니다.</p><p>콜백은 파일 설명자 또는 <code>CURL_SOCKET_BAD</code>를 반환해야 합니다. 그러면 libcurl 내에서 복구할 수 없는 오류가 발생하고 결국에는 수행 함수에서 <code>CURLE_COULDNT_CONNECT</code>를 반환합니다.</p><p>이미 서버에 연결된 파일 설명자를 반환하려면 <a href="#sockopt">sockopt 콜백</a>도 설정하고 올바른 반환 값을 반환하는지 확인해야 합니다.</p><p><code>curl_sockaddress</code> 구조체는 다음과 같습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">curl_sockaddr</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> family;</span><br><span class="line">  <span class="keyword">int</span> socktype;</span><br><span class="line">  <span class="keyword">int</span> protocol;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> addrlen;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> <span class="title">addr</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Socket-close-callback"><a href="#Socket-close-callback" class="headerlink" title="Socket close callback"></a>Socket close callback</h3><p>열린 소켓에 대한 해당 콜백은 물론 닫기 소켓입니다. 일반적으로 파일 설명자를 제공하는 사용자 지정 방법을 제공할 때 자체 정리 버전도 제공하려고 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_CLOSESOCKETFUNCTION, closesocket_callback);</span><br></pre></td></tr></table></figure><p><code>closesocket_callback</code> 함수는 다음 프로토타입과 일치해야 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closesocket_callback</span><span class="params">(<span class="keyword">void</span> *clientp, <span class="keyword">curl_socket_t</span> item)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="SSH-key"><a href="#SSH-key" class="headerlink" title="SSH key"></a>SSH key</h2><p>이 콜백은 <code>CURLOPT_SSH_KEYFUNCTION</code>으로 설정됩니다.</p><p>이것은 known_host 매칭이 완료되었을 때 호출되어 애플리케이션이 libcurl을 어떻게 처리할지 결정할 수 있도록 합니다. 콜백은 <code>CURLOPT_SSH_KNOWNHOSTS</code>도 설정된 경우에만 호출됩니다.</p><p>콜백에 대한 인수에는 이전 키와 새 키가 있으며 콜백은 libcurl에게 작동 방법을 알려주는 반환 코드를 반환할 것으로 예상됩니다.</p><ul><li><code>CURLKHSTAT_FINE_REPLACE</code> - 새 호스트 + 키가 수락되고 libcurl은 연결을 계속하기 전에 이전 호스트 + 키를 known_hosts 파일로 바꿉니다. 이것은 또한 새로운 호스트+키 콤보가 이미 존재하지 않는 경우 메모리에 보관된 known_host 풀에 추가됩니다. 파일에 데이터를 추가하는 것은 파일을 새 복사본으로 완전히 교체하여 수행되므로 파일의 권한이 이를 허용해야 합니다.</li><li><code>CURLKHSTAT_FINE_ADD_TO_FILE</code> - 호스트+키가 수락되고 libcurl은 연결을 계속하기 전에 이것을 known_hosts 파일에 추가합니다. 이것은 또한 이미 존재하지 않는 경우 메모리에 보관된 known_host 풀에 host+key 콤보를 추가합니다. 파일에 데이터를 추가하는 것은 파일을 새 복사본으로 완전히 교체하여 수행되므로 파일의 권한이 이를 허용해야 합니다.</li><li><code>CURLKHSTAT_FINE</code> - 호스트 + 키가 수락되면 libcurl이 연결을 계속합니다. 이것은 또한 이미 존재하지 않는 경우 메모리에 보관된 known_host 풀에 host+key 콤보를 추가합니다.</li><li><code>CURLKHSTAT_REJECT</code> - 호스트 + 키가 거부되었습니다. libcurl은 계속하기 위해 연결을 거부하고 닫힙니다.</li><li><code>CURLKHSTAT_DEFER</code> - 호스트 + 키가 거부되지만 SSH 연결은 활성 상태로 유지되도록 요청됩니다. 이 기능은 앱이 어떻게든 호스트+키 상황으로 돌아가서 조치를 취한 다음 처음부터 다시 설정하는 오버헤드 없이 재시도하려고 할 때 사용할 수 있습니다.</li></ul><h2 id="RTSP-interleaved-data"><a href="#RTSP-interleaved-data" class="headerlink" title="RTSP interleaved data"></a>RTSP interleaved data</h2><p><code>CURLOPT_INTERLEAVEFUNCTION</code> 옵션이 있는 콜백.</p><p>이 콜백은 RTSP 전송을 수행할 때 인터리브된 RTP 데이터를 수신하자마자 libcurl에 의해 호출됩니다. 각 $ 블록에 대해 호출되므로 정확히 하나의 상위 계층 프로토콜 단위(예: 하나의 RTP 패킷)를 포함합니다. libcurl은 인터리브 처리된 헤더와 각 호출에 대해 포함된 데이터를 씁니다. 첫 번째 바이트는 항상 ASCII 달러 기호입니다. 달러 기호 다음에 1바이트 채널 식별자가 오고 네트워크 바이트 순서로 2바이트 정수 길이가 옵니다. RTP 인터리빙의 작동 방식에 대한 자세한 내용은 RFC2326 섹션 10.12를 참조하세요. 설정하지 않거나 NULL로 설정하면 curl은 기본 쓰기 기능을 사용합니다.</p><p><code>CURLOPT_INTERLEAVEDATA</code> 포인터는 콜백의 userdata 인수로 전달됩니다.</p><h2 id="FTP-와일드-카드-일치"><a href="#FTP-와일드-카드-일치" class="headerlink" title="FTP 와일드 카드 일치"></a>FTP 와일드 카드 일치</h2><p>libcurl은 FTP 와일드 카드 일치를 지원합니다. <code>CURLOPT_WILDCARDMATCH</code>를 <code>1L</code>로 설정한 다음 URL의 파일 이름 부분에 “와일드 카드 패턴”을 사용하여 이 기능을 사용합니다.</p><h3 id="와일드-카드-패턴"><a href="#와일드-카드-패턴" class="headerlink" title="와일드 카드 패턴"></a>와일드 카드 패턴</h3><p>기본 libcurl 와일드 카드 일치 기능은 다음을 지원합니다.</p><p><code>*</code> - 별표</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp://example.com/some/path/*.txt</span><br></pre></td></tr></table></figure><p><code>some/path</code> 디렉토리의 모든 txt 파일을 일치시키려면. 동일한 패턴 문자열 내에서는 두 개의 별표만 사용할 수 있습니다.</p><p><code>?</code> - 물음표</p><p>물음표는 모든(정확히 하나의) 문자와 일치합니다. <code>photo1.jpeg</code> 및 <code>photo7.jpeg</code>라는 파일이 있는 경우 이 패턴은 다음과 일치할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp://example.com/some/path/photo?.jpeg</span><br></pre></td></tr></table></figure><p><code>[</code> - BRACKET 표현<br>왼쪽 대괄호는 대괄호 표현식을 엽니다. 대괄호 식에서 물음표와 별표는 특별한 의미가 없습니다. 각 대괄호 표현식은 오른쪽 대괄호(<code>]</code>)로 끝나고 정확히 한 문자와 일치합니다. 몇 가지 예는 다음과 같습니다.</p><p><code>[a-zA-Z0-9]</code> 또는 <code>[f-gF-G]</code> - 문자 간격</p><p><code>[abc]</code> - 문자 열거</p><p><code>[^abc]</code> 또는 <code>[!abc]</code> - 부정</p><p><code>[[:name:]]</code> 클래스 표현식입니다. 지원되는 클래스는 alnum, lower, space, alpha, digit, print, upper, blank, graph, xdigit입니다.</p><p><code>[][-!^]</code> - 특수 케이스, <code>\-</code>, <code>]</code>, <code>[</code>, <code>!</code> 또는 <code>^</code>.</p><p><code>[\\[\\]\\\\]</code> - 이스케이프 구문. <code>[</code>, <code>]</code> 또는 <code>\\</code>와 일치합니다.</p><p>위의 규칙을 사용하여 파일 이름 패턴을 구성할 수 있습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ftp://example.com/some/path/[a-z[:upper:]\\\\].jpeg</span><br></pre></td></tr></table></figure><h3 id="FTP-chunk-콜백"><a href="#FTP-chunk-콜백" class="headerlink" title="FTP chunk 콜백"></a>FTP chunk 콜백</h3><p>FTP 와일드 카드 일치가 사용되면 일치하는 파일에 대한 전송이 시작되기 전에 <code>CURLOPT_CHUNK_BGN_FUNCTION</code> 콜백이 호출됩니다.</p><p>콜백은 다음 반환 코드 중 하나를 반환하도록 선택하여 libcurl에게 파일로 무엇을 할 것인지 알릴 수 있습니다.</p><ul><li><code>CURL_CHUNK_BGN_FUNC_OK</code> 파일 전송</li><li><code>CURL_CHUNK_BGN_FUNC_SKIP</code></li><li><code>CURL_CHUNK_BGN_FUNC_FAIL</code> 오류로 인해  중지</li><li>일치하는 파일이 전송되거나 건너뛴 후 <code>CURLOPT_CHUNK_END_FUNCTION</code> 콜백이 호출됩니다.</li></ul><p>끝 chunk 콜백은 성공 또는 오류만 반환할 수 있습니다.</p><h3 id="FTP-매칭-콜백"><a href="#FTP-매칭-콜백" class="headerlink" title="FTP 매칭 콜백"></a>FTP 매칭 콜백</h3><p>기본 패턴 일치 기능이 마음에 들지 않으면 <code>CURLOPT_FNMATCH_FUNCTION</code> 옵션을 대체 기능으로 설정하여 고유한 대체 기능을 제공할 수 있습니다.</p><h2 id="Resolver-시작"><a href="#Resolver-시작" class="headerlink" title="Resolver 시작"></a>Resolver 시작</h2><p><code>CURLOPT_RESOLVER_START_FUNCTION</code>으로 설정된 이 콜백 함수는 새로운 확인 요청이 시작되기 전에 매번 libcurl에 의해 호출되며 어떤 <code>CURL *</code> 핸들이 확인 대상인지 지정합니다.</p><h2 id="트레일러-보내기"><a href="#트레일러-보내기" class="headerlink" title="트레일러 보내기"></a>트레일러 보내기</h2><p>“Trailers”은 전송이 끝날 때 헤더를 전달할 수 있는 HTTP/1 기능입니다. 이 콜백은 업로드가 완료된 후 컬이 있는 트레일러를 보내고 싶을 때 사용됩니다. 청크 인코딩된 POST 형식의 업로드입니다.</p><p><code>CURLOPT_TRAILERFUNCTION</code>으로 설정된 콜백이 호출되고 함수는 목록에 헤더를 추가할 수 있습니다. 하나 또는 여러 개. 완료되면 libcurl은 이를 서버에 트레일러로 보냅니다.</p><h2 id="HSTS"><a href="#HSTS" class="headerlink" title="HSTS"></a>HSTS</h2><p>HSTS, HTTP Strict Transport Security의 경우 libcurl은 할당이 규칙에 대한 저장소를 구현할 수 있도록 두 개의 콜백을 제공합니다. 그런 다음 콜백은 영구 저장소에서 HSTS 정책을 읽고/쓰도록 설정됩니다.</p><p><code>CURLOPT_HSTSREADFUNCTION</code>을 사용하여 응용 프로그램은 libcurl에 있는 HSTS 데이터를 읽는 데 사용하는 기능을 제공합니다. <code>CURLOPT_HSTSWRITEFUNCTION</code>은 libcurl이 데이터를 쓰기 위해 호출하는 해당 함수입니다.</p><h2 id="Prereq"><a href="#Prereq" class="headerlink" title="Prereq"></a>Prereq</h2><p>여기서 “Prereq”는 요청이 발행되기 직전을 의미합니다. 바로 이 콜백이 호출되는 순간입니다.</p><p><code>CURLOPT_PREREQFUNCTION</code>으로 함수를 설정하면 호출되고 인수에 IP 주소와 포트 번호가 전달됩니다. 이를 통해 애플리케이션은 시작 직전에 전송에 대해 알 수 있으며 원할 경우 이 특정 전송을 취소할 수도 있습니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/08/Linux-libcurl%20callback/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl Easy handle</title>
      <link>http://jung-max.github.io/2022/02/08/Linux-libcurl%20Easy%20handle/</link>
      <guid>http://jung-max.github.io/2022/02/08/Linux-libcurl%20Easy%20handle/</guid>
      <pubDate>Tue, 08 Feb 2022 04:04:09 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Easy-handle&quot;&gt;&lt;a href=&quot;#Easy-handle&quot; class=&quot;headerlink&quot; title=&quot;Easy handle&quot;&gt;&lt;/a&gt;Easy handle&lt;/h1&gt;&lt;p&gt;먼저 전송에 대한 핸들인 “이지 핸들”을 생성합니다.&lt;/p&gt;

        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Easy-handle"><a href="#Easy-handle" class="headerlink" title="Easy handle"></a>Easy handle</h1><p>먼저 전송에 대한 핸들인 “이지 핸들”을 생성합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURL *easy_handle = curl_easy_init();</span><br></pre></td></tr></table></figure><p>그런 다음 해당 핸들에서 옵션을 설정하여 예정된 전송을 제어합니다. 이 예에서는 URL을 설정합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set URL to operate on */</span></span><br><span class="line">res = curl_easy_setopt(easy_handle, CURLOPT_URL, <span class="string">"http://example.com/"</span>);</span><br></pre></td></tr></table></figure><p><code>curl_easy_setopt()</code>가 <code>CURLE_OK</code>를 반환하면 옵션이 제대로 저장되었음을 알 수 있습니다.</p><p>쉬운 핸들을 만들고 옵션을 설정해도 전송이 발생하지 않으며 일반적으로 전송이 실제로 발생했을 때 나중에 사용하고자 하는 libcurl을 저장하는 것 외에는 더 많은 일이 발생하지 않습니다. 입력의 많은 구문 검사 및 유효성 검사도 연기될 수 있으므로 <code>curl_easy_setopt</code>가 불평하지 않았다고 해서 입력이 정확하고 유효하다는 의미는 아닙니다. 나중에 오류가 반환될 수 있습니다.</p><p>별도 섹션에서 <a href="https://everything.curl.dev/libcurl/options" rel="external nofollow noopener noreferrer" target="_blank">쉬운 옵션</a>에 대해 자세히 읽어보세요.</p><p>쉬운 핸들로 옵션 설정을 마치면 실제 전송을 시작할 수 있습니다.</p><p>전송의 실제 수행은 애플리케이션에서 원하는 동작의 종류와 libcurl이 아키텍처에 가장 잘 통합되는 방식에 따라 다양한 메서드와 함수 호출을 사용하여 수행할 수 있습니다. 이에 대해서는 이 장의 뒷부분에서 자세히 설명합니다.</p><p>전송이 진행되는 동안 libcurl은 <a href="https://everything.curl.dev/libcurl/callbacks" rel="external nofollow noopener noreferrer" target="_blank">콜백</a>이라고 하는 지정된 함수를 호출하여 데이터를 전달하고 데이터를 읽고 다양한 작업을 수행합니다.</p><p>전송이 완료된 후 성공 여부를 알 수 있으며 libcurl이 전송 중에 수집한 통계 및 기타 정보를 easy 핸들에서 추출할 수 있습니다. <a href="https://everything.curl.dev/libcurl/getinfo" rel="external nofollow noopener noreferrer" target="_blank">전송 후 정보</a>를 참조하십시오.</p><h2 id="재사용"><a href="#재사용" class="headerlink" title="재사용!"></a>재사용!</h2><p>쉬운 핸들은 재사용할 수 있도록 설계되었습니다. 이지핸들로 한번의 이체를 마치면 바로 다음 이체에 다시 사용할 수 있습니다. 이를 통해 얻을 수 있는 이득이 많다.</p><p>모든 옵션은 “고정”입니다. 다시 변경하거나 핸들에서 <code>curl_easy_reset()</code>을 호출할 때까지 핸들에 설정된 상태로 유지됩니다. 동일한 핸들로 두 번째 전송을 수행하면 동일한 옵션이 사용됩니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/08/Linux-libcurl%20Easy%20handle/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl 드라이브 전송</title>
      <link>http://jung-max.github.io/2022/02/08/Linux-libcurl%20%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C%20%EC%A0%84%EC%86%A1/</link>
      <guid>http://jung-max.github.io/2022/02/08/Linux-libcurl%20%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C%20%EC%A0%84%EC%86%A1/</guid>
      <pubDate>Tue, 08 Feb 2022 04:04:09 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;드라이브-전송&quot;&gt;&lt;a href=&quot;#드라이브-전송&quot; class=&quot;headerlink&quot; title=&quot;드라이브 전송&quot;&gt;&lt;/a&gt;드라이브 전송&lt;/h1&gt;&lt;p&gt;libcurl은 전송을 수행하는 세 가지 다른 방법을 제공합니다. 귀하의 경우에 어떤 방법
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="드라이브-전송"><a href="#드라이브-전송" class="headerlink" title="드라이브 전송"></a>드라이브 전송</h1><p>libcurl은 전송을 수행하는 세 가지 다른 방법을 제공합니다. 귀하의 경우에 어떤 방법을 사용할지는 전적으로 귀하와 귀하가 필요로 하는 것에 달려 있습니다.</p><ul><li>‘쉬운’ 인터페이스를 사용하면 동기식으로 단일 전송을 수행할 수 있습니다. libcurl은 전체 전송을 수행하고 성공 여부와 상관없이 애플리케이션이 완료되면 제어를 다시 애플리케이션으로 반환합니다.</li><li>‘멀티’ 인터페이스는 동시에 둘 이상의 전송을 수행하거나 비차단 전송을 원할 때 사용합니다.</li><li>‘multi_socket’ 인터페이스는 일반 다중 인터페이스의 약간의 변형이지만 이벤트 기반이며 실제로 동시 전송 수를 수백 또는 수천 정도로 확장하려는 경우 사용하도록 제안되는 API입니다.</li></ul><h2 id="easy-drive"><a href="#easy-drive" class="headerlink" title="easy drive"></a>easy drive</h2><p>‘easy’라는 이름은 libcurl을 사용하는 정말 쉬운 방법이기 때문에 선택되었으며, 물론 easy에는 몇 가지 제한 사항이 있습니다. 예를 들어, 한 번에 하나의 전송만 수행할 수 있고 단일 함수 호출에서 전체 전송을 수행하고 완료되면 반환합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = curl_easy_perform( easy_handle );</span><br></pre></td></tr></table></figure><p>서버가 느리거나 전송이 크거나 네트워크에서 일부 불쾌한 시간 초과가 발생하거나 이와 유사한 경우 이 함수 호출에 시간이 오래 걸릴 수 있습니다. 물론 N초를 초과하지 않도록 타임아웃을 설정할 수 있지만 특정 조건에 따라 상당한 시간을 의미할 수도 있습니다.</p><p>libcurl이 쉬운 인터페이스로 전송하는 동안 애플리케이션이 다른 작업을 수행하도록 하려면 여러 스레드를 사용해야 합니다. easy 인터페이스를 사용할 때 여러 개의 동시 전송을 수행하려면 각각의 전송을 자체 스레드에서 수행해야 합니다.</p><h2 id="Drive-with-multi"><a href="#Drive-with-multi" class="headerlink" title="Drive with multi"></a>Drive with multi</h2><p>‘multi’라는 이름은 다중 병렬 전송에서와 같이 모두 동일한 단일 스레드에서 수행되는 다중에 대한 것입니다. 다중 API는 차단되지 않으므로 단일 전송에도 사용할 수 있습니다.<br>위에서 설명한 대로 전송은 여전히 “쉬운” <code>CURL *</code> 핸들로 설정되지만 다중 인터페이스를 사용하면 생성된 다중 <code>CURLM *</code> 핸들도 필요하며 이를 사용하여 모든 개별 전송을 구동해야 합니다. 다중 핸들은 하나 이상의 쉬운 핸들을 “잡을” 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURLM *multi_handle = curl_multi_init();</span><br></pre></td></tr></table></figure><p>다중 핸들은 또한 <code>curl_multi_setopt()</code>로 수행하는 특정 옵션 세트를 얻을 수 있지만 가장 간단한 경우에는 거기에 설정할 것이 없을 수도 있습니다.<br>다중 인터페이스 전송을 구동하려면 먼저 다중 핸들로 전송되어야 하는 모든 개별 간편 핸들을 추가해야 합니다. 언제라도 멀티 핸들에 추가할 수 있으며 원할 때마다 다시 제거할 수 있습니다. 다중 핸들에서 쉬운 핸들을 제거하면 물론 연결이 제거되고 특정 전송이 즉시 중지됩니다.</p><p>멀티 핸들에 easy 핸들을 추가하는 것은 쉽습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_multi_add_handle( multi_handle, easy_handle );</span><br></pre></td></tr></table></figure><p>하나를 제거하는 것도 간단합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_multi_remove_handle( multi_handle, easy_handle );</span><br></pre></td></tr></table></figure><p>수행하려는 전송을 나타내는 쉬운 핸들을 추가한 후 전송 루프를 작성합니다. 다중 인터페이스를 사용하면 루핑을 수행하여 libcurl에 파일 설명자 세트와 시간 초과 값을 요청하고 스스로 <code>select()</code> 호출을 수행하거나 <code>curl_multi_wait</code>를 사용하여 이를 수행하는 약간 단순화된 버전을 사용할 수 있습니다. 가장 간단한 루프는 다음과 같을 수 있습니다. (실제 응용 프로그램은 반환 코드를 확인합니다)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> transfers_running;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">   curl_multi_wait ( multi_handle, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1000</span>, <span class="literal">NULL</span>);</span><br><span class="line">   curl_multi_perform ( multi_handle, &amp;transfers_running );</span><br><span class="line">&#125; <span class="keyword">while</span> (transfers_running);</span><br></pre></td></tr></table></figure><p>위의 예에서 1000으로 설정된 <code>curl_multi_wait</code>에 대한 네 번째 인수는 밀리초 단위의 시간 초과입니다. 어쨌든 반환되기 전에 함수가 활동을 기다리는 가장 긴 시간입니다. 시간 초과, 진행 콜백 등이 있으므로 <code>curl_multi_perform</code>을 다시 호출하기 전에 너무 오랫동안 잠그고 싶지 않습니다. 그렇게 하면 정밀도가 떨어질 수 있습니다.</p><p>대신 <code>select()</code>를 자체적으로 수행하기 위해 다음과 같이 libcurl에서 파일 설명자와 시간 초과 값을 추출합니다(실제 응용 프로그램은 반환 코드를 확인할 것입니다).</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> transfers_running;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  fd_set fdread;</span><br><span class="line">  fd_set fdwrite;</span><br><span class="line">  fd_set fdexcep;</span><br><span class="line">  <span class="keyword">int</span> maxfd = <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">long</span> timeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* extract timeout value */</span></span><br><span class="line">  curl_multi_timeout(multi_handle, &amp;timeout);</span><br><span class="line">  <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>)</span><br><span class="line">    timeout = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* convert to struct usable by select */</span></span><br><span class="line">  timeout.tv_sec = timeout / <span class="number">1000</span>;</span><br><span class="line">  timeout.tv_usec = (timeout % <span class="number">1000</span>) * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">  FD_ZERO(&amp;fdread);</span><br><span class="line">  FD_ZERO(&amp;fdwrite);</span><br><span class="line">  FD_ZERO(&amp;fdexcep);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get file descriptors from the transfers */</span></span><br><span class="line">  mc = curl_multi_fdset(multi_handle, &amp;fdread, &amp;fdwrite, &amp;fdexcep, &amp;maxfd);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (maxfd == <span class="number">-1</span>) &#123;</span><br><span class="line">    SHORT_SLEEP;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">   select(maxfd+<span class="number">1</span>, &amp;fdread, &amp;fdwrite, &amp;fdexcep, &amp;timeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* timeout or readable/writable sockets */</span></span><br><span class="line">  curl_multi_perform(multi_handle, &amp;transfers_running);</span><br><span class="line">&#125; <span class="keyword">while</span> ( transfers_running );</span><br></pre></td></tr></table></figure><p>이 두 루프 모두 자신의 소켓이나 파이프 등에서 읽는 경우와 같이 대기할 파일 설명자를 하나 이상 사용할 수 있습니다.</p><p>또한 루핑 중 언제라도 멀티 핸들에 쉬운 핸들을 추가하거나 제거할 수 있습니다. 물론 전송 도중 핸들을 제거하면 해당 전송이 중단됩니다.</p><h3 id="단일-전송은-언제-완료됩니까"><a href="#단일-전송은-언제-완료됩니까" class="headerlink" title="단일 전송은 언제 완료됩니까?"></a>단일 전송은 언제 완료됩니까?</h3><p>위의 예에서 볼 수 있듯이 프로그램은 <code>transfers_running</code> 변수가 감소하는 것을 확인하여 개별 전송이 완료되는 시점을 감지할 수 있습니다.</p><p>또한 <code>curl_multi_info_read()</code>를 호출하여 전송이 종료된 경우 구조체에 대한 포인터(“메시지”)를 반환하고 해당 구조체를 사용하여 해당 전송의 결과를 찾을 수 있습니다.</p><p>여러 병렬 전송을 수행하는 경우 동일한 <code>curl_multi_perform</code> 호출에서 둘 이상의 전송이 완료될 수 있으며 완료된 각 전송에 대한 정보를 얻기 위해 <code>curl_multi_info_read</code>에 대한 호출이 둘 이상 필요할 수 있습니다.</p><h2 id="Drive-with-multi-socket"><a href="#Drive-with-multi-socket" class="headerlink" title="Drive with multi_socket"></a>Drive with multi_socket</h2><h3 id="“multi-socket”-인터페이스로-구동"><a href="#“multi-socket”-인터페이스로-구동" class="headerlink" title="“multi_socket” 인터페이스로 구동"></a>“multi_socket” 인터페이스로 구동</h3><p>multi_socket은 일반 다중 인터페이스의 추가 매운 버전이며 이벤트 기반 응용 프로그램을 위해 설계되었습니다.</p><p>multi_socket은 모두 동일한 단일 스레드에서 수행되는 다중 병렬 전송을 지원하며 단일 애플리케이션에서 수만 건의 전송을 실행하는 데 사용되었습니다. 일반적으로 많은 수(&gt;100 정도) 병렬 전송을 수행하는 경우 가장 적합한 API입니다.</p><p>이 경우 이벤트 구동은 응용 프로그램이 여러 소켓에 “구독”하는 시스템 수준 라이브러리 또는 설정을 사용하고 해당 소켓 중 하나를 읽거나 쓸 수 있을 때 응용 프로그램에 알려주고 정확히 어느 소켓을 알려줍니다.</p><p>이 설정을 통해 클라이언트는 다른 시스템보다 훨씬 더 많은 동시 전송 수를 확장하면서도 여전히 우수한 성능을 유지할 수 있습니다. 그렇지 않으면 “일반” API는 모든 소켓 목록을 스캔하는 데 너무 많은 시간을 낭비합니다.</p><h3 id="하나를-선택"><a href="#하나를-선택" class="headerlink" title="하나를 선택"></a>하나를 선택</h3><p>선택할 수 있는 이벤트 기반 시스템이 많이 있으며 libcurl은 사용자가 사용하는 시스템에 대해 완전히 불가지론적입니다. libevent, libev 및 libuv는 널리 사용되는 세 가지이지만 epoll, kqueue, /dev/poll, pollset 또는 Event Completion과 같은 운영 체제의 기본 솔루션으로 직접 이동할 수도 있습니다.</p><h3 id="많은-쉬운-핸들"><a href="#많은-쉬운-핸들" class="headerlink" title="많은 쉬운 핸들"></a>많은 쉬운 핸들</h3><p>일반 다중 인터페이스와 마찬가지로 <code>curl_multi_add_handle()</code>을 사용하여 다중 핸들에 쉬운 핸들을 추가합니다. 수행하려는 각 전송에 대한 하나의 쉬운 핸들.</p><p>전송이 실행되는 동안 언제든지 추가할 수 있으며 <code>curl_multi_remove_handle</code> 호출을 사용하여 언제든지 간편 핸들을 유사하게 제거할 수도 있습니다. 그러나 일반적으로 전송이 완료된 후에만 핸들을 제거합니다.</p><h3 id="multi-socket-콜백"><a href="#multi-socket-콜백" class="headerlink" title="multi_socket 콜백"></a>multi_socket 콜백</h3><p>위에서 설명했듯이 이 이벤트 기반 메커니즘은 libcurl이 어떤 소켓을 사용하고 libcurl이 해당 소켓에서 무엇을 기다리는지를 애플리케이션에 의존합니다. 소켓이 읽기, 쓰기 또는 둘 다 되기를 기다리는 경우!</p><p>또한 libcurl이 스스로 할 수 없는 모든 것을 제어하기 때문에 타임아웃 시간이 만료되면 libcurl에 알려야 합니다. 따라서 libcurl은 업데이트된 시간 초과 값도 응용 프로그램에 알려야 합니다.</p><h4 id="소켓-콜백"><a href="#소켓-콜백" class="headerlink" title="소켓_콜백"></a>소켓_콜백</h4><p>libcurl은 <a href="https://curl.se/libcurl/c/CURLMOPT_SOCKETFUNCTION.html" rel="external nofollow noopener noreferrer" target="_blank">CURLMOPT_SOCKETFUNCTION</a>이라는 콜백으로 대기할 소켓 활동에 대해 애플리케이션에 알립니다. 애플리케이션은 다음과 같은 기능을 구현해야 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_callback</span><span class="params">(CURL *easy,      <span class="comment">/* easy handle */</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">curl_socket_t</span> s, <span class="comment">/* socket */</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> what,        <span class="comment">/* what to wait for */</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *userp,     <span class="comment">/* private callback pointer */</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">void</span> *socketp)</span>   <span class="comment">/* private socket pointer */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">/* told about the socket 's' */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set the callback in the multi handle */</span></span><br><span class="line">curl_multi_setopt(multi_handle, CURLMOPT_SOCKETFUNCTION, socket_callback);</span><br></pre></td></tr></table></figure><p>이것을 사용하여 libcurl은 애플리케이션이 모니터링해야 하는 소켓을 설정 및 제거합니다. 애플리케이션은 기본 이벤트 기반 시스템에 소켓을 기다리도록 지시합니다. 이 콜백은 대기할 소켓이 여러 개 있는 경우 여러 번 호출되며 상태가 변경되면 다시 호출되며 쓰기 가능한 소켓을 기다리는 대신 읽을 수 있게 될 때까지 기다리는 것으로 전환해야 합니다.</p><p>응용 프로그램이 libcurl을 대신하여 모니터링하는 소켓 중 하나가 요청에 따라 읽기 또는 쓰기가 가능해진다고 등록하면 <code>curl_multi_socket_action()</code>을 호출하고 영향을 받는 소켓과 어떤 소켓 활동이 있었는지 지정하는 관련 비트마스크를 전달하여 libcurl에 알려줍니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> running_handles;</span><br><span class="line">ret = curl_multi_socket_action(multi_handle,</span><br><span class="line">                               sockfd, <span class="comment">/* the socket with activity */</span></span><br><span class="line">                               ev_bitmask, <span class="comment">/* the specific activity */</span></span><br><span class="line">                               &amp;running_handles);</span><br></pre></td></tr></table></figure><h4 id="타이머-콜백"><a href="#타이머-콜백" class="headerlink" title="타이머_콜백"></a>타이머_콜백</h4><p>응용 프로그램이 제어되고 소켓 활동을 기다립니다. 그러나 소켓 활동이 없더라도 libcurl이 해야 할 일이 있습니다. 시간 초과 문제, 진행 콜백 호출, 재시도를 다시 시작하거나 너무 오래 걸리는 전송 실패 등. 이 작업을 수행하려면 응용 프로그램은 libcurl이 설정하는 단일 샷 시간 초과도 처리해야 합니다.</p><p>libcurl은 timer_callback으로 시간 초과를 설정합니다. <a href="https://curl.se/libcurl/c/CURLMOPT_TIMERFUNCTION.html" rel="external nofollow noopener noreferrer" target="_blank">CURLMOPT_TIMERFUNCTION</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">timer_callback</span><span class="params">(multi_handle,   <span class="comment">/* multi handle */</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   timeout_ms,     <span class="comment">/* milliseconds to wait */</span></span></span></span><br><span class="line"><span class="function"><span class="params">                   userp)</span>          <span class="comment">/* private callback pointer */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* the new time-out value to wait for is in 'timeout_ms' */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* set the callback in the multi handle */</span></span><br><span class="line">curl_multi_setopt(multi_handle, CURLMOPT_TIMERFUNCTION, timer_callback);</span><br></pre></td></tr></table></figure><p>추가된 개별 easy 핸들 또는 진행 중인 전송의 수와 상관없이 전체 다중 핸들에 대해 애플리케이션이 처리하는 시간 초과는 한 번뿐입니다. 타이머 콜백은 현재 가장 가까운 대기 시간으로 업데이트됩니다. 소켓 활동으로 인해 시간 초과 만료 시간 전에 libcurl이 호출되면 만료되기 전에 시간 초과 값을 다시 업데이트할 수 있습니다.</p><p>선택한 이벤트 시스템이 결국 타이머가 만료되었다고 알려줄 때 libcurl에 이에 대해 알려야 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, <span class="number">0</span>, &amp;<span class="built_in">running</span>);</span><br></pre></td></tr></table></figure><p>… 많은 경우에 이것은 libcurl이 timer_callback을 다시 호출하고 다음 만료 기간에 대한 새로운 시간 초과를 설정하게 합니다.</p><h4 id="모든-것을-시작하는-방법"><a href="#모든-것을-시작하는-방법" class="headerlink" title="모든 것을 시작하는 방법"></a>모든 것을 시작하는 방법</h4><p>다중 핸들에 하나 이상의 쉬운 핸들을 추가하고 다중 핸들에서 소켓 및 타이머 콜백을 설정하면 전송을 시작할 준비가 된 것입니다.</p><p>모든 것을 시작하기 위해 libcurl에게 시간 초과(모든 쉬운 핸들이 짧은 시간 초과로 시작하기 때문에)에 알리면 libcurl이 콜백을 호출하여 설정한 다음 이벤트 시스템이 구동되도록 할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* all easy handles and callbacks are setup */</span></span><br><span class="line"></span><br><span class="line">curl_multi_socket_action(multi, CURL_SOCKET_TIMEOUT, <span class="number">0</span>, &amp;<span class="built_in">running</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* now the callbacks should have been called and we have sockets to wait for</span></span><br><span class="line"><span class="comment">   and possibly a timeout, too. Make the event system do its magic */</span></span><br><span class="line"></span><br><span class="line">event_base_dispatch(event_base); <span class="comment">/* libevent2 has this API */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* at this point we have exited the event loop */</span></span><br></pre></td></tr></table></figure><h4 id="언제-완료되나요"><a href="#언제-완료되나요" class="headerlink" title="언제 완료되나요?"></a>언제 완료되나요?</h4><p><code>curl_multi_socket_action</code>이 반환한 ‘running_handles’ 카운터는 완료되지 않은 현재 전송 수를 보유합니다. 해당 숫자가 0에 도달하면 진행 중인 전송이 없음을 알 수 있습니다.</p><p>‘running_handles’ 카운터가 변경될 때마다 <code>curl_multi_info_read()</code>는 완료된 특정 전송에 대한 정보를 반환합니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/08/Linux-libcurl%20%EB%93%9C%EB%9D%BC%EC%9D%B4%EB%B8%8C%20%EC%A0%84%EC%86%A1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>buildroot 환경에서 linux로 http통신 하기 (cURL사용)</title>
      <link>http://jung-max.github.io/2022/02/08/Linux-http%20%ED%86%B5%EC%8B%A0(curl)/</link>
      <guid>http://jung-max.github.io/2022/02/08/Linux-http%20%ED%86%B5%EC%8B%A0(curl)/</guid>
      <pubDate>Tue, 08 Feb 2022 04:04:09 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;클라이언트에서 커맨드 라인이나 소스코드로 손 쉽게 웹 브라우저 처럼 활동할 수 있도록 해주는 기술(커맨드라인 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><ul><li><p>클라이언트에서 커맨드 라인이나 소스코드로 손 쉽게 웹 브라우저 처럼 활동할 수 있도록 해주는 기술(커맨드라인 Tool 혹은 라이브러리)</p></li><li><p>서버와 통신할 수 있는 커맨드 명령어 툴이다. 웹개발에 매우 많이 사용되고 있는 무료 오픈소스이다 curl의 특징으로는 다음과 같은 수 많은 프로토콜을 지원한다는 장점이 있다.</p></li><li><p>다양한 지원 프로토콜들<br>DICT, FILE, FTP, FTPS, Gopher, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, POP3S, RTMP, RTSP, SCP, SFTP, SMB, SMBS, SMTP, SMTPS, Telnet, TFTP</p></li><li><p>또한 SSL 인증 방식 역시 가능하다.</p></li></ul><ul><li>url을 가지고 할 수 있는 것들은 다할 수 있다. 예를 들면, http 프로토콜을 이용해 웹 페이지의 소스를 가져온다거나 파일을 다운받을 수 있다. ftp 프로토콜을 이용해서는 파일을 받을 수 있을 뿐 아니라 올릴 수도 있다. 심지어 SMTP 프로토콜을 이용하면 메일도 보낼 수 있다</li></ul><p>예)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X GET http://127.0.0.1:3000/api/users/bakyeono</span><br><span class="line">$ curl -X POST http://127.0.0.1:3000/api/languages/ansi-common-lisp</span><br><span class="line">$ curl -X PUT http://127.0.0.1:3000/api/resources/1789</span><br></pre></td></tr></table></figure><p>위 명령은 cURL을 이용해 각각 다음과 같은 요청을 보낸다.</p><ul><li><a href="http://127.0.0.1:3000/api/users/bakyeono" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:3000/api/users/bakyeono</a> 리소스를 GET</li><li><a href="http://127.0.0.1:3000/api/languages/ansi-common-lisp" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:3000/api/languages/ansi-common-lisp</a> 리소스를 POST</li><li><a href="http://127.0.0.1:3000/api/resources/1789" rel="external nofollow noopener noreferrer" target="_blank">http://127.0.0.1:3000/api/resources/1789</a> 리소스를 PUT</li></ul>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/08/Linux-http%20%ED%86%B5%EC%8B%A0(curl)/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
