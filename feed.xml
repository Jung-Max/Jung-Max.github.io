<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Max&#39;s Blog</title>
    <link>http://jung-max.github.io/</link>
    
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    
    <description>개발시 정리했던 사항을 끄적이기 위한 블로그</description>
    <pubDate>Thu, 17 Feb 2022 06:07:17 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>cJSON 사용법</title>
      <link>http://jung-max.github.io/2022/02/17/Linux-cJSON%20%EC%82%AC%EC%9A%A9%EB%B2%95/</link>
      <guid>http://jung-max.github.io/2022/02/17/Linux-cJSON%20%EC%82%AC%EC%9A%A9%EB%B2%95/</guid>
      <pubDate>Thu, 17 Feb 2022 03:05:13 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;p&gt;cJSON은 c에서 JSON을 다루기 위한 라이브러리입니다. 해당 라이브러리가 좋은 점은 단일 파일과 단일 헤더로 이루어져 있
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>cJSON은 c에서 JSON을 다루기 위한 라이브러리입니다. 해당 라이브러리가 좋은 점은 단일 파일과 단일 헤더로 이루어져 있어서 importing이 매우 간단하다는 점입니다.</p><p>해당 파일은 <a href="https://github.com/DaveGamble/cJSON" rel="external nofollow noopener noreferrer" target="_blank">여기</a>에서 다운받을 수 있습니다.</p><p>해당 라이브러리는 MIT 라이센스로 누구나 자유롭게 사용 가능합니다.</p><h3 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h3><p>cmake를 통해서도 설치가 가능합니다. 하지만 라이브러리가 단일 파일로 되어있으므로 프로젝트에 직접 넣는 것이 더 간편합니다.</p><p><a href="https://github.com/DaveGamble/cJSON" rel="external nofollow noopener noreferrer" target="_blank">사이트</a>에서 다운받은 파일 중 <code>cJSON.c</code>와 <code>cJSON.h</code>를 직접 프로젝트에 넣어주면 됩니다.</p><p>추후 <code>#include &quot;cjson/cJSON.h&quot;</code>와 같은 형식으로 include해주면 됩니다.</p><h3 id="데이터-구조"><a href="#데이터-구조" class="headerlink" title="데이터 구조"></a>데이터 구조</h3><p>CJSON은 CJSON struct 데이터 유형을 사용하여 JSON 데이터를 나타냅니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The cJSON structure: */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cJSON</span> *<span class="title">child</span>;</span></span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">char</span> *valuestring;</span><br><span class="line">    <span class="comment">/* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead */</span></span><br><span class="line">    <span class="keyword">int</span> valueint;</span><br><span class="line">    <span class="keyword">double</span> valuedouble;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">string</span>;</span><br><span class="line">&#125; cJSON;</span><br></pre></td></tr></table></figure><p>이 유형의 항목은 JSON 값을 나타냅니다. 유형은<code>type</code>에 저장됩니다. 비트 플래그로 저장됩니다 (** 이것은<code>type</code> **의 값을 비교하여 유형을 찾을 수 없음을 의미합니다).</p><p>항목의 유형을 확인하려면 해당<code>cjson_is ...</code>기능을 사용하십시오. <code>null</code> 검사가 뒤 따른 다음 항목 이이 유형의 항목 인 경우 부울 값을 반환합니다.</p><p>유형은 다음 중 하나 일 수 있습니다.</p><ul><li><code>cjson_invalid</code> (<code>cjson_isinvalid</code>으로 확인) : 값이없는 유효하지 않은 항목을 나타냅니다. 항목을 모두 0 바이트로 설정하면 자동 으로이 유형이 있습니다.</li><li><code>cjson_false</code> (<code>cjson_isfalse</code>에 체크) :<code>false</code>부울 값을 나타냅니다. <code>cjson_isboool</code>로 Boolean 값을 확인할 수도 있습니다.</li><li><code>cjson_true</code> (<code>cjson_istreue</code>로 확인) :<code>true</code> Boolean 값을 나타냅니다. <code>cjson_isboool</code>로 Boolean 값을 확인할 수도 있습니다.</li><li><code>cjson_null</code> (<code>cjson_isnull</code>로 확인) :<code>null</code> 값을 나타냅니다.</li><li><code>cjson_number</code> (<code>cjson_isnumber</code>와 함께 확인) : 숫자 값을 나타냅니다. 값은<code>ValueDouble</code>의 두 배로 저장되고<code>Validint</code>에도 저장됩니다. 숫자가 정수 범위를 벗어나면<code>int_max</code> 또는<code>int_min</code>가<code>Validint</code>에 사용된다.</li><li><code>CJSON_String</code> (<code>cjson_isstring</code>에 확인) : 문자열 값을 나타냅니다. <code>valuestring</code>의 0 종단 문자열 형태로 저장됩니다.</li><li><code>cjson_array</code> (<code>cjson_isarray</code>로 확인) : 배열 값을 나타냅니다. 이는<code>자식</code>을 배열의 값을 나타내는<code>cjson</code> 항목의 링크 된 목록으로 가리키는 것으로 구현됩니다. 요소는<code>next</code> 및<code>prev</code>를 사용하여<code>pref.next == null</code>와 마지막 요소가<code>null == null&#39;를 갖는</code>next<code>와</code>prev`를 사용하여 링크됩니다.</li><li><code>cjson_object</code> (<code>cjson_isobject</code>에 확인) : 객체 값을 나타냅니다. 객체는 배열과 동일한 방식으로 저장되며, 유일한 차이점은 객체의 항목이<code>string</code>의 키를 저장한다는 것입니다.</li><li><code>CJSON_RAW</code> (<code>cjson_israw</code>에 체크) :<code>valuestring</code>의 문자의 제로 종료 배열로 저장된 모든 종류의 JSON을 나타냅니다. 예를 들어, 성능을 절약하기 위해 동일한 정적 JSON을 반복해서 반복해서 인쇄하지 않도록 사용할 수 있습니다. cjson은 구문 분석 할 때이 유형을 만들지 않습니다. 또한 CJSON은 유효한 JSON인지 확인하지 않습니다.</li></ul><p>또한 다음 두 가지 플래그가 있습니다.</p><ul><li><code>cjson_isreference</code> :<code>자녀</code>가 가리키는 항목과 / 또는<code>valuestring</code>항목 이이 항목에 의해 소유되지 않는 항목을 지정하여 참조 일뿐입니다. 따라서 <code>CJSON_DELETE</code> 및 다른 기능은<code>vehild</code> /<code>valuestring</code>이 아닌이 항목 만 할당 해제합니다.</li><li><code>cjson_stringisconst</code> : 이것은<code>string</code>가 일정한 문자열을 가리킨다는 것을 의미합니다. 즉,<code>cjson_delete</code> 및 다른 함수는<code>string</code>을 할당 해제하려고하지 않는다는 것을 의미합니다.</li></ul><h3 id="데이터-구조로-작동합니다"><a href="#데이터-구조로-작동합니다" class="headerlink" title="데이터 구조로 작동합니다"></a>데이터 구조로 작동합니다</h3><p>모든 값 유형에 대해 해당 유형의 항목을 만드는 데 사용할 수있는<code>cjson_create ...</code>함수가 있습니다.</p><p>이 모든 것은 나중에<code>cjson_delete</code>로 삭제 될 수있는<code>cjson</code> struct를 할당 할 것입니다.</p><p>어떤 시점에서 삭제해야합니다. 그렇지 않으면 메모리 누수가 발생합니다.</p><p><strong>중요</strong> : 배열이나 오브젝트에 항목을 추가 한 경우 <code>cjson_delete</code>로 삭제해서는 안됩니다. 배열이나 오브젝트에 추가하면 소유권을 전송하여 해당 배열이나 개체가 삭제되면 삭제됩니다.</p><p> <code>cjson_setvalueString</code>을 사용하여<code>cjson_string</code>의’valuestring<code>을 변경하고 이전</code>valuestring`를 수동으로 해제 할 필요는 없습니다.</p><h4 id="기본-유형"><a href="#기본-유형" class="headerlink" title="기본 유형"></a>기본 유형</h4><ul><li><strong>NULL</strong>은<code>cjson_createnull</code>로 생성됩니다</li><li><strong>booleans</strong><code>cjson_creaTeetRue</code>,<code>cjson_createfalse</code> 또는<code>cjson_createbool</code>으로 생성된다</li><li><strong>numbers</strong>는<code>cjson_createNumber</code>로 생성됩니다. 이것은<code>ValueDouble</code>와<code>ValueInt</code> 둘 다 설정됩니다. 숫자가 정수 범위를 벗어나면<code>int_max</code> 또는<code>int_min</code>가<code>Validint</code>에 사용된다.</li><li><strong>strings</strong>는<code>cjson_createString</code> (문자열 복사) 또는<code>cjson_createStringReference</code> (직접 문자열을 가리키는 것을 의미합니다. <code>valuestring</code>는<code>cjson_delete</code>에 의해 삭제되지 않고 수명, 상수에 유용합니다.)</li></ul><h4 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h4><p><code>cjson_createarray</code>가있는 빈 배열을 만들 수 있습니다. <code>CJSON_CreateArrayRayference</code>는 콘텐츠를 “소유”하지 않는 배열을 만드는 데 사용할 수 있으므로 콘텐츠가<code>cjson_delete</code>에 의해 삭제되지 않습니다.</p><p>항목을 배열에 추가하려면<code>cjson_additemtoarray</code>를 사용하여 항목을 끝까지 추가합니다.<br><code>cjson_additemreferencetoarray</code>를 사용하여 요소는 다른 항목, 배열 또는 문자열에 대한 참조로 추가 할 수 있습니다. 즉,<code>CJSON_DELETE</code>는<code>자식</code>또는<code>VALUESTRING&#39;속성을 삭제하지 않으므로 이미 다른 곳에서 이미 사용되는 경우 이중 해제가 발생하지 않습니다.중간에 항목을 삽입하려면</code>cjson_insertiteminarray`를 사용하십시오. 주어진 0 기반 인덱스에 항목을 삽입하고 기존 항목을 오른쪽으로 이동합니다.</p><p>주어진 인덱스에서 배열에서 항목을 꺼내고 계속 사용하려면<code>cjson_detachitemfromarray</code>를 사용하여 분리 된 항목을 반환하므로 포인터에 할당해야합니다. 그렇지 않으면 메모리 누수가 발생합니다.</p><p>삭제 항목은<code>cjson_deleteItemFromArray</code>로 수행됩니다. 그것은<code>cjson_detachitemfromarray</code>와 같이 작동하지만<code>cjson_delete</code>를 통해 분리 된 항목을 삭제합니다.</p><p>배열의 항목을 대체 할 수도 있습니다. 색인을 사용하여<code>cjson_replaceItemInarray</code> 또는<code>cjson_replaceItemViApointer</code>로<code>cjson_replaceItemViApointer&#39;를 사용하여</code>cjson_replaceItemViApointer<code></code>cjson_replaceItemViaPointer<code>가 실패하면</code>0`을 반환합니다. 이게 내부적으로 오래된 항목을 분리하고 삭제하고 새 항목을 그 자리에 삽입하는 것입니다.</p><p>배열의 크기를 얻으려면<code>cjson_getArraysize</code>를 사용하십시오. <code>cjson_getArrayItem</code>를 사용하여 주어진 인덱스에서 요소를 구할 수 있습니다.</p><p>배열은 링크 된 목록으로 저장되므로 인덱스를 통해 반복하는 것은 비효율적입니다 (<code>o (n²)</code>)<code>cojson_arrayforeach</code> 매크로를 사용하여 배열을 반복 할 수 있습니다.</p><h4 id="object"><a href="#object" class="headerlink" title="object"></a>object</h4><p><code>cjson_createobject</code>가있는 빈 객체를 만들 수 있습니다. <code>CJSON_CreateObjectReference</code>는 콘텐츠를 “소유”하지 않는 개체를 만드는 데 사용할 수 있으므로 콘텐츠가<code>cjson_delete</code>에 의해 삭제되지 않습니다.</p><p>객체에 항목을 추가하려면<code>cjson_additemtoobject</code>를 사용하십시오. <code>cjson_additemtoobjectcs</code>를 사용하여 상수 또는 참조 인 이름을 가진 객체에 항목을 추가하여<code>cjson_delete</code>에 의해 해제되지 않도록 아이템 (<code>cjson</code> struct)의 키,<code>string</code>).</p><p><code>cjson_additemreferencetoarray</code>를 사용하여 요소는 다른 객체, 배열 또는 문자열에 대한 참조로 추가 할 수 있습니다. 즉,<code>CJSON_DELETE</code>는<code>자식</code>또는<code>VALUESTRING</code>속성을 삭제하지 않으므로 이미 다른 곳에서 이미 사용되는 경우 이중 해제가 발생하지 않습니다.</p><p>객체에서 항목을 꺼내려면<code>cjson_detachitemfromobobjectcasesensitive</code>를 사용하여 분리 된 항목을 반환하므로 포인터에 할당해야합니다. 그렇지 않으면 메모리 누수가 발생합니다.</p><p>항목을 삭제하면<code>cjson_deleteItemFromObjectCasEnitive</code>로 수행됩니다. 그것은<code>cjson_detachitemfromobobjectcasesensitive</code>와 같은 일이 뒤 따른다.</p><p>객체의 항목을 제자리에서 바꿀 수도 있습니다. <code>cjson_replaceItemInoBjectCasEnitive</code> 키를 사용하여<code>cjson_replaceItemViApointer</code>를 사용하여<code>cjson_replaceItemViApointer</code> <code>cjson_replaceItemViaPointer</code>가 실패하면<code>0</code>을 반환합니다. 이게 내부적으로 오래된 항목을 분리하고 삭제하고 새 항목을 그 자리에 삽입하는 것입니다.</p><p>객체의 크기를 가져 오려면<code>cjson_getArraysize</code>, 내부 오브젝트가 배열로 저장되기 때문에 작동합니다.</p><p>객체의 항목에 액세스하려면<code>cjson_getobjectItemCasensitive</code>를 사용하십시오.</p><p>객체를 반복하려면 배열과 동일한 방식으로<code>cjson_arrayforeach</code> 매크로를 사용할 수 있습니다.</p><p>CJSON은 또한 새로운 항목을 빠르게 만들고<code>cjson_addnulltoobject</code>와 같은 객체에 추가하기위한 편리한 도우미 기능을 제공합니다. 그들은 실패한 경우 새 항목이나<code>null</code>에 대한 포인터를 반환합니다.</p><h3 id="JSON-파싱"><a href="#JSON-파싱" class="headerlink" title="JSON 파싱"></a>JSON 파싱</h3><p>JSON이 0 종료 문자열에 주어지면<code>cjson_parse</code>로 파싱 할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON *json = cJSON_Parse(<span class="built_in">string</span>);</span><br></pre></td></tr></table></figure><p>일부 JSON은 문자열에 (0을 종료했는지 여부)<code>cjson_parsewithLength</code>로 구문 분석 할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cJSON *json = cJSON_ParseWithLength(<span class="built_in">string</span>, buffer_length);</span><br></pre></td></tr></table></figure><p>그것은 JSON을 구문 분석하고<code>CJSON</code> 항목의 tree를 할당 할 것입니다. 반환되면<code>cjson_delete</code>와 함께 사용한 후에 그것을 할당 해제 할 책임이 있습니다.</p><p><code>cjson_parse</code>에서 사용하는 할당자는<code>malloc</code>와<code>free</code>이지만,<code>cjson_inithooks</code>으로 변경 될 수 있습니다 (전역으로).</p><p>오류가 발생하면<code>cjson_geterrorptr</code>를 사용하여 입력 문자열의 오류 위치에 대한 포인터를 액세스 할 수 있습니다. 주는이 경우 멀티 스레딩 시나리오에서 경쟁 조건을 생성 할 수 있지만이 경우<code>return_parse_end</code>로<code>cjson_parsewithopts</code>를 사용하는 것이 좋습니다.<br>기본적으로 파싱 된 JSON을 따르는 입력 문자열의 문자는 오류로 간주되지 않습니다.</p><p>더 많은 옵션을 원한다면<code>cjson_parsewithopts (const char *value, const char **return_parse_end, cjson_bool requal_null_terminated)</code>를 사용하십시오.<br><code>return_parse_end</code>는 입력 문자열의 JSON 끝이나 오류가 발생한 위치에있는 포인터를 반환합니다 (<code>cjson_geterrorptr</code>을 스레드 안전 방식으로 대체 함). <code>1</code>으로 설정하면 입력 문자열에 JSON 이후의 데이터가 포함되어 있으면 오류가 발생합니다.</p><p>버퍼 길이를 제공하는 옵션을 더 원하면<code>cjson_parsewithlengthOpts (const char *value, size_t buffer_length, const char **return_parse_end, cjson_bool requy_null_terminated)</code>를 사용하십시오.</p><h3 id="JSON-printing"><a href="#JSON-printing" class="headerlink" title="JSON printing"></a>JSON printing</h3><p><code>cjson</code> 항목의 tree가 주어지면<code>cjson_print</code>를 사용하여 문자열로 인쇄 할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *<span class="built_in">string</span> = cJSON_Print(json);</span><br></pre></td></tr></table></figure><p>문자열을 할당하고 트리의 JSON 표현을 인쇄합니다. 일단 반환되면 할당 자와 함께 사용한 후에 할당 해제 할 책임이 있습니다. (일반적으로<code>무료&#39;는</code>cjson_inithooks`로 설정된 것에 달려 있습니다.)</p><p><code>cjson_print</code>는 포맷을 위해 공백으로 인쇄됩니다. 서식을 지정하지 않고 인쇄하려면<code>cjson_printUnformatted</code>를 사용하십시오.</p><p>결과 문자열이 얼마나 큰지에 대한 대략적인 아이디어가있는 경우<code>cjson_printbuffered (const cjson * item, int prebuffer, cjson_bool fmt)</code>를 사용할 수 있습니다. <code>fmt</code>는 공백을 켜고 끌 수있는 포맷을 켜는 부울입니다. <code>Prebuffer</code>는 인쇄에 사용할 첫 번째 버퍼 크기를 지정합니다. <code>cjson_print</code>는 현재 첫 번째 버퍼 크기를 위해 256 바이트를 사용합니다. 인쇄가 공간이 부족하면 새 버퍼가 할당되고 인쇄가 계속되기 전에 이전 버퍼가 복사됩니다.</p><p>이러한 동적 버퍼 할당은<code>cjson_printpreallocated (cjson * 항목, char * 버퍼, const int length, const cjson_bool 형식)</code>를 사용하여 완전히 피할 수 있습니다. 인쇄 할 포인터와 그 길이의 버퍼가 필요합니다. 길이에 도달하면 인쇄가 실패하고<code>0</code>을 반환합니다. 성공의 경우,<code>1</code>가 반환됩니다. CJSON은 제공된 메모리가 충분할 경우 추정 할 때 100 % 정확하지 않기 때문에 실제로 5 바이트를 더 많이 제공해야합니다.</p><h3 id="예졔"><a href="#예졔" class="headerlink" title="예졔"></a>예졔</h3><p>이 예에서는 다음 JSON을 구축하고 구문 분석하려고합니다.</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Awesome 4K"</span>,</span><br><span class="line">    <span class="attr">"resolutions"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"width"</span>: <span class="number">1280</span>,</span><br><span class="line">            <span class="attr">"height"</span>: <span class="number">720</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"width"</span>: <span class="number">1920</span>,</span><br><span class="line">            <span class="attr">"height"</span>: <span class="number">1080</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"width"</span>: <span class="number">3840</span>,</span><br><span class="line">            <span class="attr">"height"</span>: <span class="number">2160</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="printing"><a href="#printing" class="headerlink" title="printing"></a>printing</h4><p>위의 JSON을 작성하고 문자열로 printing합시다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//create a monitor with a list of supported resolutions</span></span><br><span class="line"><span class="comment">//<span class="doctag">NOTE:</span> Returns a heap allocated string, you are required to free it after use.</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">create_monitor</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> resolution_numbers[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1280</span>, <span class="number">720</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1920</span>, <span class="number">1080</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3840</span>, <span class="number">2160</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON *name = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON *resolutions = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON *resolution = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON *<span class="built_in">width</span> = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON *<span class="built_in">height</span> = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cJSON *monitor = cJSON_CreateObject();</span><br><span class="line">    <span class="keyword">if</span> (monitor == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    name = cJSON_CreateString(<span class="string">"Awesome 4K"</span>);</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* after creation was successful, immediately add it to the monitor,</span></span><br><span class="line"><span class="comment">     * thereby transferring ownership of the pointer to it */</span></span><br><span class="line">    cJSON_AddItemToObject(monitor, <span class="string">"name"</span>, name);</span><br><span class="line"></span><br><span class="line">    resolutions = cJSON_CreateArray();</span><br><span class="line">    <span class="keyword">if</span> (resolutions == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cJSON_AddItemToObject(monitor, <span class="string">"resolutions"</span>, resolutions);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; (<span class="keyword">sizeof</span>(resolution_numbers) / (<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>))); ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        resolution = cJSON_CreateObject();</span><br><span class="line">        <span class="keyword">if</span> (resolution == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cJSON_AddItemToArray(resolutions, resolution);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">width</span> = cJSON_CreateNumber(resolution_numbers[index][<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">width</span> == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cJSON_AddItemToObject(resolution, <span class="string">"width"</span>, <span class="built_in">width</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">height</span> = cJSON_CreateNumber(resolution_numbers[index][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">height</span> == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cJSON_AddItemToObject(resolution, <span class="string">"height"</span>, <span class="built_in">height</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> = cJSON_Print(monitor);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to print monitor.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">end</span>:</span><br><span class="line">    cJSON_Delete(monitor);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>또는 우리는 <code>cJSON_Add...ToObject</code> 도우미 기능을 사용하여 조금 더 쉽게 만들 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//<span class="doctag">NOTE:</span> Returns a heap allocated string, you are required to free it after use.</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">create_monitor_with_helpers</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> resolution_numbers[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">        &#123;<span class="number">1280</span>, <span class="number">720</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1920</span>, <span class="number">1080</span>&#125;,</span><br><span class="line">        &#123;<span class="number">3840</span>, <span class="number">2160</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">char</span> *<span class="built_in">string</span> = <span class="literal">NULL</span>;</span><br><span class="line">    cJSON *resolutions = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    cJSON *monitor = cJSON_CreateObject();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cJSON_AddStringToObject(monitor, <span class="string">"name"</span>, <span class="string">"Awesome 4K"</span>) == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolutions = cJSON_AddArrayToObject(monitor, <span class="string">"resolutions"</span>);</span><br><span class="line">    <span class="keyword">if</span> (resolutions == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; (<span class="keyword">sizeof</span>(resolution_numbers) / (<span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>))); ++index)</span><br><span class="line">    &#123;</span><br><span class="line">        cJSON *resolution = cJSON_CreateObject();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cJSON_AddNumberToObject(resolution, <span class="string">"width"</span>, resolution_numbers[index][<span class="number">0</span>]) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cJSON_AddNumberToObject(resolution, <span class="string">"height"</span>, resolution_numbers[index][<span class="number">1</span>]) == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cJSON_AddItemToArray(resolutions, resolution);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> = cJSON_Print(monitor);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span> == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to print monitor.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">end</span>:</span><br><span class="line">    cJSON_Delete(monitor);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h4><p>이 예제에서는 위의 형식으로 JSON을 구문 분석하고 일부 진단 출력을 인쇄하는 동안 모니터가 전체 HD 해상도를 지원하는지 확인합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* return 1 if the monitor supports full hd, 0 otherwise */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">supports_full_hd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> monitor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> cJSON *resolution = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">const</span> cJSON *resolutions = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">const</span> cJSON *name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">    cJSON *monitor_json = cJSON_Parse(monitor);</span><br><span class="line">    <span class="keyword">if</span> (monitor_json == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *error_ptr = cJSON_GetErrorPtr();</span><br><span class="line">        <span class="keyword">if</span> (error_ptr != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error before: %s\n"</span>, error_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">        status = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    name = cJSON_GetObjectItemCaseSensitive(monitor_json, <span class="string">"name"</span>);</span><br><span class="line">    <span class="keyword">if</span> (cJSON_IsString(name) &amp;&amp; (name-&gt;valuestring != <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Checking monitor \"%s\"\n"</span>, name-&gt;valuestring);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    resolutions = cJSON_GetObjectItemCaseSensitive(monitor_json, <span class="string">"resolutions"</span>);</span><br><span class="line">    cJSON_ArrayForEach(resolution, resolutions)</span><br><span class="line">    &#123;</span><br><span class="line">        cJSON *<span class="built_in">width</span> = cJSON_GetObjectItemCaseSensitive(resolution, <span class="string">"width"</span>);</span><br><span class="line">        cJSON *<span class="built_in">height</span> = cJSON_GetObjectItemCaseSensitive(resolution, <span class="string">"height"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!cJSON_IsNumber(<span class="built_in">width</span>) || !cJSON_IsNumber(<span class="built_in">height</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="built_in">width</span>-&gt;valuedouble == <span class="number">1920</span>) &amp;&amp; (<span class="built_in">height</span>-&gt;valuedouble == <span class="number">1080</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            status = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> <span class="built_in">end</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">end</span>:</span><br><span class="line">    cJSON_Delete(monitor_json);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>cjson_getobjectItemcasensitive</code>가 이미<code>null</code> 입력에 대한 검사가<code>null</code>값이 전파되고<code>cjson_isnumber</code>와<code>chjson_isstring</code> <code>0</code>이면<code>cjson_getobjectItemcasensitive</code>가<code>cjson_parse</code>의 결과를 제외하고는 null 검사가 없다는 것을 유의하십시오. 입력은<code>null</code>입니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/17/Linux-cJSON%20%EC%82%AC%EC%9A%A9%EB%B2%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>우분투에서 libcurl 사용</title>
      <link>http://jung-max.github.io/2022/02/14/Linux-libcurl%20%EC%9A%B0%EB%B6%84%ED%88%AC%EC%97%90%EC%84%9C%20libcurl%20%EC%82%AC%EC%9A%A9/</link>
      <guid>http://jung-max.github.io/2022/02/14/Linux-libcurl%20%EC%9A%B0%EB%B6%84%ED%88%AC%EC%97%90%EC%84%9C%20libcurl%20%EC%82%AC%EC%9A%A9/</guid>
      <pubDate>Mon, 14 Feb 2022 08:04:16 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;설치&quot;&gt;&lt;a href=&quot;#설치&quot; class=&quot;headerlink&quot; title=&quot;설치&quot;&gt;&lt;/a&gt;설치&lt;/h1&gt;&lt;p&gt;아래와 같이 libcurl을 설치한다.&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h1><p>아래와 같이 libcurl을 설치한다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install libcurl4-openssl-dev</span><br></pre></td></tr></table></figure><p>다음 커맨드로 빌드옵션을 알 수 있다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl-config --cflags</span><br><span class="line">$ curl-config --libs</span><br></pre></td></tr></table></figure><p>아래의 명령어로 빌드 가능하다. (test.c 빌드시)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test test.c -L/usr/lib/x86_64-linux-gnu -lcurl</span><br></pre></td></tr></table></figure><p>그 후 아래의 명령어로 실행 가능하다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br></pre></td></tr></table></figure><h1 id="예제"><a href="#예제" class="headerlink" title="예제"></a>예제</h1><p>rest api를 통해서 http get을 얻어오는 예제이다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line"> </span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  <span class="keyword">if</span>(curl) &#123;</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, <span class="string">"https://reqres.in/api/users/1"</span>);</span><br><span class="line">    <span class="comment">/* example.com is redirected, so we tell libcurl to follow redirection */</span></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, <span class="number">1L</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Perform the request, res will get the return code */</span></span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line">    <span class="comment">/* Check for errors */</span></span><br><span class="line">    <span class="keyword">if</span>(res != CURLE_OK)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"curl_easy_perform() failed: %s\n"</span>,</span><br><span class="line">              curl_easy_strerror(res));</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* always cleanup */</span></span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/14/Linux-libcurl%20%EC%9A%B0%EB%B6%84%ED%88%AC%EC%97%90%EC%84%9C%20libcurl%20%EC%82%AC%EC%9A%A9/#disqus_thread</comments>
    </item>
    
    <item>
      <title>rk-roc3308b-plus 보드 wifi config</title>
      <link>http://jung-max.github.io/2022/02/10/Linux-rk-roc3308b-plus-%EB%B3%B4%EB%93%9C-wifi-config/</link>
      <guid>http://jung-max.github.io/2022/02/10/Linux-rk-roc3308b-plus-%EB%B3%B4%EB%93%9C-wifi-config/</guid>
      <pubDate>Thu, 10 Feb 2022 07:57:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;네트워크-구성&quot;&gt;&lt;a href=&quot;#네트워크-구성&quot; class=&quot;headerlink&quot; title=&quot;네트워크 구성&quot;&gt;&lt;/a&gt;네트워크 구성&lt;/h1&gt;&lt;h2 id=&quot;무선-네트워크-구성&quot;&gt;&lt;a href=&quot;#무선-네트워크-구성&quot; class=&quot;head
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="네트워크-구성"><a href="#네트워크-구성" class="headerlink" title="네트워크 구성"></a>네트워크 구성</h1><h2 id="무선-네트워크-구성"><a href="#무선-네트워크-구성" class="headerlink" title="무선 네트워크 구성"></a>무선 네트워크 구성</h2><p>‘wpa_supplicant’ 도구는 무선 네트워크 구성에 사용됩니다.<br>주로 <code>wpa_supplicant</code> 및 <code>wpa_cli</code>의 두 가지 프로그램을 포함하는 WIFI 연결 및 구성을 위한 도구입니다.</p><h2 id="커맨드-라인"><a href="#커맨드-라인" class="headerlink" title="커맨드 라인"></a>커맨드 라인</h2><h3 id="와이파이-활성화"><a href="#와이파이-활성화" class="headerlink" title="와이파이 활성화"></a>와이파이 활성화</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo 1 &gt;/sys/class/rkwifi/driver</span><br><span class="line">ifconfig wlan0 up</span><br></pre></td></tr></table></figure><p>완료되면 <code>ifconfig</code> 명령을 실행하면 <code>wlan0</code> 노드를 볼 수 있습니다.</p><h3 id="wpa-supplicant-프로세스-시작"><a href="#wpa-supplicant-프로세스-시작" class="headerlink" title="wpa_supplicant 프로세스 시작"></a>wpa_supplicant 프로세스 시작</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpa_supplicant -B -i wlan0 -c /data/cfg/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><p>파일 생성: /data/cfg/wpa_supplicant.conf 파일이 없으면 다음 구성을 추가해야 합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /data/cfg/wpa_supplicant.conf</span><br><span class="line">ctrl_interface=/var/run/wpa_supplicant</span><br><span class="line">ap_scan=1</span><br></pre></td></tr></table></figure><h3 id="wpa-cli로-WIFI-구성"><a href="#wpa-cli로-WIFI-구성" class="headerlink" title="wpa_cli로 WIFI 구성"></a>wpa_cli로 WIFI 구성</h3><p>일반적인 명령:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wpa_cli -i wlan0 scan             // Search wifi network nearby</span><br><span class="line">wpa_cli -i wlan0 scan_result      // Print the searched WiFi network</span><br><span class="line">wpa_cli -i wlan0 add_network      // Add a network connection</span><br></pre></td></tr></table></figure><p>무선 네트워크가 [WPA-PSK-CCMP+TKIP] [WPA2-PSK-CCMP+TKIP] [ESS](wpa 암호화)로 암호화되고 Wi-Fi 이름: 이름, Wi-Fi 암호: psk. 연결 작업은 다음과 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wpa_cli -i wlan0 set_network 0 ssid &apos;&quot;name&quot;&apos;</span><br><span class="line">wpa_cli -i wlan0 set_network 0 psk &apos;&quot;psk&quot;&apos;</span><br><span class="line">wpa_cli -i wlan0 enable_network 0    //Enable WiFi</span><br></pre></td></tr></table></figure><p>무선 네트워크가 [WEP] [ESS](wep 암호화)로 암호화되어 있고 wifi 이름: 이름, wifi 암호: psk. 연결 작업은 다음과 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wpa_cli -i wlan0 set_network 0 ssid &apos;&quot;name&quot;&apos;</span><br><span class="line">wpa_cli -i wlan0 set_network 0 key_mgmt NONE</span><br><span class="line">wpa_cli -i wlan0 set_network 0 wep_key0 &apos;&quot;psk&quot;&apos;</span><br><span class="line">wpa_cli -i wlan0 enable_network 0</span><br></pre></td></tr></table></figure><p>무선 네트워크가 [ESS](암호화 없음)로 암호화되어 있고 Wi-Fi 이름: 이름인 경우 연결 작업은 다음과 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wpa_cli -i wlan0 set_network 0 ssid &apos;&quot;name&quot;&apos;</span><br><span class="line">wpa_cli -i wlan0 set_network 0 key_mgmt NONE</span><br><span class="line">wpa_cli -i wlan0 enable_network 0</span><br></pre></td></tr></table></figure><p>WIFI 연결 정보 저장:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpa_cli -i wlan0 save_config</span><br></pre></td></tr></table></figure><p>저장된 연결 재개:저장된 연결 재개:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wpa_cli -i wlan0 list_network        // List all saved connections</span><br><span class="line">wpa_cli -i wlan0 select_network 0     // Connect the first saved connection</span><br><span class="line">wpa_cli -i wlan0 enable_network 0      // Enable the first saved connection</span><br></pre></td></tr></table></figure><p>WiFi 끄기:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig wlan0 down</span><br></pre></td></tr></table></figure><h2 id="WIFI-구성-파일"><a href="#WIFI-구성-파일" class="headerlink" title="WIFI 구성 파일"></a>WIFI 구성 파일</h2><p>다음 파일을 수정합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vi /data/cfg/wpa_supplicant.conf</span><br><span class="line">ctrl_interface=/var/run/wpa_supplicant</span><br><span class="line">ap_scan=1</span><br></pre></td></tr></table></figure><p>다음 항목을 추가합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">network=&#123;</span><br><span class="line">ssid=&quot;WiFi-AP&quot;// WiFi name</span><br><span class="line">psk=&quot;12345678&quot;// WiFi password</span><br><span class="line">key_mgmt=WPA-PSK// Encryption</span><br><span class="line"># key_mgmt=NONE// No encryption</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>위의 구성을 다시 로드합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpa_cli reconfigure</span><br></pre></td></tr></table></figure><p>재접속:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpa_cli reconnect</span><br></pre></td></tr></table></figure><h2 id="휴대폰으로-WIFI-구성"><a href="#휴대폰으로-WIFI-구성" class="headerlink" title="휴대폰으로 WIFI 구성"></a>휴대폰으로 WIFI 구성</h2><p>휴대폰을 사용하여 Softap 또는 Bluetooth를 통해 WiFi 네트워크를 구성하는 방법에는 여러 가지가 있습니다. 통합 음성 인식 SDK에는 “小度之家 SDK”와 같은 자체 방법도 포함될 것입니다.</p><p>여기에서는 ROC-RK3308B-CC의 내장 네트워크 구성 방법을 소개합니다.</p><h3 id="SoftAP로-WIFI-네트워크-구성"><a href="#SoftAP로-WIFI-네트워크-구성" class="headerlink" title="SoftAP로 WIFI 네트워크 구성"></a>SoftAP로 WIFI 네트워크 구성</h3><p>Download the APP: <a href="http://en.t-firefly.com/doc/download/page/id/67.html#other_298" rel="external nofollow noopener noreferrer" target="_blank">RkEcho.apk</a>, 또는 SDK:<code>SDK/external/app/RkEcho.apk</code>에서 찾을 수 있습니다.</p><p>빌드루트 구성:</p><p><img src="https://wiki.t-firefly.com/en/Core-3308Y/_images/softapserver_config.png" alt="빌드루트구성"></p><p>softapServer의 소스 디렉토리:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/external/softapServer/ -- operations related to WIFI and APK </span><br><span class="line">/external/softapDemo/ -- operations related to WiFi</span><br></pre></td></tr></table></figure><p>apk <a href="http://en.t-firefly.com/doc/download/page/id/67.html#other_298" rel="external nofollow noopener noreferrer" target="_blank">RkEcho.apk</a>를 설치하려면 휴대폰을 준비하세요. 필수입니다.</p><p>그런 다음 wpa_supplicant 프로세스가 시작되었는지 확인합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wpa_supplicant -B -i wlan0 -c /data/cfg/wpa_supplicant.conf</span><br></pre></td></tr></table></figure><p>다음과 같이 WIFI 네트워크를 구성합니다.</p><ul><li>다음 명령 실행:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">softapServer Rockchip-Echo-123</span><br></pre></td></tr></table></figure><p><img src="https://wiki.t-firefly.com/en/Core-3308Y/_images/wifi_server.png" alt="wifi-server"></p><p>참고: Wi-Fi AP는 Rockchip-Echo-xxx 형식으로 이름을 지정해야 합니다.</p><ul><li>AP를 켠 후, 휴대폰의 WiFi 설정을 열고 Rckchip-Echo-123과 같이 방금 설정한 AP로의 연결을 클릭합니다.</li><li>연결이 완료되면 휴대폰에 설치된 apk를 열고 다음 작업을 수행합니다.</li><li>APK를 열고 와이파이 설정 클릭 -&gt; 확인 -&gt; 确认 -&gt; 와이파이 목록 -&gt; 연결할 네트워크 클릭 -&gt; 비밀번호 입력 -&gt; 확인 클릭.</li></ul><p><img src="https://wiki.t-firefly.com/en/Core-3308Y/_images/network_conf.png" alt="network_conf"></p><ul><li>네트워크에 알리라는 음성 안내가 연결되면 사용 시작!</li><li>네트워크가 연결되어 있는지 확인:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping www.google.com</span><br></pre></td></tr></table></figure><ul><li>주의사항:</li></ul><ol><li><p><code>softspServer Rockchip-Echo-123</code> 명령이 실행되면 네트워크 구성이 완료될 때까지 철회할 수 없습니다.</p></li><li><p>잘못된 AP 이름을 설정하지 마십시오. 그렇지 않으면 apk가 확인 인터페이스(Rockchip-Echo-xxx)에 들어가지 않습니다.</p></li><li><p>이 기능은 현재 안드로이드 폰만 지원합니다.</p></li></ol><h2 id="Ethernet"><a href="#Ethernet" class="headerlink" title="Ethernet"></a>Ethernet</h2><h3 id="이더넷-사용"><a href="#이더넷-사용" class="headerlink" title="이더넷 사용"></a>이더넷 사용</h3><ul><li>eth0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 up</span><br></pre></td></tr></table></figure><ul><li>eth1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth1 up</span><br></pre></td></tr></table></figure><h2 id="IP-주소-설정"><a href="#IP-주소-설정" class="headerlink" title="IP 주소 설정"></a>IP 주소 설정</h2><h3 id="동적으로-IP-주소-얻기"><a href="#동적으로-IP-주소-얻기" class="headerlink" title="동적으로 IP 주소 얻기"></a>동적으로 IP 주소 얻기</h3><p>WIFI는 동적으로 IP 주소를 획득하고 다음 명령을 실행합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udhcpc -i wlan0 -R</span><br></pre></td></tr></table></figure><p>이더넷은 동적으로 IP 주소를 획득하고 다음 명령을 실행합니다.</p><ul><li>eth0</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udhcpc -i eth0 -R</span><br></pre></td></tr></table></figure><ul><li>eth1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">udhcpc -i eth1 -R</span><br></pre></td></tr></table></figure><h3 id="고정-IP-주소-설정"><a href="#고정-IP-주소-설정" class="headerlink" title="고정 IP 주소 설정"></a>고정 IP 주소 설정</h3><p>eth0에 대한 고정 IP 주소 설정 단계는 다음과 같습니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ip addr add 168.168.100.78/255.255.0.0 dev eth0 #ip address/subnet mask</span><br><span class="line">ip route flush dev eth0</span><br><span class="line">ip route add 168.168.0.1 dev eth0#gateway</span><br><span class="line">ip route add default via 168.168.0.1 dev eth0 #add default router</span><br><span class="line">echo -e &quot;nameserver 114.114.114.114\nnameserver 8.8.8.8&quot; &gt; /userdata/resolv.conf #set DNS</span><br></pre></td></tr></table></figure><p>WIFI 또는 eth1의 고정 IP 주소 단계는 위와 동일합니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/10/Linux-rk-roc3308b-plus-%EB%B3%B4%EB%93%9C-wifi-config/#disqus_thread</comments>
    </item>
    
    <item>
      <title>rk-roc3308b-plus cross compile</title>
      <link>http://jung-max.github.io/2022/02/10/Linux-rk-roc3308b-plus-cross-complie/</link>
      <guid>http://jung-max.github.io/2022/02/10/Linux-rk-roc3308b-plus-cross-complie/</guid>
      <pubDate>Thu, 10 Feb 2022 07:57:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;p&gt;buildroot sdk가 올라간 보드에서는 컴파일이 불가능 합니다. 그렇기 때문에 Cross compiling을 사용해서 컴
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>buildroot sdk가 올라간 보드에서는 컴파일이 불가능 합니다. 그렇기 때문에 Cross compiling을 사용해서 컴파일을 진행해야 합니다.</p><h1 id="Cross-compiling-tools"><a href="#Cross-compiling-tools" class="headerlink" title="Cross compiling tools"></a>Cross compiling tools</h1><p>sdk를 컴파일 한 폴더를 기준으로 아래의 경로를 찾아갑니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd buildroot/output/firefly_rk3308_release/host/usr/bin/</span><br></pre></td></tr></table></figure><p>그러면 Cross compiling tool을 이용해서 바로 컴파일이 가능합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./buildroot/output/firefly_rk3308_release/host/usr/bin/aarch64-rockchip-linux-gnu-gcc main.c -o test</span><br></pre></td></tr></table></figure><p>해당 파일을 타겟 보드에 옮기고 실행을 합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure><p>만약 permison error가 발생한다면 아래와 같이 권한을 수정합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 test</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/10/Linux-rk-roc3308b-plus-cross-complie/#disqus_thread</comments>
    </item>
    
    <item>
      <title>buildroot 보드 ssh 설정</title>
      <link>http://jung-max.github.io/2022/02/10/Linux-buildroot-%EB%B3%B4%EB%93%9C-ssh%EC%84%A4%EC%A0%95/</link>
      <guid>http://jung-max.github.io/2022/02/10/Linux-buildroot-%EB%B3%B4%EB%93%9C-ssh%EC%84%A4%EC%A0%95/</guid>
      <pubDate>Thu, 10 Feb 2022 07:57:17 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;개요&quot;&gt;&lt;a href=&quot;#개요&quot; class=&quot;headerlink&quot; title=&quot;개요&quot;&gt;&lt;/a&gt;개요&lt;/h1&gt;&lt;p&gt;roc-rk3308b-cc-plus 보드는 여러 컴파일 옵션이 있지만 기본으로 buildroot로 sdk를 컴파일 합니다.&lt;/
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>roc-rk3308b-cc-plus 보드는 여러 컴파일 옵션이 있지만 기본으로 buildroot로 sdk를 컴파일 합니다.</p><p>보드의 좀더 쉬운 컨트롤를 위해서 ssh를 설치했는데 이 방법을 공유해보겠습니다.</p><h1 id="buildroot-sdk-컴파일"><a href="#buildroot-sdk-컴파일" class="headerlink" title="buildroot sdk 컴파일"></a>buildroot sdk 컴파일</h1><p>기본 sdk에는 ssh가 깔려있지 않습니다. ssh를 수동으로 추가하긴 힘드므로 sdk를 컴파일 할때 sdk를 추가해줍니다.</p><p>일단 추가를 위해서 buildroot 폴더에서 <code>make menuconfig</code>를 실행합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/workspace/rk3308b_sdk_linux/buildroot# make menuconfig</span><br></pre></td></tr></table></figure><p>그럼 아래와 같이 창이 뜨게 됩니다.</p><p><img src="/images/0143.png" alt="make menuconfig"></p><p>여기서 다음을 체크해 줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Target packages &gt; Filesystem and flash utilities &gt; sshfs (FUSE)</span><br><span class="line">Target packages &gt; Networking applications &gt; openssh</span><br></pre></td></tr></table></figure><p><code>sshfs</code>는 마운트를 위한 것으로 필요하지 않다면 깔지 않아도 됩니다.<br><code>openssh</code>가 기본으로 설정되있다면 sdk를 컴파일 하지 않아도 됩니다.</p><h1 id="root-password-설정"><a href="#root-password-설정" class="headerlink" title="root password 설정"></a>root password 설정</h1><p>기본적으로 root는 패스워드가 설정되있지 않습니다.</p><p>패스워드 설정을 위해 아래와 같이 입력합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure><p>그러면 root의 암호를 변경할 수 있습니다.</p><h1 id="ssh-동작-확인"><a href="#ssh-동작-확인" class="headerlink" title="ssh 동작 확인"></a>ssh 동작 확인</h1><p>기본적으로 ssh가 기본으로 실행되고 있습니다.</p><p>아래와 같은 방법으로 확인 가능합니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@ubuntu:~/# ps -aef | grep sshd</span><br><span class="line">  800 root    4808 S    /usr/sbin/sshd</span><br></pre></td></tr></table></figure><h1 id="ssh-root-로그인-설정"><a href="#ssh-root-로그인-설정" class="headerlink" title="ssh root 로그인 설정"></a>ssh root 로그인 설정</h1><p>기본적으로 ssh는 root로 로그인이 불가능 합니다.</p><p>아래와 같은 방법으로 root로그인을 허용해 줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure><p>해당 파일에서 <code>PermitRootLogin</code>을 <code>yes</code>로 변경해 줍니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure><p>그 후 <code>reboot</code>을 합니다.</p><h1 id="ssh-접속"><a href="#ssh-접속" class="headerlink" title="ssh 접속"></a>ssh 접속</h1><p>기본적으로 wifi로 네트워크 접속이 필요합니다. wifi 접속 방법은 <a href="https://jung-max.github.io/2022/02/10/Linux-libcurl%20rk-roc3308b-plus-%EB%B3%B4%EB%93%9C-wifi-config/">여기</a>를 참고해주세요.</p><p>wifi 접속 후 <code>ifconfig</code>를 치면 <code>wlan0</code>에 ip주소가 표시됩니다.</p><p>해당 ip주소와 22번 port, id : root, password는 위에서 설정했던 것으로 ssh접속을 하면 됩니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/10/Linux-buildroot-%EB%B3%B4%EB%93%9C-ssh%EC%84%A4%EC%A0%95/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl example</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20example/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20example/</guid>
      <pubDate>Wed, 09 Feb 2022 07:31:07 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;libcurl-example&quot;&gt;&lt;a href=&quot;#libcurl-example&quot; class=&quot;headerlink&quot; title=&quot;libcurl example&quot;&gt;&lt;/a&gt;libcurl example&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://c
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="libcurl-example"><a href="#libcurl-example" class="headerlink" title="libcurl example"></a>libcurl example</h1><p><a href="https://curl.se/libcurl/c/example.html" rel="external nofollow noopener noreferrer" target="_blank">https://curl.se/libcurl/c/example.html</a>도 참고하세요.</p><p>libcurl용 기본 API는 C로 되어 있으므로 이 장은 C로 작성된 예제에 초점을 맞춥니다. 그러나 libcurl용 언어 바인딩이 얇기 때문에 일반적으로 거의 동일한 기능을 노출하므로 여전히 흥미롭고 교육적일 수 있습니다. 다른 언어도 마찬가지입니다.</p><h2 id="간단한-HTTP-페이지-가져오기"><a href="#간단한-HTTP-페이지-가져오기" class="headerlink" title="간단한 HTTP 페이지 가져오기"></a>간단한 HTTP 페이지 가져오기</h2><p>이 예제는 주어진 URL에서 HTML을 가져와서 stdout으로 보냅니다. 아마도 가장 간단한 libcurl 프로그램을 작성할 수 있습니다.</p><p>URL을 교체하면 물론 지원되는 다른 프로토콜을 통해서도 콘텐츠를 가져올 수 있습니다.</p><p>출력을 stdout으로 보내는 것은 기본 동작이며 일반적으로 실제로 원하는 것이 아닙니다. 대부분의 애플리케이션은 도착하는 데이터를 수신하기 위해 <a href="https://jung-max.github.io/2022/02/08/Linux-libcurl%20callback">쓰기 콜백</a>을 대신 설치합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  <span class="keyword">if</span>(curl) &#123;</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, <span class="string">"http://example.com/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Perform the request, res will get the return code */</span></span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line">    <span class="comment">/* Check for errors */</span></span><br><span class="line">    <span class="keyword">if</span>(res != CURLE_OK)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"curl_easy_perform() failed: %s\n"</span>,</span><br><span class="line">              curl_easy_strerror(res));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* always cleanup */</span></span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="메모리에-페이지-가져오기"><a href="#메모리에-페이지-가져오기" class="headerlink" title="메모리에 페이지 가져오기"></a>메모리에 페이지 가져오기</h2><p>이 예는 수신된 데이터를 stdout(종종 원하는 것이 아님)으로 보내는 대신 수신 데이터가 증가함에 따라 확장되는 메모리 버퍼에 수신 데이터를 저장하는 전자의 변형입니다.</p><p><a href="https://jung-max.github.io/2022/02/08/Linux-libcurl%20callback">쓰기 콜백</a>을 사용하여 데이터를 수신하여 이를 수행합니다.</p><p>이 예에서는 설정된 URL 체계와 함께 고정 URL 문자열을 사용하지만 물론 지원되는 다른 프로토콜을 사용하도록 이를 변경한 다음 대신 해당 프로토콜에서 리소스를 가져올 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MemoryStruct</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *memory;</span><br><span class="line">  <span class="keyword">size_t</span> <span class="built_in">size</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">size_t</span></span><br><span class="line">WriteMemoryCallback(<span class="keyword">void</span> *contents, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> nmemb, <span class="keyword">void</span> *userp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> realsize = <span class="built_in">size</span> * nmemb;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">MemoryStruct</span> *<span class="title">mem</span> = (<span class="title">struct</span> <span class="title">MemoryStruct</span> *)<span class="title">userp</span>;</span></span><br><span class="line"></span><br><span class="line">  mem-&gt;memory = <span class="built_in">realloc</span>(mem-&gt;memory, mem-&gt;<span class="built_in">size</span> + realsize + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span>(mem-&gt;memory == <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* out of memory */</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"not enough memory (realloc returned NULL)\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;(mem-&gt;memory[mem-&gt;<span class="built_in">size</span>]), contents, realsize);</span><br><span class="line">  mem-&gt;<span class="built_in">size</span> += realsize;</span><br><span class="line">  mem-&gt;memory[mem-&gt;<span class="built_in">size</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> realsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURL *curl_handle;</span><br><span class="line">  CURLcode res;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">MemoryStruct</span> <span class="title">chunk</span>;</span></span><br><span class="line"></span><br><span class="line">  chunk.memory = <span class="built_in">malloc</span>(<span class="number">1</span>);  <span class="comment">/* will be grown as needed by the realloc above */</span></span><br><span class="line">  chunk.<span class="built_in">size</span> = <span class="number">0</span>;    <span class="comment">/* no data at this point */</span></span><br><span class="line"></span><br><span class="line">  curl_global_init(CURL_GLOBAL_ALL);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* init the curl session */</span></span><br><span class="line">  curl_handle = curl_easy_init();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* specify URL to get */</span></span><br><span class="line">  curl_easy_setopt(curl_handle, CURLOPT_URL, <span class="string">"https://www.example.com/"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* send all data to this function  */</span></span><br><span class="line">  curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteMemoryCallback);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* we pass our 'chunk' struct to the callback function */</span></span><br><span class="line">  curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, (<span class="keyword">void</span> *)&amp;chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* some servers do not like requests that are made without a user-agent</span></span><br><span class="line"><span class="comment">     field, so we provide one */</span></span><br><span class="line">  curl_easy_setopt(curl_handle, CURLOPT_USERAGENT, <span class="string">"libcurl-agent/1.0"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* get it! */</span></span><br><span class="line">  res = curl_easy_perform(curl_handle);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* check for errors */</span></span><br><span class="line">  <span class="keyword">if</span>(res != CURLE_OK) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"curl_easy_perform() failed: %s\n"</span>,</span><br><span class="line">            curl_easy_strerror(res));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now, our chunk.memory points to a memory block that is chunk.size</span></span><br><span class="line"><span class="comment">     * bytes big and contains the remote file.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Do something nice with it!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lu bytes retrieved\n"</span>, (<span class="keyword">long</span>)chunk.<span class="built_in">size</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* cleanup curl stuff */</span></span><br><span class="line">  curl_easy_cleanup(curl_handle);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(chunk.memory);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* we are done with libcurl, so clean it up */</span></span><br><span class="line">  curl_global_cleanup();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTTP를-통해-로그인-양식-제출"><a href="#HTTP를-통해-로그인-양식-제출" class="headerlink" title="HTTP를 통해 로그인 양식 제출"></a>HTTP를 통해 로그인 양식 제출</h2><p>HTTP를 통한 로그인 제출은 일반적으로 POST에서 제출할 데이터와 전송할 대상 URL을 정확히 파악하는 문제입니다.</p><p>로그인한 후 적절한 쿠키를 사용하면 대상 URL을 가져올 수 있습니다. 많은 로그인 시스템이 HTTP 리디렉션과 함께 작동하므로 libcurl이 이러한 리디렉션이 도착하면 이를 따르도록 요청합니다.</p><p>일부 로그인 양식은 이를 더 복잡하게 만들고 로그인 양식 등을 보여주는 페이지에서 쿠키를 얻어야 하므로 필요한 경우 이 코드를 약간 확장할 수 있습니다.</p><p>존재하지 않는 쿠키 파일을 전달함으로써 이 예제는 쿠키 파서를 활성화하여 로그인 응답의 응답이 도착할 때 들어오는 쿠키가 저장되고 리소스에 대한 후속 요청이 쿠키를 사용하고 우리가 실제로 올바르게 로그인했습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *postthis = <span class="string">"user=daniel&amp;password=monkey123"</span>;</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  <span class="keyword">if</span>(curl) &#123;</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, <span class="string">"https://example.com/login.cgi"</span>);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, postthis);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, <span class="number">1L</span>); <span class="comment">/* redirects! */</span></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_COOKIEFILE, <span class="string">""</span>); <span class="comment">/* no file */</span></span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line">    <span class="comment">/* Check for errors */</span></span><br><span class="line">    <span class="keyword">if</span>(res != CURLE_OK)</span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"curl_easy_perform() failed: %s\n"</span>,</span><br><span class="line">              curl_easy_strerror(res));</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * After the login POST, we have received the new cookies. Switch</span></span><br><span class="line"><span class="comment">       * over to a GET and ask for the login-protected URL.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      curl_easy_setopt(curl, CURLOPT_URL, <span class="string">"https://example.com/file"</span>);</span><br><span class="line">      curl_easy_setopt(curl, CURLOPT_HTTPGET, <span class="number">1L</span>); <span class="comment">/* no more POST */</span></span><br><span class="line">      res = curl_easy_perform(curl);</span><br><span class="line">      <span class="comment">/* Check for errors */</span></span><br><span class="line">      <span class="keyword">if</span>(res != CURLE_OK)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"second curl_easy_perform() failed: %s\n"</span>,</span><br><span class="line">                curl_easy_strerror(res));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* always cleanup */</span></span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FTP-디렉토리-목록-가져오기"><a href="#FTP-디렉토리-목록-가져오기" class="headerlink" title="FTP 디렉토리 목록 가져오기"></a>FTP 디렉토리 목록 가져오기</h2><p>이 예제는 주어진 URL에서 FTP 디렉토리 출력을 가져와서 stdout으로 보냅니다. URL의 후행 슬래시는 libcurl이 이를 디렉토리로 처리하도록 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line">  CURLcode res;</span><br><span class="line"></span><br><span class="line">  curl_global_init(CURL_GLOBAL_DEFAULT);</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  <span class="keyword">if</span>(curl) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Make the URL end with a trailing slash!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, <span class="string">"ftp://ftp.example.com/"</span>);</span><br><span class="line"></span><br><span class="line">    res = curl_easy_perform(curl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* always cleanup */</span></span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(CURLE_OK != res) &#123;</span><br><span class="line">      <span class="comment">/* we failed */</span></span><br><span class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"curl told us %d\n"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  curl_global_cleanup();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Non-blocking-HTTP-form-post"><a href="#Non-blocking-HTTP-form-post" class="headerlink" title="Non-blocking HTTP form-post"></a>Non-blocking HTTP form-post</h2><p>이 예제는 다중 인터페이스를 사용하여 다중 파트 form-post를 만듭니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURL *curl;</span><br><span class="line"></span><br><span class="line">  CURLM *multi_handle;</span><br><span class="line">  <span class="keyword">int</span> still_running = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  curl_mime *form = <span class="literal">NULL</span>;</span><br><span class="line">  curl_mimepart *field = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">curl_slist</span> *<span class="title">headerlist</span> = <span class="title">NULL</span>;</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> buf[] = <span class="string">"Expect:"</span>;</span><br><span class="line"></span><br><span class="line">  curl = curl_easy_init();</span><br><span class="line">  multi_handle = curl_multi_init();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(curl &amp;&amp; multi_handle) &#123;</span><br><span class="line">    <span class="comment">/* Create the form */</span></span><br><span class="line">    form = curl_mime_init(curl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill in the file upload field */</span></span><br><span class="line">    field = curl_mime_addpart(form);</span><br><span class="line">    curl_mime_name(field, <span class="string">"sendfile"</span>);</span><br><span class="line">    curl_mime_filedata(field, <span class="string">"multi-post.c"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill in the filename field */</span></span><br><span class="line">    field = curl_mime_addpart(form);</span><br><span class="line">    curl_mime_name(field, <span class="string">"filename"</span>);</span><br><span class="line">    curl_mime_data(field, <span class="string">"multi-post.c"</span>, CURL_ZERO_TERMINATED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fill in the submit field too, even if this is rarely needed */</span></span><br><span class="line">    field = curl_mime_addpart(form);</span><br><span class="line">    curl_mime_name(field, <span class="string">"submit"</span>);</span><br><span class="line">    curl_mime_data(field, <span class="string">"send"</span>, CURL_ZERO_TERMINATED);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* initialize custom header list (stating that Expect: 100-continue is not</span></span><br><span class="line"><span class="comment">       wanted */</span></span><br><span class="line">    headerlist = curl_slist_append(headerlist, buf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* what URL that receives this POST */</span></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_URL, <span class="string">"https://www.example.com/upload.cgi"</span>);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_VERBOSE, <span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headerlist);</span><br><span class="line">    curl_easy_setopt(curl, CURLOPT_MIMEPOST, form);</span><br><span class="line"></span><br><span class="line">    curl_multi_add_handle(multi_handle, curl);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      CURLMcode mc = curl_multi_perform(multi_handle, &amp;still_running);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(still_running)</span><br><span class="line">        <span class="comment">/* wait for activity, timeout or "nothing" */</span></span><br><span class="line">        mc = curl_multi_poll(multi_handle, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1000</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span>(mc)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span>(still_running);</span><br><span class="line"></span><br><span class="line">    curl_multi_cleanup(multi_handle);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* always cleanup */</span></span><br><span class="line">    curl_easy_cleanup(curl);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* then cleanup the form */</span></span><br><span class="line">    curl_mime_free(form);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* free slist */</span></span><br><span class="line">    curl_slist_free_all(headerlist);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20example/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl Post transfer info</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Post%20transfer%20info/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Post%20transfer%20info/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Post-transfer-info&quot;&gt;&lt;a href=&quot;#Post-transfer-info&quot; class=&quot;headerlink&quot; title=&quot;Post transfer info&quot;&gt;&lt;/a&gt;Post transfer info&lt;/h1&gt;&lt;p&gt;libcur
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Post-transfer-info"><a href="#Post-transfer-info" class="headerlink" title="Post transfer info"></a>Post transfer info</h1><p>libcurl 전송이 “쉬운 핸들”과 어떻게 연관되어 있는지 기억하십시오! 각 전송에는 이러한 핸들이 있으며 전송이 완료되면 핸들을 정리하거나 다른 전송에 재사용하기 전에 이전 작업에서 정보를 추출하는 데 사용할 수 있습니다.</p><p>이 작업을 수행하는 친구를 <code>curl_easy_getinfo()</code>라고 하며 관심 있는 특정 정보를 알려주면 가능한 경우 해당 정보를 반환합니다.</p><p>이 함수를 사용할 때 원하는 정보와 답을 담을 변수에 대한 포인터를 쉽게 처리할 수 있습니다. 올바른 유형의 변수에 대한 포인터를 전달해야 합니다. 그렇지 않으면 일이 엉뚱한 방향으로 갈 위험이 있습니다. 이러한 정보 값은 전송이 완료된 후 제공되도록 설계되었습니다.</p><p>받는 데이터는 long, ‘char’, ‘struct curl_slist’, double 또는 socket일 수 있습니다.</p><p>이전 HTTP 전송에서 <code>Content-Type</code>: 값을 추출하는 방법은 다음과 같습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CURLcode res;</span><br><span class="line"><span class="keyword">char</span> *content_type;</span><br><span class="line">res = curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &amp;content_type);</span><br></pre></td></tr></table></figure><p>해당 연결에 사용된 로컬 포트 번호를 추출하려면 다음을 수행하십시오.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CURLcode res;</span><br><span class="line"><span class="keyword">long</span> port_number;</span><br><span class="line">res = curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT, &amp;port_number);</span><br></pre></td></tr></table></figure><h2 id="이용-가능한-정보"><a href="#이용-가능한-정보" class="headerlink" title="이용 가능한 정보"></a>이용 가능한 정보</h2><table><thead><tr><th align="left">Getinfo option</th><th align="left">Type</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">CURLINFO_ACTIVESOCKET</td><td align="left">curl_socket_t</td><td align="left">세션의 활성 소켓</td></tr><tr><td align="left">CURLINFO_APPCONNECT_TIME</td><td align="left">double</td><td align="left">시작부터 SSL/SSH 핸드셰이크가 완료될 때까지의 시간</td></tr><tr><td align="left">CURLINFO_APPCONNECT_TIME_T</td><td align="left">curl_off_t</td><td align="left">시작부터 SSL/SSH 핸드셰이크가 완료될 때까지의 시간(마이크로초)</td></tr><tr><td align="left">CURLINFO_CERTINFO</td><td align="left">struct curl_slist *</td><td align="left">인증서 체인</td></tr><tr><td align="left">CURLINFO_CONDITION_UNMET</td><td align="left">long</td><td align="left">시간 조건이 충족되었는지 여부</td></tr><tr><td align="left">CURLINFO_CONNECT_TIME</td><td align="left">double</td><td align="left">시작부터 원격 호스트 또는 프록시가 완료될 때까지의 시간</td></tr><tr><td align="left">CURLINFO_CONNECT_TIME_T</td><td align="left">curl_off_t</td><td align="left">시작부터 원격 호스트 또는 프록시가 완료될 때까지의 시간(마이크로초)</td></tr><tr><td align="left">CURLINFO_CONTENT_LENGTH_DOWNLOAD</td><td align="left">double</td><td align="left">Content-Length 헤더의 콘텐츠 길이</td></tr><tr><td align="left">CURLINFO_CONTENT_LENGTH_UPLOAD</td><td align="left">double</td><td align="left">업로드 크기</td></tr><tr><td align="left">CURLINFO_CONTENT_TYPE</td><td align="left">char *</td><td align="left">Content-Type 헤더의 콘텐츠 유형</td></tr><tr><td align="left">CURLINFO_COOKIELIST</td><td align="left">struct curl_slist *</td><td align="left">알려진 모든 쿠키 목록</td></tr><tr><td align="left">CURLINFO_EFFECTIVE_METHOD</td><td align="left">char *</td><td align="left">마지막으로 사용한 HTTP 요청 방법</td></tr><tr><td align="left">CURLINFO_EFFECTIVE_URL</td><td align="left">char *</td><td align="left">마지막으로 사용한 URL</td></tr><tr><td align="left">CURLINFO_PROXY_SSL_VERIFYRESULT</td><td align="left">long</td><td align="left">프록시 인증서 확인 결과</td></tr><tr><td align="left">CURLINFO_PROXYAUTH_AVAIL</td><td align="left">long</td><td align="left">사용 가능한 HTTP 프록시 인증 방법</td></tr><tr><td align="left">CURLINFO_REDIRECT_COUNT</td><td align="left">long</td><td align="left">팔로우한 총 리디렉션 수</td></tr><tr><td align="left">CURLINFO_REDIRECT_TIME</td><td align="left">double</td><td align="left">최종 전송 전 모든 리디렉션 단계에 소요된 시간</td></tr><tr><td align="left">CURLINFO_REDIRECT_TIME_T</td><td align="left">curl_off_t</td><td align="left">최종 전송 전 모든 리디렉션 단계에 소요된 시간(마이크로초)</td></tr><tr><td align="left">CURLINFO_REDIRECT_URL</td><td align="left">char *</td><td align="left">리디렉션을 활성화한 경우 리디렉션을 통해 이동할 URL</td></tr><tr><td align="left">CURLINFO_REQUEST_SIZE</td><td align="left">long</td><td align="left">발행된 HTTP 요청에서 보낸 바이트 수</td></tr><tr><td align="left">CURLINFO_RESPONSE_CODE</td><td align="left">long</td><td align="left">마지막으로 받은 응답 코드</td></tr><tr><td align="left">CURLINFO_RETRY_AFTER</td><td align="left">curl_off_t</td><td align="left">응답 Retry-After: 헤더의 값</td></tr><tr><td align="left">CURLINFO_RTSP_CLIENT_CSEQ</td><td align="left">long</td><td align="left">다음에 사용될 RTSP CSeq</td></tr><tr><td align="left">CURLINFO_RTSP_CSEQ_RECV</td><td align="left">long</td><td align="left">RTSP CSeq 마지막 수신</td></tr><tr><td align="left">CURLINFO_RTSP_SERVER_CSEQ</td><td align="left">long</td><td align="left">다음에 예상되는 RTSP CSeq</td></tr><tr><td align="left">CURLINFO_RTSP_SESSION_ID</td><td align="left">char *</td><td align="left">RTSP 세션 ID</td></tr><tr><td align="left">CURLINFO_SCHEME</td><td align="left">char *</td><td align="left">연결에 사용된 체계</td></tr><tr><td align="left">CURLINFO_SIZE_DOWNLOAD</td><td align="left">double</td><td align="left">다운로드된 바이트 수</td></tr><tr><td align="left">CURLINFO_SIZE_UPLOAD</td><td align="left">double</td><td align="left">업로드된 바이트 수</td></tr><tr><td align="left">CURLINFO_SPEED_DOWNLOAD</td><td align="left">double</td><td align="left">평균 다운로드 속도</td></tr><tr><td align="left">CURLINFO_SPEED_UPLOAD</td><td align="left">double</td><td align="left">평균 업로드 속도</td></tr><tr><td align="left">CURLINFO_SSL_ENGINES</td><td align="left">struct curl_slist *</td><td align="left">OpenSSL 암호화 엔진 목록</td></tr><tr><td align="left">CURLINFO_SSL_VERIFYRESULT</td><td align="left">long</td><td align="left">인증서 확인 결과</td></tr><tr><td align="left">CURLINFO_STARTTRANSFER_TIME</td><td align="left">double</td><td align="left">시작부터 첫 번째 바이트가 수신될 때까지의 시간</td></tr><tr><td align="left">CURLINFO_STARTTRANSFER_TIME_T</td><td align="left">curl_off_t</td><td align="left">시작부터 첫 번째 바이트가 수신될 때까지의 시간(마이크로초)</td></tr><tr><td align="left">CURLINFO_TLS_SSL_PTR</td><td align="left">struct curl_slist *</td><td align="left">추가 처리에 사용할 수 있는 TLS 세션 정보</td></tr><tr><td align="left">CURLINFO_TOTAL_TIME</td><td align="left">double</td><td align="left">이전 전송의 총 시간</td></tr><tr><td align="left">CURLINFO_TOTAL_TIME_T</td><td align="left">curl_off_t</td><td align="left">이전 전송의 총 시간(마이크로초)</td></tr></tbody></table>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Post%20transfer%20info/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl multi-threading</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20multi-threading/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20multi-threading/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;multi-threading&quot;&gt;&lt;a href=&quot;#multi-threading&quot; class=&quot;headerlink&quot; title=&quot;multi-threading&quot;&gt;&lt;/a&gt;multi-threading&lt;/h1&gt;&lt;p&gt;libcurl은 스레드로부터 안전
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="multi-threading"><a href="#multi-threading" class="headerlink" title="multi-threading"></a>multi-threading</h1><p>libcurl은 스레드로부터 안전하지만 내부 스레드 동기화가 없습니다. libcurl 스레드를 올바르게 사용하려면 고유한 잠금을 제공하거나 옵션을 변경해야 할 수 있습니다. 정확히 필요한 것은 libcurl이 빌드된 방식에 따라 다릅니다. 최신 정보가 포함된 libcurl <a href="https://curl.se/libcurl/c/threadsafe.html" rel="external nofollow noopener noreferrer" target="_blank">스레드 안전 웹페이지</a>를 참조하십시오.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20multi-threading/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl CURL코드 리턴 코드</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20CURL%EC%BD%94%EB%93%9C%20%EB%A6%AC%ED%84%B4%20%EC%BD%94%EB%93%9C/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20CURL%EC%BD%94%EB%93%9C%20%EB%A6%AC%ED%84%B4%20%EC%BD%94%EB%93%9C/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;CURL코드-리턴-코드&quot;&gt;&lt;a href=&quot;#CURL코드-리턴-코드&quot; class=&quot;headerlink&quot; title=&quot;CURL코드 리턴 코드&quot;&gt;&lt;/a&gt;CURL코드 리턴 코드&lt;/h1&gt;&lt;p&gt;많은 libcurl 함수는 CURLcode를 반환합니다
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="CURL코드-리턴-코드"><a href="#CURL코드-리턴-코드" class="headerlink" title="CURL코드 리턴 코드"></a>CURL코드 리턴 코드</h1><p>많은 libcurl 함수는 CURLcode를 반환합니다. 그것은 오류 코드에 대한 특별한 libcurl typedeffed 변수입니다. 모든 것이 훌륭하고 멋지면 <code>CURLE_OK</code>(값이 0임)를 반환하고 문제가 감지되면 0이 아닌 숫자를 반환합니다. 거의 100개의 <code>CURLcode</code> 오류가 사용 중이며, 모두 <code>curl/curl.h</code> 헤더 파일에서 찾을 수 있으며 libcurl-errors 매뉴얼 페이지에 문서화되어 있습니다.</p><p><code>curl_easy_strerror()</code> 함수를 사용하여 CURLcode를 사람이 읽을 수 있는 문자열로 변환할 수 있습니다. 그러나 이러한 오류는 UI 또는 최종 사용자에게 노출하기에 적합한 방식으로 표현되는 경우가 거의 없다는 점에 유의하십시오.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = curl_easy_strerror( error );</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"libcurl said %s\n"</span>, str);</span><br></pre></td></tr></table></figure><p>오류가 발생했을 때 약간 더 나은 오류 텍스트를 얻는 또 다른 방법은 프로그램의 버퍼를 가리키도록 <code>CURLOPT_ERRORBUFFER</code> 옵션을 설정하는 것입니다. 그러면 libcurl은 오류를 반환하기 전에 관련 오류 메시지를 그곳에 저장합니다:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> error[CURL_ERROR_SIZE]; <span class="comment">/* needs to be at least this big */</span></span><br><span class="line">CURLcode ret = curl_easy_setopt(handle, CURLOPT_ERRORBUFFER, error);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20CURL%EC%BD%94%EB%93%9C%20%EB%A6%AC%ED%84%B4%20%EC%BD%94%EB%93%9C/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl URL API</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20URL%20API/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20URL%20API/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;URL-API&quot;&gt;&lt;a href=&quot;#URL-API&quot; class=&quot;headerlink&quot; title=&quot;URL API&quot;&gt;&lt;/a&gt;URL API&lt;/h1&gt;&lt;p&gt;libcurl은 URL을 구문 분석, 업데이트 및 생성하기 위한 API를 제공합니다. 이를
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="URL-API"><a href="#URL-API" class="headerlink" title="URL API"></a>URL API</h1><p>libcurl은 URL을 구문 분석, 업데이트 및 생성하기 위한 API를 제공합니다. 이를 사용하여 응용 프로그램은 자체 목적을 위해 libcurl의 URL 파서를 사용할 수 있습니다. 동일한 파서를 사용함으로써 다른 해석으로 인한 보안 문제를 피할 수 있습니다.</p><h2 id="Include-files"><a href="#Include-files" class="headerlink" title="Include files"></a>Include files</h2><p>URL API를 사용하려는 경우 코드에 <code>&lt;curl/curl.h&gt;</code>를 포함합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">CURLU *h = curl_url();</span><br><span class="line">rc = curl_url_set(h, CURLUPART_URL, <span class="string">"ftp://example.com/no/where"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="Create-cleanup-duplicate"><a href="#Create-cleanup-duplicate" class="headerlink" title="Create, cleanup, duplicate"></a>Create, cleanup, duplicate</h2><p>이 API를 사용하는 첫 번째 단계는 URL 정보와 리소스를 보유하는 <code>CURLU *</code> 핸들을 만드는 것입니다. 핸들은 단일 URL 및 모든 다른 구성 요소에 대한 정보를 보유하는 연결된 데이터 개체에 대한 참조입니다.</p><p>API를 사용하면 각 URL 구성 요소를 개별적으로 또는 전체 URL로 설정하거나 가져올 수 있습니다.</p><p>다음과 같이 URL 핸들을 만듭니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURLU *h = curl_url();</span><br></pre></td></tr></table></figure><p>완료되면 정리하십시오.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_url_cleanup(h);</span><br></pre></td></tr></table></figure><p>핸들 사본이 필요하면 복사하십시오.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURLU *nh = curl_url_dup(h);</span><br></pre></td></tr></table></figure><h2 id="Parse-a-URL"><a href="#Parse-a-URL" class="headerlink" title="Parse a URL"></a>Parse a URL</h2><p>핸들에서 <code>CURLUPART_URL</code> 부분을 설정하여 전체 URL을 구문 분석합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CURLU *h = curl_url();</span><br><span class="line">rc = curl_url_set(h, CURLUPART_URL,</span><br><span class="line">                  <span class="string">"https://example.com:449/foo/bar?name=moo"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>성공하면 rc에 CURLUE_OK가 포함되고 다른 URL 구성 요소가 핸들에 유지됩니다. libcurl에 관한 한 URL이 유효했음을 의미합니다.</p><p>함수 호출의 네 번째 인수는 특정 기능을 변경하기 위한 비트마스크입니다. 파서의 동작을 변경하기 위해 비트를 하나만 더 설정할 수 있습니다.</p><h3 id="CURLU-NON-SUPPORT-SCHEME"><a href="#CURLU-NON-SUPPORT-SCHEME" class="headerlink" title="CURLU_NON_SUPPORT_SCHEME"></a>CURLU_NON_SUPPORT_SCHEME</h3><p><code>curl_url_set()</code>이 지원되지 않는 체계를 허용하도록 합니다. 설정하지 않으면 libcurl이 알고 있고 지원하는 내장 프로토콜에 대한 유일한 구성표가 허용됩니다.</p><h3 id="CURLU-URLENCODE"><a href="#CURLU-URLENCODE" class="headerlink" title="CURLU_URLENCODE"></a>CURLU_URLENCODE</h3><p>공백 또는 “제어 문자”와 같은 이점이 있는 바이트가 있는 경우 함수 URL이 경로 부분을 인코딩하도록 합니다.</p><h3 id="CURLU-DEFAULT-SCHEME"><a href="#CURLU-DEFAULT-SCHEME" class="headerlink" title="CURLU_DEFAULT_SCHEME"></a>CURLU_DEFAULT_SCHEME</h3><p>전달된 문자열이 체계를 사용하지 않는 경우 기본 체계를 의도한 것으로 가정합니다. 기본 체계는 HTTPS입니다. 이것이 설정되지 않으면 스킴 부분이 없는 URL은 유효한 것으로 승인되지 않습니다. 둘 다 설정된 경우 <code>CURLU_GUESS_SCHEME</code> 옵션을 재정의합니다.</p><h3 id="CURLU-GUESS-SCHEME"><a href="#CURLU-GUESS-SCHEME" class="headerlink" title="CURLU_GUESS_SCHEME"></a>CURLU_GUESS_SCHEME</h3><p>libcurl이 URL이 스키마 없이 설정되도록 하고 대신 호스트 이름을 기반으로 의도한 스키마를 “추측”합니다. 가장 바깥쪽 하위 도메인 이름이 DICT, FTP, IMAP, LDAP, POP3 또는 SMTP와 일치하면 해당 체계가 사용되며, 그렇지 않으면 HTTP를 선택합니다. 둘 다 설정된 경우 우선적으로 적용되는 <code>CURLU_DEFAULT_SCHEME</code> 옵션과 충돌합니다.</p><h3 id="CURLU-NO-AUTHORITY"><a href="#CURLU-NO-AUTHORITY" class="headerlink" title="CURLU_NO_AUTHORITY"></a>CURLU_NO_AUTHORITY</h3><p>권한 검사를 건너뜁니다. RFC는 개별 체계가 호스트 부분(일반적으로 권한의 유일한 필수 부분)을 생략하도록 허용하지만 libcurl은 이것이 사용자 지정 체계에 허용되는지 여부를 알 수 없습니다. 플래그를 지정하면 파일 구성표가 처리되는 방식과 유사한 빈 권한 섹션이 허용됩니다. <code>CURLU_NON_SUPPORT_SCHEME</code>와 조합해서만 사용할 수 있습니다.</p><h3 id="CURLU-PATH-AS-IS"><a href="#CURLU-PATH-AS-IS" class="headerlink" title="CURLU_PATH_AS_IS"></a>CURLU_PATH_AS_IS</h3><p>libcurl이 경로의 정규화를 건너뛰게 합니다. 이것은 curl이 점-슬래시 및 점-점 등의 시퀀스를 제거하는 절차입니다. 전송에 사용되는 동일한 옵션을 <code>CURLOPT_PATH_AS_IS</code>라고 합니다.</p><h3 id="CURLU-ALLOW-SPACE"><a href="#CURLU-ALLOW-SPACE" class="headerlink" title="CURLU_ALLOW_SPACE"></a>CURLU_ALLOW_SPACE</h3><p>URL 파서가 가능한 경우 공간(ASCII 32)을 허용하도록 합니다. URL 구문은 일반적으로 공백을 허용하지 않지만 <code>%20</code> 또는 <code>+</code>로 인코딩해야 합니다. 공백이 허용되면 스키마에서 여전히 허용되지 않습니다. URL에서 공간이 사용되고 허용되면 <code>CURLU_URLENCODE</code>도 설정되지 않는 한 그대로 저장됩니다. 그러면 libcurl이 저장하기 전에 공간을 URL로 인코딩합니다. 이는 전체 URL 또는 개별 부분을 추출하기 위해 <code>curl_url_get()</code>을 사용할 때 URL이 구성되는 방식에 영향을 줍니다.</p><h2 id="상대-URL로-리디렉션"><a href="#상대-URL로-리디렉션" class="headerlink" title="상대 URL로 리디렉션"></a>상대 URL로 리디렉션</h2><p>핸들이 이미 URL을 구문 분석한 경우 두 번째 상대 URL을 설정하면 이에 맞게 “리디렉션”됩니다.</p><p>예를 들어, 먼저 원래 URL을 설정한 다음 “리디렉션”할 URL을 다음으로 설정합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CURLU *h = curl_url();</span><br><span class="line">rc = curl_url_set(h, CURLUPART_URL,</span><br><span class="line">                  <span class="string">"https://example.com/foo/bar?name=moo"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">rc = curl_url_set(h, CURLUPART_URL, <span class="string">"../test?another"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="Get-a-URL"><a href="#Get-a-URL" class="headerlink" title="Get a URL"></a>Get a URL</h2><p><code>CURLU *</code> 핸들은 URL 또는 URL의 일부를 나타내며 언제든지 해당 URL을 쉽게 추출할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *url;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_URL, &amp;url, CURLU_NO_DEFAULT_PORT);</span><br><span class="line">curl_free(url);</span><br></pre></td></tr></table></figure><p>핸들에 전체 URL을 추가하기에 충분한 정보가 없으면 오류를 반환합니다.<br>반환된 문자열은 작업을 마친 후 <code>curl_free()</code>로 해제해야 합니다.<br>함수 호출의 네 번째 인수에서 0은 특정 기능을 변경하기 위한 플래그 비트마스크입니다.</p><h3 id="CURLU-DEFAULT-PORT"><a href="#CURLU-DEFAULT-PORT" class="headerlink" title="CURLU_DEFAULT_PORT"></a>CURLU_DEFAULT_PORT</h3><p>URL 핸들에 저장된 포트 번호가 없는 경우 이 옵션은 <code>curl_url_get()</code>이 사용된 체계에 대한 기본 포트를 반환하도록 합니다.</p><h3 id="CURLU-DEFAULT-SCHEME-1"><a href="#CURLU-DEFAULT-SCHEME-1" class="headerlink" title="CURLU_DEFAULT_SCHEME"></a>CURLU_DEFAULT_SCHEME</h3><p>핸들에 저장된 체계가 없는 경우 이 옵션은 <code>curl_url_get()</code>이 오류 대신 기본 체계를 반환하도록 합니다.</p><h3 id="CURLU-NO-DEFAULT-PORT"><a href="#CURLU-NO-DEFAULT-PORT" class="headerlink" title="CURLU_NO_DEFAULT_PORT"></a>CURLU_NO_DEFAULT_PORT</h3><p>포트 번호가 스키마에 사용된 기본 포트와 일치하는 경우 생성된 URL에서 포트 번호를 사용하지 않도록 <code>curl_url_get()</code>에 지시합니다. 예를 들어 포트 번호 443이 설정되고 스키마가 https인 경우 추출된 URL에는 포트 번호가 포함되지 않습니다.</p><h3 id="CURLU-URLENCODE-1"><a href="#CURLU-URLENCODE-1" class="headerlink" title="CURLU_URLENCODE"></a>CURLU_URLENCODE</h3><p>설정하면 전체 URL이 검색될 때 <code>curl_url_get()</code> URL이 호스트 이름 부분을 인코딩하도록 합니다. 설정되지 않은 경우(기본값) libcurl은 IDN 이름이 있는 그대로 표시되도록 지원하기 위해 호스트 이름이 “raw”인 URL을 반환합니다. IDN 호스트 이름은 일반적으로 비ASCII 바이트를 사용하며 그렇지 않으면 백분율로 인코딩됩니다.</p><p>URL 인코딩을 요청하지 않는 경우에도 <code>%</code>(바이트 37)는 호스트 이름이 유효한지 확인하기 위해 호스트 이름에서 URL로 인코딩됩니다.</p><h2 id="개별-URL-부분-가져오기"><a href="#개별-URL-부분-가져오기" class="headerlink" title="개별 URL 부분 가져오기"></a>개별 URL 부분 가져오기</h2><p>URL이 구문 분석되었거나 개별 부분이 <code>CURLU</code> 핸들에 설정된 경우 언제든지 핸들에서 해당 부분을 다시 추출할 수 있습니다.</p><p><code>curl_url_get()</code>에 대한 두 번째 인수는 추출할 부분을 지정합니다. 그것들은 모두 null로 끝나는 <code>char *</code> 데이터로 추출되므로 이러한 변수에 대한 포인터를 전달합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *host;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_HOST, &amp;host, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *scheme;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_SCHEME, &amp;scheme, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *user;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_USER, &amp;user, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *password;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_PASSWORD, &amp;password, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *port;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_PORT, &amp;port, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *path;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_PATH, &amp;path, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *query;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_QUERY, &amp;query, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *fragment;</span><br><span class="line">rc = curl_url_get(h, CURLUPART_FRAGMENT, &amp;fragment, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>작업이 끝나면 반환된 문자열을 curl_free로 해제하는 것을 잊지 마십시오!</p><p>추출된 부분은 사용자가 <code>CURLU_URLDECODE</code> 플래그로 요청하지 않는 한 URL 디코딩되지 않습니다.</p><h2 id="개별-URL-부분-설정"><a href="#개별-URL-부분-설정" class="headerlink" title="개별 URL 부분 설정"></a>개별 URL 부분 설정</h2><p>API를 사용하면 전체 URL을 구문 분석하거나 구문 분석하는 대신 <code>CURLU</code> 핸들에 보관된 URL의 개별 부분을 애플리케이션에서 설정할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rc = curl_url_set(urlp, CURLUPART_HOST, <span class="string">"www.example.com"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_SCHEME, <span class="string">"https"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_USER, <span class="string">"john"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_PASSWORD, <span class="string">"doe"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_PORT, <span class="string">"443"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_PATH, <span class="string">"/index.html"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_QUERY, <span class="string">"name=john"</span>, <span class="number">0</span>);</span><br><span class="line">rc = curl_url_set(urlp, CURLUPART_FRAGMENT, <span class="string">"anchor"</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>API는 항상 세 번째 인수에서 null로 끝나는 <code>char *</code> 문자열을 예상하거나 필드를 지우려면 NULL을 예상합니다. 포트 번호도 이런 식으로 문자열로 제공됩니다.</p><p>사용자가 네 번째 인수에서 <code>CURLU_URLENCODE</code> 플래그를 사용하여 요청하지 않는 한 설정 부분은 URL로 인코딩되지 않습니다.</p><h2 id="쿼리에-추가"><a href="#쿼리에-추가" class="headerlink" title="쿼리에 추가"></a>쿼리에 추가</h2><p>응용 프로그램은 <code>CURLU_APPENDQUERY</code> 플래그를 사용하여 기존 쿼리 부분의 오른쪽 끝에 문자열을 추가할 수 있습니다.</p><p>URL <code>https://example.com/?shoes=2</code>를 보유하는 핸들을 고려하십시오. 그러면 애플리케이션은 다음과 같이 쿼리 부분에 문자열 <code>hat=1</code>을 추가할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rc = curl_url_set(urlp, CURLUPART_QUERY, <span class="string">"hat=1"</span>, CURLU_APPENDQUERY);</span><br></pre></td></tr></table></figure><p>앰퍼샌드(&amp;) 구분 기호가 없는 경우에도 이를 삽입하므로 핸들의 전체 URL은 <code>https://example.com/?shoes=2&amp;hat=1</code>과 같습니다.</p><p>추가된 문자열은 물론 추가 시 인코딩된 URL을 얻을 수도 있으며, 요청하는 경우 인코딩은 ‘=’ 문자를 건너뜁니다. 예를 들어, 우리가 이미 가지고 있는 것에 <code>candy=M&amp;M</code>을 추가하고 데이터의 앰퍼샌드를 처리하기 위해 그것을 URL 인코딩합니다:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rc = curl_url_set(urlp, CURLUPART_QUERY, <span class="string">"candy=M&amp;M"</span>,</span><br><span class="line">                  CURLU_APPENDQUERY | CURLU_URLENCODE);</span><br></pre></td></tr></table></figure><p>이제 URL은 <code>https://example.com/?shoes=2&amp;hat=1&amp;candy=M%26M</code>과 같습니다.</p><h2 id="CURLOPT-CURLU"><a href="#CURLOPT-CURLU" class="headerlink" title="CURLOPT_CURLU"></a>CURLOPT_CURLU</h2><p>응용 프로그램의 편의를 위해 <code>CURLOPT_URL</code>의 대안으로 이미 구문 분석된 URL을 libcurl에 전달할 수 있습니다.</p><p><code>CURLOPT_CURLU</code> 옵션을 사용하여 URL 문자열 대신 <code>CURLU</code> 핸들을 전달합니다.<br>예시:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CURLU *h = curl_url();</span><br><span class="line">rc = curl_url_set(h, CURLUPART_URL, <span class="string">"https://example.com/"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">CURL *easy = curl_easy_init();</span><br><span class="line">curl_easy_setopt(easy, CURLOPT_CURLU, h);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20URL%20API/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl Proxies</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Proxies/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Proxies/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;프록시&quot;&gt;&lt;a href=&quot;#프록시&quot; class=&quot;headerlink&quot; title=&quot;프록시&quot;&gt;&lt;/a&gt;프록시&lt;/h1&gt;&lt;p&gt;네트워크 컨텍스트에서 프록시는 중개자, 즉 클라이언트인 귀하와 통신하려는 원격 서버 사이에 있는 서버입니다. 클라이언트
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="프록시"><a href="#프록시" class="headerlink" title="프록시"></a>프록시</h1><p>네트워크 컨텍스트에서 프록시는 중개자, 즉 클라이언트인 귀하와 통신하려는 원격 서버 사이에 있는 서버입니다. 클라이언트는 중간 사람에게 연락한 다음 계속해서 원격 서버에 연락합니다.</p><p>이 스타일의 프록시 사용은 회사와 조직에서 사용하는 경우가 있으며, 이 경우 일반적으로 대상 서버에 도달하기 위해 사용해야 합니다.</p><p>프록시와 통신할 때 사용할 여러 종류의 프록시와 프로토콜이 있으며 libcurl은 가장 일반적인 몇 가지 프록시 프로토콜을 지원합니다. 프록시에 사용되는 프로토콜이 원격 서버에 사용되는 프로토콜과 반드시 같지는 않다는 점을 인식하는 것이 중요합니다.</p><p>libcurl로 전송을 설정할 때 프록시의 서버 이름과 포트 번호를 지적해야 합니다. 여러분이 즐겨 사용하는 브라우저가 libcurl보다 약간 더 고급 방식으로 이 작업을 수행할 수 있다는 것을 알게 될 것입니다. 이러한 세부 사항은 이후 섹션에서 다룰 것입니다.</p><h2 id="프록시-유형"><a href="#프록시-유형" class="headerlink" title="프록시 유형"></a>프록시 유형</h2><p>libcurl은 SOCKS 및 HTTP 프록시의 두 가지 주요 프록시 유형을 지원합니다. 보다 구체적으로, 원격 이름 조회가 있거나 없는 SOCKS4 및 SOCKS5와 로컬 프록시에 대한 HTTP 및 HTTPS를 모두 지원합니다.</p><p>말하는 프록시의 종류를 지정하는 가장 쉬운 방법은 프록시 호스트 이름 문자열(<code>CURLOPT_PROXY</code>)의 구성표 부분을 일치하도록 설정하는 것입니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socks4:<span class="comment">//proxy.example.com:12345/</span></span><br><span class="line">socks4a:<span class="comment">//proxy.example.com:12345/</span></span><br><span class="line">socks5:<span class="comment">//proxy.example.com:12345/</span></span><br><span class="line">socks5h:<span class="comment">//proxy.example.com:12345/</span></span><br><span class="line">http:<span class="comment">//proxy.example.com:12345/</span></span><br><span class="line">https:<span class="comment">//proxy.example.com:12345/</span></span><br></pre></td></tr></table></figure><ul><li><code>socks4</code> - 로컬 이름 확인이 있는 SOCKS4를 의미합니다.</li><li><code>socks4a</code> - 프록시 이름이 확인되는 SOCKS4를 의미합니다.</li><li><code>socks5</code> - 로컬 이름 확인이 있는 SOCKS5를 의미합니다.</li><li><code>socks5h</code> - 프록시 이름이 확인되는 SOCKS5를 의미합니다.</li><li><code>http</code> - 프록시가 항상 이름을 확인할 수 있도록 하는 HTTP를 의미합니다.</li><li><code>https</code> - 프록시에 대한 HTTPS를 의미하며 항상 프록시가 이름을 확인할 수 있습니다(HTTPS 프록시 지원은 최근 curl 7.52.0에 추가되었으며 OpenSSL, GnuTLS 및 NSS와 같은 TLS 라이브러리의 하위 집합에서만 작동합니다. )</li></ul><p><code>CURLOPT_PROXYTYPE</code>을 사용하여 호스트 이름만 설정하려는 경우 별도의 옵션으로 프록시 유형을 설정하도록 선택할 수도 있습니다. 마찬가지로 <code>CURLOPT_PROXYPORT</code>와 함께 사용할 프록시 포트 번호를 설정할 수 있습니다.</p><h2 id="로컬-또는-프록시-이름-조회"><a href="#로컬-또는-프록시-이름-조회" class="headerlink" title="로컬 또는 프록시 이름 조회"></a>로컬 또는 프록시 이름 조회</h2><p>위의 섹션에서 서로 다른 프록시 설정을 통해 전송에 관련된 다른 당사자가 이름 확인을 수행할 수 있음을 알 수 있습니다. 여러 경우에 클라이언트가 서버 호스트 이름을 확인하고 연결할 프록시에 IP 주소를 전달하도록 할 수 있습니다. 물론 이름 조회가 클라이언트 시스템에서 정확하게 작동한다고 가정합니다. 프록시가 이름을 확인하도록 합니다. 연결할 IP 주소로 변환합니다.</p><p>HTTP 또는 HTTPS 프록시를 사용하는 경우 항상 확인할 프록시에 이름을 지정합니다.</p><h2 id="어떤-프록시"><a href="#어떤-프록시" class="headerlink" title="어떤 프록시?"></a>어떤 프록시?</h2><p>네트워크 연결에서 목적지에 도달하기 위해 프록시를 사용해야 하는 경우, 이를 파악하고 올바른 프록시를 사용하도록 libcurl에 알려야 합니다. libcurl에서는 프록시를 자동으로 파악하거나 감지하도록 지원하지 않습니다.</p><p>브라우저를 사용할 때 프록시에 PAC 스크립트 또는 기타 수단을 제공하는 것이 일반적이지만 libcurl에서는 그 중 어느 것도 인식하지 못합니다.</p><h3 id="프록시-환경-변수"><a href="#프록시-환경-변수" class="headerlink" title="프록시 환경 변수"></a>프록시 환경 변수</h3><p>프록시 옵션이 설정되지 않은 경우 libcurl은 프록시가 사용되도록 요청되었는지 확인하기 위해 전송을 수행하기 전에 특별히 명명된 환경 변수의 존재를 확인합니다.</p><p>프록시 호스트 이름을 보유하도록 <code>[scheme]_proxy</code>라는 변수를 설정하여 프록시를 지정할 수 있습니다(호스트를 -x로 지정하는 것과 동일한 방식). 따라서 HTTP 서버에 접근할 때 프록시를 사용하도록 curl에 지시하려면 ‘http_proxy’ 환경 변수를 설정합니다. 이와 같이:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://proxy.example.com:80</span><br></pre></td></tr></table></figure><p>위의 프록시 예제는 HTTP용이지만 물론 프록시하려는 특정 프로토콜에 대해 <code>ftp_proxy</code>, <code>https_proxy</code> 등을 설정할 수도 있습니다. http_proxy를 제외한 이러한 모든 프록시 환경 변수 이름은 <code>HTTPS_PROXY</code>와 같이 대문자로 지정할 수도 있습니다.</p><p>모든 프로토콜을 제어하는 단일 변수를 설정하기 위해 <code>ALL_PROXY</code>가 존재합니다. 특정 프로토콜 변수가 있는 경우 해당 변수가 우선 적용됩니다.</p><p>환경 변수를 사용하여 프록시를 설정할 때 하나 또는 몇 개의 호스트 이름이 프록시를 통과하지 못하도록 제외되어야 하는 상황에 쉽게 도달할 수 있습니다. 이것은 <code>NO_PROXY</code> 변수 또는 해당 <code>CURLOPT_NOPROXY</code> libcurl 옵션을 사용하여 수행할 수 있습니다. 액세스할 때 프록시를 사용하지 않아야 하는 쉼표로 구분된 호스트 이름 목록으로 설정합니다. 모든 호스트와 일치하도록 NO_PROXY를 단일 별표(‘*’)로 설정할 수 있습니다.</p><h2 id="HTTP-프록시"><a href="#HTTP-프록시" class="headerlink" title="HTTP 프록시"></a>HTTP 프록시</h2><p>HTTP 프로토콜은 HTTP 프록시를 사용하는 방법에 대해 자세히 설명합니다. 실제 원격 서버에 요청을 보내는 대신 클라이언트(libcurl)는 대신 프록시에 특정 리소스를 요청합니다. HTTP 프록시에 대한 연결은 암호화되지 않은 일반 HTTP를 사용하여 이루어집니다.</p><p>HTTPS 리소스가 요청되면 libcurl은 대신 프록시에 CONNECT 요청을 발행합니다. 이러한 요청은 프록시를 통해 터널을 열어 데이터를 이해하지 못한 채 전달합니다. 이런 식으로 libcurl은 HTTP 프록시가 있는 경우에도 안전한 종단 간 TLS 연결을 설정할 수 있습니다.</p><p>HTTP 프록시를 통해 비 HTTP 프로토콜을 프록시할 수 있지만 이는 대부분 CONNECT 메서드를 통해 데이터를 터널링하여 수행되기 때문에 클라이언트가 다른 특정 원격 포트 번호에 연결할 수 있도록 프록시를 구성해야 합니다. 많은 HTTP 프록시는 80 및 443 이외의 다른 포트 번호에 대한 연결을 금지하도록 설정됩니다.</p><h2 id="HTTPS-프록시"><a href="#HTTPS-프록시" class="headerlink" title="HTTPS 프록시"></a>HTTPS 프록시</h2><p>HTTPS 프록시는 HTTP 프록시와 유사하지만 클라이언트가 보안 HTTPS 연결을 사용하여 연결할 수 있습니다. 이 경우에도 프록시 연결은 원격 사이트와의 연결과 분리되어 있으므로 원격 사이트에 대한 HTTPS는 프록시에 대한 HTTPS 연결을 통해 터널링되므로 libcurl은 별도의 프록시 연결에 대한 전체 TLS 옵션 집합을 제공합니다. 원격 호스트에 대한 연결에서.</p><p>예를 들어, <code>CURLOPT_PROXY_CAINFO</code>는 <code>CURLOPT_CAINFO</code>가 원격 호스트를 위한 것과 같은 HTTPS 프록시의 기능입니다. <code>CURLOPT_PROXY_SSL_VERIFYPEER</code>는 <code>CURLOPT_SSL_VERIFYPEER</code> 등의 프록시 버전입니다.</p><p>HTTPS 프록시는 오늘날에도 여전히 조직과 회사에서 상당히 이례적입니다.</p><h2 id="프록시-인증"><a href="#프록시-인증" class="headerlink" title="프록시 인증"></a>프록시 인증</h2><p>프록시를 사용한 인증은 프록시 자체와의 핸드셰이크 협상에서 유효한 자격 증명을 제공해야 함을 의미합니다. 프록시 인증은 원격 호스트와의 가능한 인증 또는 인증 부족에 추가 및 분리됩니다.</p><p>libcurl은 HTTP, HTTPS 및 SOCKS5 프록시를 통한 인증을 지원합니다. 핵심 옵션은 <code>CURLOPT_PROXY</code> 문자열 내에서 설정하지 않는 한 사용할 사용자 이름과 암호를 설정하는 <code>CURLOPT_PROXYUSERPWD</code>입니다.</p><h2 id="HTTP-프록시-헤더"><a href="#HTTP-프록시-헤더" class="headerlink" title="HTTP 프록시 헤더"></a>HTTP 프록시 헤더</h2><p>HTTP 또는 HTTP 프록시를 사용하여 libcurl은 헤더 세트를 포함하는 프록시에 요청을 발행합니다. 물론 애플리케이션은 서버로 보낸 요청과 마찬가지로 헤더를 수정할 수 있습니다.</p><p>libcurl은 <strong>서버에 별도의 요청이 전송될 때</strong> 프록시로 전송되는 헤더를 제어하기 위해 <code>CURLOPT_PROXYHEADER</code>를 제공합니다. 이는 일반적으로 프록시를 통해 터널을 설정하기 위해 프록시로 전송된 초기 CONNECT 요청을 의미합니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Proxies/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl Header files</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Header%20files/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Header%20files/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;Header-files&quot;&gt;&lt;a href=&quot;#Header-files&quot; class=&quot;headerlink&quot; title=&quot;Header files&quot;&gt;&lt;/a&gt;Header files&lt;/h1&gt;&lt;p&gt;응용 프로그램을 사용하는 libcurl이 포함해야 하는
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="Header-files"><a href="#Header-files" class="headerlink" title="Header files"></a>Header files</h1><p>응용 프로그램을 사용하는 libcurl이 포함해야 하는 헤더는 단 하나뿐입니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br></pre></td></tr></table></figure><p>그 파일에는 몇 가지 다른 공개 헤더 파일이 포함되어 있지만 존재하지 않는 척 할 수 있습니다. (역사적으로 말해서, 우리는 약간 다르게 시작했지만 시간이 지남에 따라 포함에 대해 하나만 사용하는 이 형식을 중심으로 안정화되었습니다.)</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20Header%20files/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl 자세한 작업</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%9E%90%EC%84%B8%ED%95%9C%20%EC%9E%91%EC%97%85/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%9E%90%EC%84%B8%ED%95%9C%20%EC%9E%91%EC%97%85/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;자세한-작업&quot;&gt;&lt;a href=&quot;#자세한-작업&quot; class=&quot;headerlink&quot; title=&quot;자세한 작업&quot;&gt;&lt;/a&gt;자세한 작업&lt;/h1&gt;&lt;p&gt;좋습니다, 우리는 특정 전송에서 무엇이 잘못되었는지 파악하고 종종 왜 그렇게 할 수 있는지 또는 
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="자세한-작업"><a href="#자세한-작업" class="headerlink" title="자세한 작업"></a>자세한 작업</h1><p>좋습니다, 우리는 특정 전송에서 무엇이 잘못되었는지 파악하고 종종 왜 그렇게 할 수 있는지 또는 현재 문제가 무엇인지 설명하기 때문에 사람이 읽을 수 있는 텍스트로 오류를 얻는 방법을 보여주었습니다.</p><p>최소한 libcurl 애플리케이션을 개발하거나 libcurl 자체를 디버깅하는 동안 모두가 알아야 하고 광범위하게 사용해야 하는 libcurl 애플리케이션을 작성할 때 다음 생명의 은인은 <code>CURLOPT_VERBOSE</code>를 사용하여 “상세 모드”를 활성화하는 것입니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURLcode ret = curl_easy_setopt(handle, CURLOPT_VERBOSE, <span class="number">1L</span>);</span><br></pre></td></tr></table></figure><p>libcurl이 verbose라고 하면 전송이 진행되는 동안 전송 관련 세부 정보 및 정보를 stderr에 언급합니다. 이것은 일이 실패하는 이유를 알아내고 libcurl이 다른 것을 요청할 때 정확히 무엇을 하는지 알아내는 것은 굉장합니다. <code>CURLOPT_STDERR</code>을 사용하여 stderr을 변경하여 출력을 다른 곳으로 리디렉션하거나 디버그 콜백을 사용하여 더 멋진 방식으로 더 많은 정보를 얻을 수 있습니다(나중 섹션에서 자세히 설명).</p><h2 id="모든-것을-추적"><a href="#모든-것을-추적" class="headerlink" title="모든 것을 추적"></a>모든 것을 추적</h2><p>Verbose는 확실히 괜찮지만 때로는 더 필요합니다. libcurl은 또한 자세한 정보 표시 모드가 수행하는 모든 작업을 표시하는 것 외에도 전송 및 수신된 모든 데이터를 전달하여 애플리케이션이 모든 것을 완벽하게 추적할 수 있도록 추적 콜백을 제공합니다.</p><p>추적 콜백으로 전달되고 수신된 데이터는 암호화되지 않은 형식으로 콜백에 제공되며, 이는 디버깅을 위해 네트워크에서 데이터를 캡처하는 것이 실용적이지 않을 때 TLS 또는 SSH 기반 프로토콜로 작업할 때 편리할 수 있습니다.</p><p><code>CURLOPT_DEBUGFUNCTION</code> 옵션을 설정할 때 여전히 <code>CURLOPT_VERBOSE</code>를 활성화해야 하지만 추적 콜백을 설정하면 libcurl은 내부 처리 대신 해당 콜백을 사용합니다.</p><p>추적 콜백은 다음과 같은 프로토타입과 일치해야 합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">my_trace</span><span class="params">(CURL *handle, curl_infotype type, <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> <span class="built_in">size</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">void</span> *userp)</span></span>;</span><br></pre></td></tr></table></figure><p>핸들은 관련된 쉬운 핸들이고, 유형은 콜백에 전달된 특정 데이터(데이터 입/출력, 헤더 입/출력, TLS 데이터 입/출력 및 “텍스트”)를 설명하고, ptr은 크기가 바이트 수인 데이터를 가리킵니다. userp는 <code>CURLOPT_DEBUGDATA</code>로 설정한 사용자 지정 포인터입니다.</p><p>ptr이 가리키는 데이터는 0으로 종료되지 않지만 size 인수에 의해 지시된 크기와 정확히 일치합니다.</p><p>콜백은 0을 반환해야 하며 그렇지 않으면 libcurl은 이를 오류로 간주하고 전송을 중단합니다.</p><p>curl 웹사이트에서 영감을 얻을 수 있는 간단한 추적 기능이 포함된 <a href="https://curl.se/libcurl/c/debug.html" rel="external nofollow noopener noreferrer" target="_blank">debug.c</a>라는 예제를 호스팅합니다.</p><p><a href="https://curl.se/libcurl/c/CURLOPT_DEBUGFUNCTION.html" rel="external nofollow noopener noreferrer" target="_blank">CURLOPT_DEBUGFUNCTION 매뉴얼 페이지</a>에도 추가 세부 정보가 있습니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%9E%90%EC%84%B8%ED%95%9C%20%EC%9E%91%EC%97%85/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl curl easy options</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20curl%20easy%20options/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20curl%20easy%20options/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;curl-easy-options&quot;&gt;&lt;a href=&quot;#curl-easy-options&quot; class=&quot;headerlink&quot; title=&quot;curl easy options&quot;&gt;&lt;/a&gt;curl easy options&lt;/h1&gt;&lt;p&gt;이지 핸들에서 옵션
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="curl-easy-options"><a href="#curl-easy-options" class="headerlink" title="curl easy options"></a>curl easy options</h1><p>이지 핸들에서 옵션을 설정하여 전송 방식을 제어하거나 경우에 따라 실제로 옵션을 설정하고 전송이 진행되는 동안 전송 동작을 수정할 수 있습니다. <code>curl_easy_setopt()</code>로 옵션을 설정하고 핸들, 설정하려는 옵션 및 옵션에 대한 인수를 제공합니다. 모든 옵션은 정확히 하나의 인수를 취하며 항상 <code>curl_easy_setopt()</code> 호출에 정확히 세 개의 매개변수를 전달해야 합니다.</p><p><code>curl_easy_setopt()</code> 호출은 수백 가지 다른 옵션을 허용하고 다양한 옵션은 다양한 유형의 인수를 허용하므로 세부 사항을 읽고 특정 옵션이 지원하고 기대하는 인수 유형을 정확히 제공하는 것이 중요합니다. 잘못된 유형을 전달하면 예기치 않은 부작용이 발생하거나 딸꾹질을 이해하기 어려울 수 있습니다.</p><p>모든 전송에 필요한 가장 중요한 옵션은 URL입니다. libcurl은 관련된 URL을 알지 못하면 전송을 수행할 수 없으므로 알려야 합니다. URL 옵션 이름은 <code>CURLOPT_URL</code>입니다. 모든 옵션에는 <code>CURLOPT_</code> 접두어가 붙은 다음 설명이 포함된 이름이 모두 대문자를 사용하기 때문입니다. <code>http://example.com</code> HTTP 콘텐츠를 가져오기 위해 URL을 설정하는 예제 줄은 다음과 같습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURLcode ret = curl_easy_setopt(easy, CURLOPT_URL, <span class="string">"http://example.com"</span>);</span><br></pre></td></tr></table></figure><p>다시: 이것은 핸들의 옵션만 설정합니다. 실제 전송 또는 기타 작업을 수행하지 않습니다. libcurl에게 문자열을 복사하도록 지시하고 작동하면 OK를 반환합니다.</p><p>물론 반환 코드를 확인하여 아무 문제가 없는지 확인하는 것이 좋습니다.</p><h2 id="숫자-옵션-설정"><a href="#숫자-옵션-설정" class="headerlink" title="숫자 옵션 설정"></a>숫자 옵션 설정</h2><p><code>curl_easy_setopt()</code>는 3번째 인자가 상황에 따라 다른 타입을 사용할 수 있는 vararg 함수이기 때문에 일반적인 C언어 타입 변환은 불가능하다. 따라서 문서에서 그렇게 말하는 경우 ‘int’가 아닌 ‘long’을 실제로 전달했는지 확인해야 합니다. 크기가 같은 아키텍처에서는 문제가 발생하지 않을 수 있지만 모두가 그렇게 작동하지는 않습니다. 마찬가지로 ‘curl_off_t’ 유형을 허용하는 옵션의 경우 해당 유형을 사용하고 다른 유형을 사용하지 않는 인수를 전달하는 것이 중요합니다.</p><p>긴 실행:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(handle, CURLOPT_TIMEOUT, <span class="number">5L</span>); <span class="comment">/* 5 seconds timeout */</span></span><br></pre></td></tr></table></figure><p>curl_off_t 시행:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">curl_off_t</span> no_larger_than = <span class="number">0x50000</span>;</span><br><span class="line">curl_easy_setopt(handle, CURLOPT_MAXFILESIZE_LARGE, no_larger_than);</span><br></pre></td></tr></table></figure><h2 id="핸들-옵션-가져오기"><a href="#핸들-옵션-가져오기" class="headerlink" title="핸들 옵션 가져오기"></a>핸들 옵션 가져오기</h2><p>이전에 <code>curl_easy_setopt()</code>로 설정한 것과 동일한 정보를 추출하는 일반적인 방법은 없습니다! 이전에 설정한 정보를 다시 추출해야 하는 경우 애플리케이션에서 해당 데이터를 직접 추적하는 것이 좋습니다.</p><h2 id="TLS-옵션"><a href="#TLS-옵션" class="headerlink" title="TLS 옵션"></a>TLS 옵션</h2><p>이 글을 쓰는 시점에서 libcurl이 SSL과 TLS를 수행하는 방식을 제어하기 위한 전용 curl_easy_setopt에 대해 40가지 이상의 다른 옵션이 있습니다.</p><p>TLS를 사용하여 수행된 전송은 안전한 기본값을 사용하지만 curl은 다양한 시나리오 및 설정에서 사용되기 때문에 이러한 동작을 변경하려는 상황이 발생할 가능성이 있습니다.</p><h3 id="프로토콜-버전"><a href="#프로토콜-버전" class="headerlink" title="프로토콜 버전"></a>프로토콜 버전</h3><p><code>CURLOPT_SSLVERSION</code> 및 <code>CURLOPT_PROXY_SSLVERSION</code>을 사용하여 허용되는 SSL 또는 TLS 프로토콜 범위를 지정할 수 있습니다. 전통적으로 SSL 및 TLS 프로토콜 버전은 시간이 지남에 따라 감지되고 사용하기에 부적합한 것으로 밝혀졌으며 curl 자체가 시간이 지남에 따라 기본 낮은 버전을 올리더라도 가장 최신의 보안 프로토콜 버전만 사용하도록 선택할 수 있습니다.</p><p>이러한 옵션은 허용 가능한 가장 낮은 버전과 선택적으로 최대값을 사용합니다. 서버가 해당 조건으로 연결을 협상할 수 없으면 전송이 실패합니다.</p><p>예시:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(easy, CURLOPT_SSLVERSION, CURL_SSLVERSION_TLSv1_2);</span><br></pre></td></tr></table></figure><h3 id="프로토콜-세부정보-및-동작"><a href="#프로토콜-세부정보-및-동작" class="headerlink" title="프로토콜 세부정보 및 동작"></a>프로토콜 세부정보 및 동작</h3><p><code>CURLOPT_SSL_CIPHER_LIST</code> 및 <code>CURLOPT_PROXY_SSL_CIPHER_LIST</code>를 설정하여 사용할 암호를 선택할 수 있습니다.</p><p><code>CURLOPT_SSL_FALSESTART</code>를 사용하여 SSL “False Start”를 활성화하도록 요청할 수 있으며 <code>CURLOPT_SSL_OPTIONS</code>를 사용하여 조정할 몇 가지 다른 동작 변경 사항이 있습니다.</p><h3 id="확인-Verification"><a href="#확인-Verification" class="headerlink" title="확인(Verification)"></a>확인(Verification)</h3><p>TLS를 사용하는 클라이언트는 자신이 말하는 서버가 정확하고 신뢰할 수 있는 서버인지 확인해야 합니다. 이것은 서버의 인증서가 curl에 대한 공개 키가 있는 인증 기관(CA)에 의해 서명되었고 인증서에 서버의 이름이 포함되어 있는지 확인하여 수행됩니다. 이러한 검사 중 하나라도 실패하면 전송이 실패합니다.</p><p>개발 목적과 실험을 위해 curl을 사용하면 애플리케이션이 서버 또는 HTTPS 프록시에 대한 이러한 검사 중 하나 또는 둘 다를 끌 수 있습니다.</p><ul><li><code>CURLOPT_SSL_VERIFYPEER</code>는 인증서가 신뢰할 수 있는 CA에 의해 서명되었는지 확인하는 것을 제어합니다.</li><li><code>CURLOPT_SSL_VERIFYHOST</code>는 인증서 내의 이름 확인을 제어합니다.</li><li><code>CURLOPT_PROXY_SSL_VERIFYPEER</code>는 <code>CURLOPT_SSL_VERIFYPEER</code>의 프록시 버전입니다.</li><li><code>CURLOPT_PROXY_SSL_VERIFYHOST</code>는 <code>CURLOPT_SSL_VERIFYHOST</code>의 프록시 버전입니다.</li></ul><p>선택적으로 <code>CURLOPT_PINNEDPUBLICKEY</code> 또는 <code>CURLOPT_PROXY_PINNEDPUBLICKEY</code>를 사용하여 알려진 해시에 대해 인증서의 공개 키를 확인하도록 curl에 지시할 수 있습니다. 여기에서도 불일치로 인해 전송이 실패합니다.</p><h3 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h3><h4 id="TLS-클라이언트-인증서"><a href="#TLS-클라이언트-인증서" class="headerlink" title="TLS 클라이언트 인증서"></a>TLS 클라이언트 인증서</h4><p>TLS를 사용하고 서버가 클라이언트에게 인증서를 사용하여 인증하도록 요청할 때 일반적으로 <code>CURLOPT_SSLKEY</code> 및 <code>CURLOPT_SSLCERT</code>를 사용하여 개인 키와 해당 클라이언트 인증서를 지정합니다. 일반적으로 <code>CURLOPT_SSLKEYPASSWD</code>를 사용하여 키의 비밀번호도 설정해야 합니다.</p><p>다시 말하지만, <code>CURLOPT_PROXY_SSLKEY</code>, <code>CURLOPT_PROXY_SSLCERT</code> 등 HTTPS 프록시에 대한 연결에 대해 동일한 옵션 세트가 별도로 존재합니다.</p><h4 id="TLS-인증"><a href="#TLS-인증" class="headerlink" title="TLS 인증"></a>TLS 인증</h4><p>TLS 연결은 보안 원격 암호라는 (거의 사용되지 않는) 기능을 제공합니다. 이것을 사용하여 이름과 암호를 사용하여 서버에 대한 연결을 인증하고 옵션은 <code>CURLOPT_TLSAUTH_USERNAME</code> 및 <code>CURLOPT_TLSAUTH_PASSWORD</code>입니다.</p><h3 id="STARTTLS"><a href="#STARTTLS" class="headerlink" title="STARTTLS"></a>STARTTLS</h3><p>STARTTLS 방법을 사용하여 TLS(FTP, IMAP, POP3 및 SMTP)로의 연결을 업그레이드하는 프로토콜의 경우 일반적으로 URL을 지정할 때 curl에 비TLS 버전의 프로토콜을 사용하도록 지시한 다음 curl에게 TLS를 활성화하도록 <code>CURLOPT_USE_SSL</code> 옵션으로 요청합니다.</p><p>이 옵션을 사용하면 클라이언트가 TLS로 업그레이드할 수 없는 경우 curl을 계속할 수 있지만 제대로 인식하지 못한 채 안전하지 않은 프로토콜을 사용할 수 있으므로 권장하지 않는 경로입니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* require use of SSL for this, or fail */</span></span><br><span class="line">curl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_ALL);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20curl%20easy%20options/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl API 호환성</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20API%20%ED%98%B8%ED%99%98%EC%84%B1/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20API%20%ED%98%B8%ED%99%98%EC%84%B1/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;API-호환성&quot;&gt;&lt;a href=&quot;#API-호환성&quot; class=&quot;headerlink&quot; title=&quot;API 호환성&quot;&gt;&lt;/a&gt;API 호환성&lt;/h1&gt;&lt;p&gt;libcurl은 API 안정성을 약속하고 오늘 작성된 프로그램이 앞으로도 계속 작동할 것임
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="API-호환성"><a href="#API-호환성" class="headerlink" title="API 호환성"></a>API 호환성</h1><p>libcurl은 API 안정성을 약속하고 오늘 작성된 프로그램이 앞으로도 계속 작동할 것임을 보장합니다. 우리는 호환성을 깨뜨리지 않습니다.</p><p>시간이 지남에 따라 기능, 새 옵션 및 새 기능을 API에 추가하지만 호환되지 않는 방식으로 동작을 변경하거나 기능을 제거하지 않습니다.</p><p>API를 호환되지 않는 방식으로 마지막으로 변경한 것은 2006년 7.16.0용이었고 다시는 변경하지 않을 계획입니다.</p><h2 id="버전-번호"><a href="#버전-번호" class="headerlink" title="버전 번호"></a>버전 번호</h2><p>Curl과 libcurl은 개별적으로 버전이 지정되지만 대부분 서로 밀접하게 따릅니다.<br>버전 번호는 항상 동일한 시스템을 사용하여 구성됩니다.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X.Y.Z</span><br></pre></td></tr></table></figure><ul><li>X는 기본 버전 번호입니다.</li><li>Y는 릴리스 번호입니다.</li><li>Z는 패치 번호입니다.</li></ul><h2 id="범람하는-숫자"><a href="#범람하는-숫자" class="headerlink" title="범람하는 숫자"></a>범람하는 숫자</h2><p>이 X.Y.Z 숫자 중 하나는 모든 새 릴리스에서 충돌합니다. 범프된 숫자의 오른쪽에 있는 숫자는 0으로 재설정됩니다.</p><p>기본 버전 번호 X는 실제로 크고 충돌하는 변경 사항이 있을 때 충돌합니다. 릴리스 번호 Y는 변경이 수행되거나 사물/기능이 추가될 때 범프됩니다. 변경 사항이 단순한 버그 수정일 때 패치 번호 Z가 충돌합니다.</p><p>이는 릴리스 1.2.3 이후에 정말 큰 변화가 있으면 2.0.0을 릴리스할 수 있고, 그렇지 않은 경우 1.3.0을 릴리스하거나 대부분의 버그가 수정된 경우 1.2.4를 릴리스할 수 있음을 의미합니다.</p><p>숫자를 1로 늘릴 때와 같이 범핑은 무조건 숫자 중 하나에만 영향을 미칩니다(오른쪽에 있는 숫자는 0으로 설정됨). 1은 2가 되고 3은 4가 되고 9는 10이 되고 88은 89가 되고 99는 100이 됩니다. 따라서 1.2.9 이후에는 1.2.10이 됩니다. 3.99.3 이후에는 3.100.0이 나올 수 있습니다.</p><p>모든 원본 컬 소스 릴리스 아카이브는 libcurl 버전에 따라 이름이 지정됩니다(앞서 말했듯이 다를 수 있는 컬 클라이언트 버전이 아님).</p><h2 id="어떤-libcurl-버전"><a href="#어떤-libcurl-버전" class="headerlink" title="어떤 libcurl 버전"></a>어떤 libcurl 버전</h2><p>새로운 libcurl 기능을 지원하는 동시에 이전 버전으로 빌드할 수 있는 모든 애플리케이션에 대한 서비스로 모든 릴리스에는 비교에 사용할 수 있는 정적 번호 매기기 체계를 사용하여 <code>curl/curlver.h</code> 파일에 libcurl 버전이 저장되어 있습니다. . 버전 번호는 다음과 같이 정의됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBCURL_VERSION_NUM 0xXXYYZZ</span></span><br></pre></td></tr></table></figure><p>여기서 XX, YY 및 ZZ는 16진수의 기본 버전, 릴리스 및 패치 번호입니다. 세 개의 숫자 필드 모두는 항상 두 자리(각각 8비트)를 사용하여 표현됩니다. 1.2.0은 “0x010200”으로 표시되고 버전 9.11.7은 “0x090b07”로 표시됩니다.</p><p>이 6자리 16진수 숫자는 최신 릴리스에서 항상 더 큰 숫자입니다. 일보다 크거나 작음과 비교합니다.</p><p>이 번호는 <code>LIBCURL_VERSION_MAJOR</code>, <code>LIBCURL_VERSION_MINOR</code> 및 <code>LIBCURL_VERSION_PATCH</code>의 세 가지 개별 정의로도 사용할 수 있습니다.<br>물론 이러한 정의는 지금 빌드된 버전 번호를 파악하는 데에만 적합하며 지금부터 3년 후 런타임에 사용되는 libcurl 버전을 파악하는 데 도움이 되지 않습니다.</p><h2 id="실행되는-libcurl-버전"><a href="#실행되는-libcurl-버전" class="headerlink" title="실행되는 libcurl 버전"></a>실행되는 libcurl 버전</h2><p>애플리케이션이 현재 사용하고 있는 libcurl 버전을 파악하기 위해 <code>curl_version_info()</code>가 있습니다.</p><p>동적/DLL 라이브러리는 응용 프로그램과 독립적으로 변경할 수 있으므로 응용 프로그램은 컴파일 시간 검사를 사용하는 대신 이 기능을 사용하여 작업이 가능한지 여부를 판단해야 합니다.</p><p><code>curl_version_info()</code>는 버전 번호 및 다양한 기능과 실행 중인 libcurl 버전에 대한 정보가 포함된 구조체에 대한 포인터를 반환합니다. 당신은 libcurl이 그것을 호출하는 libcurl의 “나이”를 알 수 있도록 특별한 나이 카운터를 주어 그것을 호출합니다. 나이는 CURLVERSION_NOW라고 하는 정의이며 컬 발달 전반에 걸쳐 불규칙한 간격으로 증가하는 카운터입니다. 연령 번호는 libcurl이 반환할 수 있는 구조체 집합을 알려줍니다.</p><p>다음과 같이 함수를 호출합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_version_info_data *ver = curl_version_info( CURLVERSION_NOW );</span><br></pre></td></tr></table></figure><p>그러면 데이터는 다음 레이아웃을 갖거나 가질 수 있는 구조체를 가리킬 것입니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  CURLversion age;          <span class="comment">/* see description below */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 0 or higher, the members below also exist: */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *version;      <span class="comment">/* human readable string */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> version_num; <span class="comment">/* numeric representation */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *host;         <span class="comment">/* human readable string */</span></span><br><span class="line">  <span class="keyword">int</span> features;             <span class="comment">/* bitmask, see below */</span></span><br><span class="line">  <span class="keyword">char</span> *ssl_version;        <span class="comment">/* human readable string */</span></span><br><span class="line">  <span class="keyword">long</span> ssl_version_num;     <span class="comment">/* not used, always zero */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *libz_version; <span class="comment">/* human readable string */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> * <span class="keyword">const</span> *protocols; <span class="comment">/* protocols */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 1 or higher, the members below also exist: */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *ares;         <span class="comment">/* human readable string */</span></span><br><span class="line">  <span class="keyword">int</span> ares_num;             <span class="comment">/* number */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 2 or higher, the member below also exists: */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *libidn;       <span class="comment">/* human readable string */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 3 or higher (7.16.1 or later), the members below also</span></span><br><span class="line"><span class="comment">     exist  */</span></span><br><span class="line">  <span class="keyword">int</span> iconv_ver_num;       <span class="comment">/* '_libiconv_version' if iconv support enabled */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *libssh_version; <span class="comment">/* human readable string */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 4 or higher, the member below also exists: */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> brotli_ver_num; <span class="comment">/* Numeric Brotli version</span></span><br><span class="line"><span class="comment">                                  (MAJOR &lt;&lt; 24) | (MINOR &lt;&lt; 12) | PATCH */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *brotli_version; <span class="comment">/* human readable string. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 5 or higher, the member below also exists: */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> nghttp2_ver_num; <span class="comment">/* Numeric nghttp2 version</span></span><br><span class="line"><span class="comment">                                   (MAJOR &lt;&lt; 16) | (MINOR &lt;&lt; 8) | PATCH */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *nghttp2_version; <span class="comment">/* human readable string. */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *quic_version;    <span class="comment">/* human readable quic (+ HTTP/3) library +</span></span><br><span class="line"><span class="comment">                                  version or NULL */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 6 or higher, the member below also exists: */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *cainfo;          <span class="comment">/* the built-in default CURLOPT_CAINFO, might</span></span><br><span class="line"><span class="comment">                                  be NULL */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *capath;          <span class="comment">/* the built-in default CURLOPT_CAPATH, might</span></span><br><span class="line"><span class="comment">                                  be NULL */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 7 or higher, the member below also exists: */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> zstd_ver_num; <span class="comment">/* Numeric Zstd version</span></span><br><span class="line"><span class="comment">                                  (MAJOR &lt;&lt; 24) | (MINOR &lt;&lt; 12) | PATCH */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *zstd_version; <span class="comment">/* human readable string. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* when 'age' is 8 or higher, the member below also exists: */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *hyper_version; <span class="comment">/* human readable string. */</span></span><br><span class="line"></span><br><span class="line">&#125; curl_version_info_data;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20API%20%ED%98%B8%ED%99%98%EC%84%B1/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl 전역 초기화</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%A0%84%EC%97%AD%20%EC%B4%88%EA%B8%B0%ED%99%94/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%A0%84%EC%97%AD%20%EC%B4%88%EA%B8%B0%ED%99%94/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;전역-초기화&quot;&gt;&lt;a href=&quot;#전역-초기화&quot; class=&quot;headerlink&quot; title=&quot;전역 초기화&quot;&gt;&lt;/a&gt;전역 초기화&lt;/h1&gt;&lt;p&gt;프로그램에서 libcurl과 관련된 작업을 수행하기 전에 &lt;code&gt;curl_global_init
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="전역-초기화"><a href="#전역-초기화" class="headerlink" title="전역 초기화"></a>전역 초기화</h1><p>프로그램에서 libcurl과 관련된 작업을 수행하기 전에 <code>curl_global_init()</code>으로 전역 libcurl 초기화 호출을 수행해야 합니다. 이는 libcurl이 사용할 수 있는 일부 기본 라이브러리가 설정을 가져오고 적절하게 초기화하기 위해 미리 호출해야 하기 때문에 필요합니다.</p><p><code>curl_global_init()</code>은 불행히도 스레드로부터 안전하지 않으므로 한 번만 수행하고 다른 호출과 동시에 수행하지 않도록 해야 합니다. 전역 상태를 초기화하므로 한 번만 호출해야 하며 프로그램이 libcurl을 사용하여 완전히 완료되면 <code>curl_global_cleanup()</code>을 호출하여 할당된 초기화 호출과 관련된 전역 리소스를 해제하고 정리할 수 있습니다.</p><p>libcurl은 <code>curl_global_init()</code> 호출을 건너뛰는 상황을 처리하도록 빌드되었지만 대신 자체적으로 호출하여 수행하고(실제 파일 전송이 시작되기 전에 수행하지 않은 경우) 자체 기본값을 사용합니다. 그러나 그때도 여전히 스레드로부터 안전하지 않으므로 “흥미로운” 부작용이 발생할 수 있습니다. <code>curl_global_init()</code>를 제어된 방식으로 직접 호출하는 것이 훨씬 좋습니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%A0%84%EC%97%AD%20%EC%B4%88%EA%B8%B0%ED%99%94/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl for C++ programmers</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20for%20C++%20programmers/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20for%20C++%20programmers/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;for-C-programmers&quot;&gt;&lt;a href=&quot;#for-C-programmers&quot; class=&quot;headerlink&quot; title=&quot;for C++ programmers&quot;&gt;&lt;/a&gt;for C++ programmers&lt;/h1&gt;&lt;p&gt;libcur
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="for-C-programmers"><a href="#for-C-programmers" class="headerlink" title="for C++ programmers"></a>for C++ programmers</h1><p>libcurl은 C API를 제공합니다. C와 C++는 비슷하지만 같지는 않습니다. C++에서 libcurl을 사용할 때 염두에 두어야 할 몇 가지 사항이 있습니다.</p><h2 id="문자열은-C-문자열-객체가-아니라-C-문자열입니다"><a href="#문자열은-C-문자열-객체가-아니라-C-문자열입니다" class="headerlink" title="문자열은 C++ 문자열 객체가 아니라 C 문자열입니다."></a>문자열은 C++ 문자열 객체가 아니라 C 문자열입니다.</h2><p><code>char *</code>를 허용하는 libcurl의 API에 문자열을 전달할 때 C++ 문자열이나 객체를 해당 함수에 전달할 수 없음을 의미합니다.</p><p>예를 들어, C++로 문자열을 작성한 다음 해당 문자열을 URL로 사용하려는 경우:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> url = <span class="string">"https://example.com/foo.asp?name="</span> + i;</span><br><span class="line">curl_easy_setopt(curl, CURLOPT_URL, url.c_str());</span><br></pre></td></tr></table></figure><h2 id="콜백-고려-사항"><a href="#콜백-고려-사항" class="headerlink" title="콜백 고려 사항"></a>콜백 고려 사항</h2><p>libcurl은 C 라이브러리이기 때문에 C++ 멤버 함수나 객체에 대해 아무것도 모릅니다. 클래스에 대한 포인터가 전달되는 정적 멤버 함수를 사용하면 이 “제한”을 비교적 쉽게 극복할 수 있습니다.</p><p>다음은 C++ 메서드를 콜백으로 사용하는 쓰기 콜백의 예입니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// f is the pointer to your object.</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">YourClass::func</span><span class="params">(<span class="keyword">void</span> *<span class="built_in">buffer</span>, <span class="keyword">size_t</span> sz, <span class="keyword">size_t</span> n, <span class="keyword">void</span> *f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Call non-static member function.</span></span><br><span class="line">  <span class="keyword">static_cast</span>&lt;YourClass*&gt;(f)-&gt;nonStaticFunction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is how you pass pointer to the static function:</span></span><br><span class="line">curl_easy_setopt(hcurl, CURLOPT_WRITEFUNCTION, YourClass::func);</span><br><span class="line">curl_easy_setopt(hcurl, CURLOPT_WRITEDATA, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20for%20C++%20programmers/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl 이름 확인</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%9D%B4%EB%A6%84%20%ED%99%95%EC%9D%B8/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%9D%B4%EB%A6%84%20%ED%99%95%EC%9D%B8/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;이름-확인&quot;&gt;&lt;a href=&quot;#이름-확인&quot; class=&quot;headerlink&quot; title=&quot;이름 확인&quot;&gt;&lt;/a&gt;이름 확인&lt;/h1&gt;&lt;p&gt;libcurl이 수행할 수 있는 대부분의 전송에는 먼저 인터넷 주소로 변환되어야 하는 이름이 포함됩니다.
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="이름-확인"><a href="#이름-확인" class="headerlink" title="이름 확인"></a>이름 확인</h1><p>libcurl이 수행할 수 있는 대부분의 전송에는 먼저 인터넷 주소로 변환되어야 하는 이름이 포함됩니다. 그것은 “이름 확인”입니다. URL에서 직접 숫자 IP 주소를 사용하면 일반적으로 이름 확인 단계를 피할 수 있지만 대부분의 경우 이름을 IP 주소로 수동으로 바꾸는 것이 쉽지 않습니다.</p><p>libcurl은 새로운 연결을 생성하기 보다는 <a href="https://jung-max.github.io/2022/02/09/Linux-libcurl%20연결%20재사용">기존 연결을 재사용</a>하기 위해 열심히 노력합니다. 사용할 기존 연결을 확인하는 기능은 순전히 이름을 기반으로 하며 이름 확인이 시도되기 전에 수행됩니다. 이것이 재사용이 훨씬 더 빠른 이유 중 하나입니다. 재사용된 연결을 사용하는 전송은 호스트 이름을 다시 확인하지 않습니다.</p><p>연결을 재사용할 수 없는 경우 libcurl은 확인하려는 주소 집합으로 호스트 이름을 확인합니다. 일반적으로 이것은 IPv4 및 IPv6 주소를 모두 요청한다는 것을 의미하며 libcurl에 반환된 전체 집합이 있을 수 있습니다. 그런 다음 해당 주소 집합이 작동하거나 실패를 반환할 때까지 시도됩니다.</p><p>응용 프로그램은 CURLOPT_IPRESOLVE를 기본 값으로 설정하여 libcurl이 IPv4 또는 IPv6 확인 주소만 사용하도록 할 수 있습니다. 예를 들어 IPv6 주소만 사용하도록 요청합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(easy, CURLOPT_IPRESOLVE, CURL_IPRESOLVE_V6);</span><br></pre></td></tr></table></figure><h2 id="이름-확인자-백엔드"><a href="#이름-확인자-백엔드" class="headerlink" title="이름 확인자 백엔드"></a>이름 확인자 백엔드</h2><p>libcurl은 이 세 가지 다른 방법 중 하나로 이름 확인을 수행하도록 빌드할 수 있으며 사용되는 백엔드 방법에 따라 약간 다른 기능 세트와 때때로 수정된 동작을 얻습니다.</p><ol><li>기본 백엔드는 새로운 도우미 스레드에서 “일반” libc 해석기 기능을 호출하므로 원하는 경우 여전히 세분화된 시간 초과를 수행할 수 있고 차단 호출이 포함되지 않습니다.</li><li>이전 시스템에서 libcurl은 표준 동기 이름 해석기 기능을 사용합니다. 불행히도 작동하는 동안 다중 핸들 블록 내에서 모든 전송을 수행하며 멋지게 시간 초과되는 것이 훨씬 더 어렵습니다.</li><li>스레드를 사용하지 않고 비동기식 이름 확인을 지원하는 c-ares 타사 라이브러리로 확인하기 위한 지원도 있습니다. 이것은 엄청난 수의 병렬 전송으로 더 잘 확장되지만 기본 이름 확인기 기능과 항상 100% 호환되는 것은 아닙니다.</li></ol><h2 id="HTTPS를-통한-DNS"><a href="#HTTPS를-통한-DNS" class="headerlink" title="HTTPS를 통한 DNS"></a>HTTPS를 통한 DNS</h2><p>libcurl이 사용하도록 빌드된 확인자 백엔드와는 별개로, 7.62.0부터는 사용자가 특정 DoH(DNS over HTTPS) 서버에 이름 주소를 요청할 수 있는 방법도 제공합니다. 이렇게 하면 일반적인 기본 리졸버 메서드와 서버를 사용하지 않고 전용 별도의 메서드와 서버를 요청합니다.</p><p>DoH 서버는 다음과 같이 <code>CURLOPT_DOH_URL</code> 옵션을 사용하여 전체 URL로 지정됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(easy, CURLOPT_DOH_URL, <span class="string">"https://example.com/doh"</span>);</span><br></pre></td></tr></table></figure><p>이 옵션에 전달되는 URL은 <code>https://</code>를 사용해야 하며 일반적으로 libcurl이 DoH 서버에 대한 연결을 통해 다중 DoH 요청을 수행할 수 있도록 HTTP/2 지원을 활성화하는 것이 좋습니다.</p><h2 id="캐싱"><a href="#캐싱" class="headerlink" title="캐싱"></a>캐싱</h2><p>이름이 확인되면 결과는 libcurl의 메모리 내 캐시에 저장되어 이름이 DNS 캐시에 유지되는 한 동일한 이름에 대한 후속 확인이 거의 즉시 이루어집니다. 기본적으로 각 항목은 캐시에 60초 동안 유지되지만 해당 값은 <code>CURLOPT_DNS_CACHE_TIMEOUT</code>으로 변경할 수 있습니다.</p><p>DNS 캐시는 <code>curl_easy_perform</code>을 사용하는 경우 easy 핸들 내에, 멀티 인터페이스를 사용하는 경우 멀티 핸들 내에 유지됩니다. 또한 <a href="https://jung-max.github.io/2022/02/09/Linux-libcurl%20핸들%20간에%20데이터%20공유">공유 인터페이스</a>를 사용하여 여러 개의 쉬운 핸들 간에 공유할 수 있습니다.</p><h2 id="호스트에-대한-사용자-지정-주소"><a href="#호스트에-대한-사용자-지정-주소" class="headerlink" title="호스트에 대한 사용자 지정 주소"></a>호스트에 대한 사용자 지정 주소</h2><p>때로는 실제 호스트 이름에 “가짜” 주소를 제공하여 libcurl이 실제 이름 확인이 제안하는 주소 대신 다른 주소에 연결하도록 하는 것이 편리합니다.</p><p><a href="https://curl.se/libcurl/c/CURLOPT_RESOLVE.html" rel="external nofollow noopener noreferrer" target="_blank">CURLOPT_RESOLVE</a> 옵션의 도움으로 응용 프로그램은 libcurl의 DNS 캐시를 지정된 호스트 이름 및 포트 번호에 대한 사용자 지정 주소로 미리 채울 수 있습니다.</p><p>포트 443의 example.com이 요청될 때 libcurl이 127.0.0.1에 연결되도록 하려면 애플리케이션에서 다음을 수행할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">curl_slist</span> *<span class="title">dns</span>;</span></span><br><span class="line">dns = curl_slist_append(<span class="literal">NULL</span>, <span class="string">"example.com:443:127.0.0.1"</span>);</span><br><span class="line">curl_easy_setopt(curl, CURLOPT_RESOLVE, dns);</span><br></pre></td></tr></table></figure><p>이렇게 하면 “가짜” 주소가 DNS 캐시에 저장되기 때문에 리디렉션 등을 따라갈 때도 작동합니다.</p><h2 id="네임서버-옵션"><a href="#네임서버-옵션" class="headerlink" title="네임서버 옵션"></a>네임서버 옵션</h2><p>c-ares를 사용하도록 빌드된 libcurl의 경우 사용할 DNS 서버와 방법을 세밀하게 제어할 수 있는 몇 가지 옵션이 있습니다. 이것은 이름 해석을 위한 표준 시스템 호출이 사용될 때 사용할 수 없는 권한이기 때문에 순전히 c-are 빌드로 제한됩니다.</p><ul><li><code>CURLOPT_DNS_SERVERS</code>를 통해 애플리케이션은 전용 DNS 서버 세트를 사용하도록 선택할 수 있습니다.</li><li><code>CURLOPT_DNS_INTERFACE</code>를 사용하면 기본 인터페이스 대신 DNS를 사용할 네트워크 인터페이스를 libcurl에 알릴 수 있습니다.</li><li><code>CURLOPT_DNS_LOCAL_IP4</code> 및 <code>CURLOPT_DNS_LOCAL_IP6</code>을 사용하면 응용 프로그램에서 DNS를 바인딩할 특정 네트워크 주소를 지정할 수 있습니다.</li></ul><h2 id="전역-DNS-캐시-없음"><a href="#전역-DNS-캐시-없음" class="headerlink" title="전역 DNS 캐시 없음"></a>전역 DNS 캐시 없음</h2><p><code>CURLOPT_DNS_USE_GLOBAL_CACHE</code>라는 옵션은 한때 curl에 전역 DNS 캐시를 사용하도록 지시했습니다. 이 기능은 7.65.0 이후 제거되었으므로 이 옵션이 여전히 존재하는 동안에는 아무 것도 하지 않습니다.</p>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%EC%9D%B4%EB%A6%84%20%ED%99%95%EC%9D%B8/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl 핸들 간에 데이터 공유</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%ED%95%B8%EB%93%A4%20%EA%B0%84%EC%97%90%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EA%B3%B5%EC%9C%A0/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%ED%95%B8%EB%93%A4%20%EA%B0%84%EC%97%90%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EA%B3%B5%EC%9C%A0/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;핸들-간에-데이터-공유&quot;&gt;&lt;a href=&quot;#핸들-간에-데이터-공유&quot; class=&quot;headerlink&quot; title=&quot;핸들 간에 데이터 공유&quot;&gt;&lt;/a&gt;핸들 간에 데이터 공유&lt;/h1&gt;&lt;p&gt;때때로 응용 프로그램은 전송 간에 데이터를 공유해야 합
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="핸들-간에-데이터-공유"><a href="#핸들-간에-데이터-공유" class="headerlink" title="핸들 간에 데이터 공유"></a>핸들 간에 데이터 공유</h1><p>때때로 응용 프로그램은 전송 간에 데이터를 공유해야 합니다. 동일한 다중 핸들에 추가된 모든 쉬운 핸들은 동일한 다중 핸들의 핸들 간에 많은 공유가 자동으로 수행되지만 때로는 정확히 원하는 것이 아닙니다.</p><h2 id="멀티-핸들"><a href="#멀티-핸들" class="headerlink" title="멀티 핸들"></a>멀티 핸들</h2><p>동일한 다중 핸들에 추가된 모든 간편 핸들은 <a href="https://jung-max.github.io/2022/02/08/Linux-libcurl%20연결%20재사용">연결 캐시</a>와 <a href="https://jung-max.github.io/2022/02/09/Linux-libcurl%20이름%20확인">DNS 캐시</a>를 자동으로 공유합니다.</p><h2 id="쉬운-핸들-간-공유"><a href="#쉬운-핸들-간-공유" class="headerlink" title="쉬운 핸들 간 공유"></a>쉬운 핸들 간 공유</h2><p>libcurl에는 일반 “공유 인터페이스”가 있으며, 여기서 응용 프로그램은 “공유 개체”를 생성한 다음 여러 손쉬운 핸들에서 공유할 수 있는 데이터를 보유합니다. 그런 다음 데이터를 공유하는 핸들 내에 보관하는 대신 공유 개체에서 데이터를 저장하고 읽습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CURLSH *share = curl_share_init();</span><br></pre></td></tr></table></figure><p>공유 객체는 쿠키, 연결 캐시, dns 캐시 및 SSL 세션 ID 캐시의 전체 또는 일부를 공유하도록 설정할 수 있습니다.</p><p>예를 들어 쿠키 및 DNS 캐시를 보유하도록 공유 설정:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_COOKIE);</span><br><span class="line">curl_share_setopt(share, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS);</span><br></pre></td></tr></table></figure><p>그런 다음 이 공유 개체를 사용하도록 해당 전송을 설정합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_easy_setopt(curl, CURLOPT_SHARE, share);</span><br></pre></td></tr></table></figure><p>따라서 이 컬 핸들로 수행된 전송은 공유 핸들의 쿠키 및 DNS 정보를 사용하고 저장합니다. 동일한 공유 개체를 공유하기 위해 여러 개의 쉬운 핸들을 설정할 수 있습니다.</p><h2 id="무엇을-공유할-것인가"><a href="#무엇을-공유할-것인가" class="headerlink" title="무엇을 공유할 것인가"></a>무엇을 공유할 것인가</h2><p><code>CURL_LOCK_DATA_COOKIE</code> - 쿠키 항아리를 공유하려면 이 비트를 설정합니다. 각각의 쉬운 핸들은 쿠키 사용을 시작하기 위해 쿠키 “엔진”을 제대로 시작해야 합니다.</p><p><code>CURL_LOCK_DATA_DNS</code> - DNS 캐시는 libcurl이 이후 조회를 더 빠르게 하기 위해 확인된 호스트 이름에 대한 주소를 잠시 저장하는 곳입니다.</p><p><code>CURL_LOCK_DATA_SSL_SESSION</code> - SSL 세션 ID 캐시는 libcurl이 이전 연결을 더 빨리 재개할 수 있도록 SSL 연결에 대한 재개 정보를 저장하는 곳입니다.</p><p><code>CURL_LOCK_DATA_CONNECT</code> - 설정되면 이 핸들은 공유 연결 캐시를 사용하므로 재사용할 기존 연결을 찾을 가능성이 더 높아져 동일한 호스트에 직렬 방식으로 여러 번 전송할 때 성능이 더 빨라질 수 있습니다.</p><h2 id="잠금"><a href="#잠금" class="headerlink" title="잠금"></a>잠금</h2><p>다중 스레드 환경에서 전송을 통해 공유 개체를 공유하려는 경우. 아마도 많은 코어가 있는 CPU가 있고 각 코어가 자체 스레드를 실행하고 데이터를 전송하기를 원하지만 여전히 다른 전송에서 데이터를 공유하기를 원할 수 있습니다. 그런 다음 뮤텍스 콜백을 설정해야 합니다.</p><p>스레딩을 사용하지 않고 한 번에 하나씩 직렬 방식으로 공유 개체에 액세스한다는 것을 알고 있으면 잠금을 설정할 필요가 없습니다. 그러나 한 번에 공유 개체에 액세스하는 전송이 두 개 이상 있는 경우 데이터 파괴 및 충돌을 방지하기 위해 뮤텍스 콜백 설정을 가져와야 합니다.</p><p>libcurl 자체는 사물을 잠그는 방법이나 사용 중인 스레딩 모델을 알지 못하기 때문에 한 번에 하나의 액세스만 허용하는 뮤텍스 잠금을 수행해야 합니다. pthreads 사용 애플리케이션에 대한 잠금 콜백은 다음과 유사할 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lock_cb</span><span class="params">(CURL *handle, curl_lock_data data,</span></span></span><br><span class="line"><span class="function"><span class="params">                    curl_lock_access access, <span class="keyword">void</span> *userptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pthread_mutex_lock(&amp;lock[data]); <span class="comment">/* uses a global lock array */</span></span><br><span class="line">&#125;</span><br><span class="line">curl_share_setopt(share, CURLSHOPT_LOCKFUNC, lock_cb);</span><br></pre></td></tr></table></figure><p>해당 잠금 해제 콜백을 사용하면 다음과 같이 보일 수 있습니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unlock_cb</span><span class="params">(CURL *handle, curl_lock_data data,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">void</span> *userptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  pthread_mutex_unlock(&amp;lock[data]); <span class="comment">/* uses a global lock array */</span></span><br><span class="line">&#125;</span><br><span class="line">curl_share_setopt(share, CURLSHOPT_UNLOCKFUNC, unlock_cb);</span><br></pre></td></tr></table></figure><h2 id="공유-해제"><a href="#공유-해제" class="headerlink" title="공유 해제"></a>공유 해제</h2><p>전송은 전송 중에 공유 개체를 사용하고 동일한 개체를 공유하는 다른 핸들과 공유하도록 지정된 개체를 공유합니다.</p><p>후속 전송에서 <code>CURLOPT_SHARE</code>를 NULL로 설정하여 전송이 계속 공유되는 것을 방지할 수 있습니다. 이 경우 핸들은 이전에 공유된 데이터에 대한 빈 캐시로 다음 전송을 시작할 수 있습니다.</p><p>두 전송 간에 공유 개체는 다른 속성 집합을 공유하도록 업데이트되어 해당 개체를 공유하는 핸들이 다음에 다른 데이터 집합을 공유할 수도 있습니다. DNS 데이터를 공유 해제할 때 다음과 같이 curl_share_setopt()의 <code>CURLSHOPT_UNSHARE</code> 옵션을 사용하여 공유 개체에서 공유할 항목을 제거합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl_share_setopt(share, CURLSHOPT_UNSHARE, CURL_LOCK_DATA_DNS);</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20%ED%95%B8%EB%93%A4%20%EA%B0%84%EC%97%90%20%EB%8D%B0%EC%9D%B4%ED%84%B0%20%EA%B3%B5%EC%9C%A0/#disqus_thread</comments>
    </item>
    
    <item>
      <title>libcurl --libcurl</title>
      <link>http://jung-max.github.io/2022/02/09/Linux-libcurl%20--libcurl/</link>
      <guid>http://jung-max.github.io/2022/02/09/Linux-libcurl%20--libcurl/</guid>
      <pubDate>Wed, 09 Feb 2022 04:02:00 GMT</pubDate>
      <description>
      
        
        
          &lt;h1 id=&quot;–libcurl&quot;&gt;&lt;a href=&quot;#–libcurl&quot; class=&quot;headerlink&quot; title=&quot;–libcurl&quot;&gt;&lt;/a&gt;–libcurl&lt;/h1&gt;&lt;p&gt;우리는 사용자가 먼저 curl 명령줄 도구로 수행하려는 전송을 시도할 것을 적극 권
        
      
      </description>
      
      
      <content:encoded><![CDATA[<h1 id="–libcurl"><a href="#–libcurl" class="headerlink" title="–libcurl"></a>–libcurl</h1><p>우리는 사용자가 먼저 curl 명령줄 도구로 수행하려는 전송을 시도할 것을 적극 권장하며, 대략 원하는 대로 작동하면 <code>--libcurl [filename]</code> 옵션을 명령줄에 추가하고 다시 다음을 실행합니다.</p><p><code>--libcurl</code> 명령줄 옵션은 제공된 파일 이름으로 C 프로그램을 생성합니다. C 프로그램은 libcurl을 사용하여 방금 curl 명령줄 도구에서 수행한 전송을 실행하는 응용 프로그램입니다. 몇 가지 예외가 있고 항상 100% 일치하는 것은 아니지만 원하는 libcurl 옵션과 사용할 수 있는 libcurl 옵션 및 제공할 추가 인수에 대한 훌륭한 영감 소스 역할을 할 수 있습니다.</p><p><code>--libcurl -</code>과 같이 파일 이름을 단일 대시로 지정하면 파일 대신 stdout에 프로그램이 작성됩니다.</p><p>예를 들어 <code>http://example.com</code>을 가져오는 명령을 실행합니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http:<span class="comment">//example.com --libcurl example.c</span></span><br></pre></td></tr></table></figure><p>이렇게 하면 현재 디렉토리에 다음과 유사한 <code>example.c</code>가 생성됩니다.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/********* Sample code generated by the curl command-line tool **********</span></span><br><span class="line"><span class="comment"> * All curl_easy_setopt() options are documented at:</span></span><br><span class="line"><span class="comment"> * https://curl.se/libcurl/c/curl_easy_setopt.html</span></span><br><span class="line"><span class="comment"> ************************************************************************/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;curl/curl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  CURLcode ret;</span><br><span class="line">  CURL *hnd;</span><br><span class="line"></span><br><span class="line">  hnd = curl_easy_init();</span><br><span class="line">  curl_easy_setopt(hnd, CURLOPT_URL, <span class="string">"http://example.com"</span>);</span><br><span class="line">  curl_easy_setopt(hnd, CURLOPT_NOPROGRESS, <span class="number">1L</span>);</span><br><span class="line">  curl_easy_setopt(hnd, CURLOPT_USERAGENT, <span class="string">"curl/7.45.0"</span>);</span><br><span class="line">  curl_easy_setopt(hnd, CURLOPT_MAXREDIRS, <span class="number">50L</span>);</span><br><span class="line">  curl_easy_setopt(hnd, CURLOPT_SSH_KNOWNHOSTS, <span class="string">"/home/daniel/.ssh/known_hosts"</span>);</span><br><span class="line">  curl_easy_setopt(hnd, CURLOPT_TCP_KEEPALIVE, <span class="number">1L</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Here is a list of options the curl code used that cannot get generated</span></span><br><span class="line"><span class="comment">     as source easily. You may select to either not use them or implement</span></span><br><span class="line"><span class="comment">     them yourself.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  CURLOPT_WRITEDATA set to a objectpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_WRITEFUNCTION set to a functionpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_READDATA set to a objectpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_READFUNCTION set to a functionpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_SEEKDATA set to a objectpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_SEEKFUNCTION set to a functionpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_ERRORBUFFER set to a objectpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_STDERR set to a objectpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_HEADERFUNCTION set to a functionpointer</span></span><br><span class="line"><span class="comment">  CURLOPT_HEADERDATA set to a objectpointer</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  ret = curl_easy_perform(hnd);</span><br><span class="line"></span><br><span class="line">  curl_easy_cleanup(hnd);</span><br><span class="line">  hnd = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">int</span>)ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**** End of sample code ****/</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>http://jung-max.github.io/2022/02/09/Linux-libcurl%20--libcurl/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
